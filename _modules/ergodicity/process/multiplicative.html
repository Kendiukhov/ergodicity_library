<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ergodicity.process.multiplicative &#8212; Ergodicity Library 0.3.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../_static/documentation_options.js?v=e259d695"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="canonical" href="https://kendiukhov.github.io/ergodicity_library/_modules/ergodicity/process/multiplicative.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ergodicity.process.multiplicative</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">multiplicative Submodule</span>

<span class="sd">This submodule provides a comprehensive framework for simulating and analyzing multiplicative stochastic processes.</span>
<span class="sd">These processes model phenomena where changes in value are proportional to the current state, making them</span>
<span class="sd">ideal for capturing growth dynamics, financial modeling, and systems exhibiting exponential behavior. The</span>
<span class="sd">submodule includes implementations of both univariate and multivariate processes, with support for Brownian</span>
<span class="sd">motion, Lévy processes, fractional dynamics, and heavy-tailed distributions.</span>

<span class="sd">Key Features:</span>

<span class="sd">1. **Multiplicative Nature**:</span>

<span class="sd">    - All processes in this submodule exhibit multiplicative growth, meaning that increments are proportional</span>

<span class="sd">      to the current value. This feature is critical for modeling systems where non-negativity and relative</span>

<span class="sd">      changes are fundamental, such as in asset prices or population dynamics.</span>

<span class="sd">2. **Heavy-Tailed Distributions**:</span>

<span class="sd">    - Several processes leverage Lévy stable distributions to capture extreme events and heavy-tailed behavior,</span>
<span class="sd">      accommodating scenarios with infinite variance. This is essential for accurately modeling rare but impactful</span>
<span class="sd">      events, especially in risk management, finance, and natural systems.</span>

<span class="sd">3. **Multidimensional Capabilities**:</span>

<span class="sd">    - Multivariate extensions of key processes allow for the modeling of correlated, interacting systems. These</span>
<span class="sd">      include processes where different components are driven by shared stochastic factors, capturing the</span>
<span class="sd">      interdependence between multiple variables, such as portfolios of financial assets or ecological populations.</span>

<span class="sd">4. **Flexible Simulation and Analysis**:</span>

<span class="sd">    - Built-in methods support the simulation of paths, growth rates, and increments, as well as the calculation</span>
<span class="sd">      of expected values, variances, and higher-order moments. Visualizations through Matplotlib and Plotly</span>
<span class="sd">      further aid in analyzing the behavior of these processes over time.</span>

<span class="sd">Available Processes:</span>

<span class="sd">- **Geometric Brownian Motion (GBM)**:</span>

<span class="sd">    A continuous-time stochastic process commonly used in finance to model stock prices. In this submodule, GBM</span>
<span class="sd">    is extended with customizable drift and volatility parameters and supports both closed-form solutions and</span>
<span class="sd">    simulation of growth rates.</span>

<span class="sd">- **Geometric Lévy Process**:</span>

<span class="sd">    Combines the heavy-tailed properties of Lévy stable distributions with multiplicative dynamics. Useful for</span>
<span class="sd">    modeling processes with large, unpredictable jumps and extreme events.</span>

<span class="sd">- **Multivariate Geometric Brownian Motion (MGBM)**:</span>

<span class="sd">    An extension of GBM to multiple dimensions, allowing for the simulation of correlated stochastic processes</span>
<span class="sd">    with multiplicative growth in each dimension. Ideal for portfolios, interrelated economic indicators, and</span>
<span class="sd">    other systems with multiple interacting components.</span>

<span class="sd">- **Geometric Fractional Brownian Motion**:</span>

<span class="sd">    A fractional extension of Brownian motion incorporating the Hurst parameter to model long-range dependence.</span>
<span class="sd">    Suitable for applications requiring memory effects, such as geophysical or economic time series.</span>

<span class="sd">- **Geometric Cauchy Process**:</span>

<span class="sd">    A specific case of a Lévy process with Cauchy distribution, providing a mechanism for modeling extremely</span>
<span class="sd">    heavy-tailed behavior where variance is infinite.</span>

<span class="sd">- **Multivariate Geometric Lévy Process**:</span>

<span class="sd">    Extends the Lévy process framework to multiple dimensions, allowing for correlated heavy-tailed behaviors</span>
<span class="sd">    across multiple interacting components. This class is particularly useful in fields such as finance, where</span>
<span class="sd">    multiple asset prices or risk factors may exhibit simultaneous extreme behaviors.</span>

<span class="sd">- **Geometric Generalized Hyperbolic Process**:</span>

<span class="sd">    A generalization of the Lévy process that includes the generalized hyperbolic distribution, providing a</span>
<span class="sd">    flexible framework for modeling heavy-tailed phenomena with varying skewness and kurtosis.</span>

<span class="sd">- **Geometric Bessel Process**:</span>

<span class="sd">    A Lévy process based on the Bessel distribution, useful for modeling processes with infinite activity and</span>
<span class="sd">    non-negative jumps. This process is particularly relevant in insurance and risk management contexts.</span>

<span class="sd">- **Geometric Squared Bessel Process**:</span>

<span class="sd">    A variant of the Bessel process where the squared values of the process are considered, leading to different</span>
<span class="sd">    behavior and statistical properties. </span>

<span class="sd">Helper Functions:</span>

<span class="sd">- **implied_levy_correction**:</span>

<span class="sd">    Calculates and visualizes the correction term for a range of alpha and beta parameters, helping to understand</span>
<span class="sd">    the behavior of Lévy processes under various conditions.</span>

<span class="sd">- **estimate_sigma**:</span>

<span class="sd">    Provides an estimate of the sigma parameter for Geometric Lévy Processes across a grid of alpha and time values,</span>
<span class="sd">    with options for linear and non-linear regression to capture sigma dynamics.</span>

<span class="sd">Applications:</span>

<span class="sd">This submodule is versatile and applicable across various fields:</span>

<span class="sd">- **Finance**:</span>

<span class="sd">    For modeling asset prices, portfolios, or other financial quantities where multiplicative dynamics and heavy-tailed</span>
<span class="sd">    behavior are important.</span>

<span class="sd">- **Risk Management**:</span>

<span class="sd">    Particularly useful in scenarios where extreme, rare events (such as market crashes or catastrophic losses)</span>
<span class="sd">    need to be modeled.</span>

<span class="sd">- **Natural Systems**:</span>

<span class="sd">    For capturing exponential growth dynamics, population models, or interacting ecological systems.</span>

<span class="sd">- **Telecommunications**:</span>

<span class="sd">    In modeling bursty network traffic or data flows, where traffic patterns exhibit heavy-tailed behavior and</span>
<span class="sd">    large fluctuations.</span>

<span class="sd">By leveraging these processes, researchers and practitioners can model and analyze complex, real-world systems</span>
<span class="sd">that exhibit multiplicative growth, heavy tails, and interdependencies, offering rich insights into stochastic</span>
<span class="sd">dynamics.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Literal</span>
<span class="kn">from</span> <span class="nn">.definitions</span> <span class="kn">import</span> <span class="n">ItoProcess</span>
<span class="kn">from</span> <span class="nn">.definitions</span> <span class="kn">import</span> <span class="n">NonItoProcess</span>
<span class="kn">from</span> <span class="nn">.definitions</span> <span class="kn">import</span> <span class="n">Process</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">ergodicity.process.definitions</span> <span class="kn">import</span> <span class="n">simulation_decorator</span>
<span class="kn">from</span> <span class="nn">ergodicity.process.definitions</span> <span class="kn">import</span> <span class="n">check_simulate_with_differential</span>
<span class="kn">from</span> <span class="nn">ergodicity.tools.helper</span> <span class="kn">import</span> <span class="n">plot_simulate_ensemble</span>
<span class="kn">from</span> <span class="nn">ergodicity.process.default_values</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">ergodicity.configurations</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">import</span> <span class="nn">plotly.graph_objects</span> <span class="k">as</span> <span class="nn">go</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">r2_score</span>
<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">GeometricBrownianMotion</span> <span class="k">as</span> <span class="n">StochasticGBM</span>
<span class="kn">from</span> <span class="nn">.basic</span> <span class="kn">import</span> <span class="n">BrownianMotion</span>

<div class="viewcode-block" id="GeometricBrownianMotion">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricBrownianMotion">[docs]</a>
<span class="k">class</span> <span class="nc">GeometricBrownianMotion</span><span class="p">(</span><span class="n">BrownianMotion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GeometricBrownianMotion represents a fundamental continuous-time stochastic process used to model the</span>
<span class="sd">    dynamics of various phenomena, particularly in finance and economics. The process, denoted as (S_t)_{t≥0}.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Geometric Brownian Motion&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticGBM</span><span class="p">,</span> <span class="n">drift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">drift_term_default</span><span class="p">,</span> <span class="n">volatility</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">stochastic_term_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Geometric Brownian Motion process.</span>

<span class="sd">        :param name: Name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: Class of the process</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param drift: Drift term of the process</span>
<span class="sd">        :type drift: float</span>
<span class="sd">        :param volatility: Volatility term of the process</span>
<span class="sd">        :type volatility: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">drift</span><span class="p">,</span> <span class="n">volatility</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;geometric&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplicative</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span> <span class="o">=</span> <span class="n">drift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_volatility</span> <span class="o">=</span> <span class="n">volatility</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drift_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_wrong_params</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_simulator</span> <span class="o">=</span> <span class="n">use_external_simulators</span>
        <span class="k">if</span> <span class="n">use_external_simulators</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_wrong_params</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;External simulator for this process may not work properly. We advice to use the internal simulator or make sure you know exactly what you are doing.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drift_term_sympy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stochastic_term_sympy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volatility</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="GeometricBrownianMotion.custom_increment">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricBrownianMotion.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the custom increment for the process.</span>

<span class="sd">        :param X:  Current value of the process</span>
<span class="sd">        :type X: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: Increment for the process</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">timestep</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span> <span class="o">+</span> <span class="n">X</span> <span class="o">*</span> <span class="p">(</span><span class="n">timestep</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volatility</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dX</span></div>


<div class="viewcode-block" id="GeometricBrownianMotion.simulate_growth_rate">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricBrownianMotion.simulate_growth_rate">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_growth_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span>
                             <span class="n">num_instances</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">num_instances_default</span><span class="p">,</span> <span class="n">n_simulations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">num_instances_default</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the growth rate of the Geometric Brownian Motion process.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param num_instances: Number of instances to simulate</span>
<span class="sd">        :type num_instances: int</span>
<span class="sd">        :param save: Whether to save the results to a file</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to plot the results</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return: Array of simulated growth rates</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">average_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_simulations</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_simulations</span><span class="p">):</span>
            <span class="c1"># Simulate weights</span>
            <span class="n">weight_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_weights</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">num_instances</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Extract times and weights</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">weight_data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weight_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>

            <span class="c1"># Calculate growth rate using the formula</span>
            <span class="n">growth_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)):</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">term1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span><span class="p">)</span>
                <span class="n">term2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volatility</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">growth_rates</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">term1</span> <span class="o">+</span> <span class="n">term2</span>

            <span class="c1"># Combine times and growth rates</span>
            <span class="n">growth_rate_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">times</span><span class="p">,</span> <span class="n">growth_rates</span><span class="p">))</span>
            <span class="n">average_rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">growth_rate_data</span>

        <span class="c1"># Calculate average growth rates</span>
        <span class="n">growth_rate_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">average_rates</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;growth_rate_simulation_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">, t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">, timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">, num_instances:</span><span class="si">{</span><span class="n">num_instances</span><span class="si">}</span><span class="s2">.csv&quot;</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;time,growth_rate&#39;</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">growth_rate_data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Growth rates saved to </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_growth_rate</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">growth_rates</span><span class="p">,</span> <span class="n">save</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">growth_rate_data</span></div>


<div class="viewcode-block" id="GeometricBrownianMotion.plot_growth_rate">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricBrownianMotion.plot_growth_rate">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_growth_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">growth_rates</span><span class="p">,</span> <span class="n">save</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the simulated growth rate of the Geometric Brownian Motion process.</span>

<span class="sd">        :param times: Array of time values</span>
<span class="sd">        :type times: np.ndarray</span>
<span class="sd">        :param growth_rates: Array of growth rates</span>
<span class="sd">        :type growth_rates: np.ndarray</span>
<span class="sd">        :param save: Whether to save the plot</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">growth_rates</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Growth Rate&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Growth Rate&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Simulated Growth Rate of Geometric Brownian Motion&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;growth_rate_plot_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="GeometricBrownianMotion.self_averaging_time_theory">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricBrownianMotion.self_averaging_time_theory">[docs]</a>
    <span class="k">def</span> <span class="nf">self_averaging_time_theory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_instances</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">num_instances_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the theoretical estimate of self-averaging time for the Geometric Brownian Motion process.</span>
<span class="sd">        Self-averaging time is the time when the process ensemble exits self-averaging regime.</span>
<span class="sd">        It means that the ensemble average of the process is no more equal to the expected value.</span>

<span class="sd">        :param num_instances: Number of instances to simulate</span>
<span class="sd">        :type num_instances: int</span>
<span class="sd">        :return: Theoretical estimate of self-averaging time</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sat</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">num_instances</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_volatility</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sat</span></div>


<div class="viewcode-block" id="GeometricBrownianMotion.relative_variance_pea_theory">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricBrownianMotion.relative_variance_pea_theory">[docs]</a>
    <span class="k">def</span> <span class="nf">relative_variance_pea_theory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_instances</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">num_instances_default</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the theoretical relative variance of a partial ensemble average (PEA).</span>
<span class="sd">        It is used to estimate if PEA is close to its expectation value.</span>
<span class="sd">        If the results is &lt;&lt;1, then PEA is close to its expectation value.</span>
<span class="sd">        Otherwise, the process has exited the self-averaging regime.</span>

<span class="sd">        :param num_instances: Number of instances to simulate</span>
<span class="sd">        :type num_instances: int</span>
<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :return: Relative variance of the process</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_volatility</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_instances</span>
        <span class="k">return</span> <span class="n">rv</span></div>
</div>


<span class="kn">from</span> <span class="nn">.basic</span> <span class="kn">import</span> <span class="n">LevyStableProcess</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">levy_stable</span>

<span class="kn">import</span> <span class="nn">ergodicity.configurations</span> <span class="k">as</span> <span class="nn">config</span>

<div class="viewcode-block" id="comments_false">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.comments_false">[docs]</a>
<span class="k">def</span> <span class="nf">comments_false</span><span class="p">():</span>
    <span class="n">config</span><span class="o">.</span><span class="n">default_comments</span> <span class="o">=</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="comments_true">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.comments_true">[docs]</a>
<span class="k">def</span> <span class="nf">comments_true</span><span class="p">():</span>
    <span class="n">config</span><span class="o">.</span><span class="n">default_comments</span> <span class="o">=</span> <span class="kc">True</span></div>


<span class="kn">from</span> <span class="nn">ergodicity.tools.compute</span> <span class="kn">import</span> <span class="o">*</span>

<div class="viewcode-block" id="GeometricLevyProcess">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricLevyProcess">[docs]</a>
<span class="k">class</span> <span class="nc">GeometricLevyProcess</span><span class="p">(</span><span class="n">LevyStableProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GeometricLevyProcess represents a stochastic process that combines the heavy-tailed</span>
<span class="sd">    characteristics of Lévy stable distributions with the multiplicative nature of geometric processes.</span>
<span class="sd">    This continuous-time process, denoted as (S_t)_{t≥0}, extends the concept of Geometric Brownian Motion</span>
<span class="sd">    to accommodate more extreme fluctuations and asymmetry often observed in complex systems.</span>

<span class="sd">    where X_t is a Lévy stable process characterized by four key parameters:</span>

<span class="sd">    1. α (alpha): Stability parameter (0 &lt; α ≤ 2), controlling tail heaviness. Smaller values lead to</span>
<span class="sd">       heavier tails and more extreme events.</span>

<span class="sd">    2. β (beta): Skewness parameter (-1 ≤ β ≤ 1), determining the asymmetry of the distribution.</span>

<span class="sd">    3. σ (scale): Scale parameter, influencing the spread of the distribution.</span>

<span class="sd">    4. μ (loc): Location parameter, affecting the central tendency of the process.</span>

<span class="sd">    Key properties of the Geometric Lévy Process include:</span>

<span class="sd">    1. Multiplicative nature: Changes are proportional to the current value, preserving non-negativity.</span>

<span class="sd">    2. Heavy-tailed behavior: Capable of modeling extreme events more effectively than Gaussian-based processes.</span>

<span class="sd">    3. Potential for infinite variance: For α &lt; 2, capturing highly volatile phenomena.</span>

<span class="sd">    4. Self-similarity: Exhibiting fractal-like behavior in certain parameter regimes.</span>

<span class="sd">    This implementation inherits from LevyStableProcess, adapting it to a geometric framework. It&#39;s</span>
<span class="sd">    explicitly set as multiplicative (_multiplicative = True) and uses an internal simulator</span>
<span class="sd">    (_external_simulator = False) for precise control over the process generation.</span>

<span class="sd">    The class is versatile, finding applications in various fields:</span>

<span class="sd">    - Financial modeling: Asset prices with extreme movements, particularly in volatile markets.</span>

<span class="sd">    - Risk management: Modeling scenarios with potential for large, sudden changes.</span>

<span class="sd">    - Physics: Describing growth processes in complex systems with potential for rapid fluctuations.</span>

<span class="sd">    - Telecommunications: Modeling bursty traffic patterns in networks.</span>

<span class="sd">    Notable features:</span>

<span class="sd">    - Flexible parameterization: Allows fine-tuning of tail behavior, skewness, scale, and location.</span>

<span class="sd">    - Simulation control: Uses differential-based simulation (_simulate_with_differential = True) for</span>
<span class="sd">      accurate trajectory generation.</span>

<span class="sd">    - Type categorization: Classified under both &quot;geometric&quot; and &quot;levy&quot; types, reflecting its dual nature.</span>

<span class="sd">    Researchers and practitioners should be aware of the increased complexity in parameter estimation</span>
<span class="sd">    and interpretation compared to Gaussian-based models. The rich behavior of this process, especially</span>
<span class="sd">    for α &lt; 2, requires careful consideration in application and analysis. While powerful in capturing</span>
<span class="sd">    extreme behaviors, users should ensure the chosen parameters align with the underlying phenomena</span>
<span class="sd">    being modeled and be prepared for potentially counterintuitive results in statistical analyses.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Geometric Levy Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">alpha_default</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">beta_default</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">scale_default</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Geometric Levy Process with the specified parameters.</span>

<span class="sd">        :param name: Name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: Class of the process</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param alpha: Stability parameter (0 &lt; α ≤ 2)</span>
<span class="sd">        :type alpha: float</span>
<span class="sd">        :param beta: Skewness parameter (-1 ≤ β ≤ 1)</span>
<span class="sd">        :type beta: float</span>
<span class="sd">        :param scale: Scale parameter</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :param loc: Location parameter</span>
<span class="sd">        :type loc: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;geometric&quot;</span><span class="p">,</span> <span class="s2">&quot;levy&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplicative</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loc_scaled</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">/</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_simulate_with_differential</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_simulator</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="GeometricLevyProcess.custom_increment">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricLevyProcess.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the custom increment for the process.</span>

<span class="sd">        :param X: Current value of the process</span>
<span class="sd">        :type X: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: Increment for the process</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">simulate_with_differential</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">LevyStableProcess</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">dL</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">timestep_increment</span><span class="o">=</span><span class="n">timestep</span><span class="p">)</span>
            <span class="n">dX</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">dL</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dX</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span> <span class="o">*</span> <span class="n">timestep</span> <span class="o">+</span> <span class="n">X</span> <span class="o">*</span> <span class="p">(</span><span class="n">timestep</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="n">levy_stable</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                            <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dX</span></div>


<div class="viewcode-block" id="GeometricLevyProcess.sigma_divergence">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricLevyProcess.sigma_divergence">[docs]</a>
    <span class="k">def</span> <span class="nf">sigma_divergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the divergence between the theoretical and empirical sigma values for the process.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: Theoretical and empirical sigma values</span>
<span class="sd">        :rtype: Any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">theoretical_sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="o">=</span><span class="n">timestep</span><span class="p">,</span> <span class="n">num_instances</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">skewness</span><span class="p">,</span> <span class="n">kurtosis</span><span class="p">,</span> <span class="n">mad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="o">=</span><span class="n">timestep</span><span class="p">,</span>
                                                                      <span class="n">num_instances</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Convert variance to a 1D array if it&#39;s not already</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variance</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">variance</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">variance</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="n">empirical_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>

        <span class="c1"># Ensure times and empirical_sigma have the same length</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">empirical_sigma</span><span class="p">):</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">empirical_sigma</span><span class="p">)]</span>

        <span class="c1"># Plot theoretical vs empirical sigma</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">theoretical_sigma</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Theoretical Sigma&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">empirical_sigma</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Empirical Sigma&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Sigma&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Theoretical vs Empirical Sigma&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">theoretical_sigma</span><span class="p">,</span> <span class="n">empirical_sigma</span></div>


<div class="viewcode-block" id="GeometricLevyProcess.implied_correction">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricLevyProcess.implied_correction">[docs]</a>
    <span class="k">def</span> <span class="nf">implied_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the implied correction term for the Geometric Levy Process (analogoys to -0.5 * sigma^2 * t for GBM).</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the results</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to plot the results</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return: Implied correction</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="o">=</span><span class="n">timestep</span><span class="p">,</span> <span class="n">num_instances</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">skewness</span><span class="p">,</span> <span class="n">kurtosis</span><span class="p">,</span> <span class="n">mad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="o">=</span><span class="n">timestep</span><span class="p">,</span>
                                                                      <span class="n">num_instances</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># theoretical_sigma = self._scale / ((1 / 2) ** 0.5)</span>

        <span class="n">average_growth_rate_values</span> <span class="o">=</span> <span class="n">average_growth_rate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">visualize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">average_growth_rate_values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">data_increments</span> <span class="o">=</span> <span class="n">relative_increments</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">visualize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">mu_sigma</span><span class="p">(</span><span class="n">data_increments</span><span class="p">)</span>

        <span class="n">mu_implied</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span>
        <span class="n">sigma_implied</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">growth_function</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">times</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">times</span>

        <span class="c1"># implied_growth_function = mu_implied * times - correction * sigma_implied ** 2 * times</span>

        <span class="n">naive_growth_function</span> <span class="o">=</span> <span class="n">mu_implied</span> <span class="o">*</span> <span class="n">times</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sigma_implied</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">times</span>

        <span class="n">correction</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu_implied</span> <span class="o">-</span> <span class="n">mu</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sigma_implied</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">average_growth_rate_values</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Growth Rate&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">growth_function</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Growth function&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">naive_growth_function</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Naive Growth function&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Comparison of growth functions&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Value&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;comparison_of_averages_vs_gbm.png&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Implied correction: </span><span class="si">{</span><span class="n">correction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">correction</span></div>
</div>


<span class="kn">from</span> <span class="nn">.basic</span> <span class="kn">import</span> <span class="n">MultivariateBrownianMotion</span>
<div class="viewcode-block" id="MultivariateGeometricBrownianMotion">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.MultivariateGeometricBrownianMotion">[docs]</a>
<span class="k">class</span> <span class="nc">MultivariateGeometricBrownianMotion</span><span class="p">(</span><span class="n">MultivariateBrownianMotion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MultivariateGeometricBrownianMotion represents a sophisticated extension of Geometric Brownian Motion</span>
<span class="sd">    to multiple dimensions, providing a powerful framework for modeling correlated, exponentially growing</span>
<span class="sd">    processes subject to random fluctuations. This continuous-time stochastic process, denoted as</span>
<span class="sd">    (S_t)_{t≥0} where S_t is a vector in R^n, is characterized by the system of stochastic differential</span>
<span class="sd">    equations:</span>

<span class="sd">    dS_i(t) = μ_i S_i(t) dt + Σ_ij S_i(t) dW_j(t)  for i = 1, ..., n</span>

<span class="sd">    where:</span>

<span class="sd">    - μ (drift) is a vector representing the average rates of return or growth for each component</span>

<span class="sd">    - Σ (scale) is a matrix capturing both volatilities and correlations between components</span>

<span class="sd">    - W_t is a vector of standard Brownian motions</span>

<span class="sd">    Key properties include:</span>

<span class="sd">    1. Multiplicative nature in each dimension: Changes are proportional to current values, preserving</span>
<span class="sd">       non-negativity of each component.</span>

<span class="sd">    2. Log-normality: The logarithm of each component follows a multivariate normal distribution.</span>

<span class="sd">    3. Complex correlation structure: Allows modeling of intricate dependencies between components.</span>

<span class="sd">    4. Non-stationary: Variances and covariances increase over time.</span>

<span class="sd">    This implementation extends the MultivariateBrownianMotion class, adapting it to the geometric nature</span>
<span class="sd">    of the process. It&#39;s explicitly set as multiplicative (_multiplicative = True) and uses an internal</span>
<span class="sd">    simulator (_external_simulator = False) for precise control over the process generation.</span>

<span class="sd">    Notable features:</span>

<span class="sd">    - Flexible initialization: Accepts drift vector and scale matrix as inputs, allowing for detailed</span>
<span class="sd">      specification of growth rates and interdependencies.</span>

<span class="sd">    - Numpy integration: Utilizes numpy arrays for efficient computation and manipulation of</span>
<span class="sd">      multi-dimensional data.</span>

<span class="sd">    - Parameter handling: The _has_wrong_params flag is set to True, indicating potential need for</span>
<span class="sd">      parameter adjustment in certain contexts.</span>

<span class="sd">    - Initial state: _X is initialized to a vector of ones, reflecting the typical starting point for</span>
<span class="sd">      geometric processes.</span>

<span class="sd">    Researchers and practitioners should be aware of the increased complexity in parameter estimation</span>
<span class="sd">    and interpretation compared to univariate models. The interplay between drift components and the</span>
<span class="sd">    scale matrix requires careful consideration, particularly in high-dimensional settings. While</span>
<span class="sd">    powerful in capturing complex, correlated growth phenomena, users should ensure the model&#39;s</span>
<span class="sd">    assumptions align with the characteristics of the system being studied. The log-normal nature of</span>
<span class="sd">    the process may not be suitable for all applications, and consideration of alternative multivariate</span>
<span class="sd">    processes (e.g., based on Lévy processes) might be necessary for scenarios involving more extreme</span>
<span class="sd">    events or heavier tails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Multivariate Geometric Brownian Motion&quot;</span><span class="p">,</span> <span class="n">drift</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_list_default</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="n">variance_matrix_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Multivariate Geometric Brownian Motion process.</span>

<span class="sd">        :param name: Name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param drift: Drift term of the process</span>
<span class="sd">        :type drift: List[float]</span>
<span class="sd">        :param scale: Volatility term of the process</span>
<span class="sd">        :type scale: List[List[float]]</span>
<span class="sd">        :raises ValueError: If drift and scale have different shapes</span>
<span class="sd">        :raises ValueError: If the scale matrix is not symmetric and positive definite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">drift</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;geometric&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplicative</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">drift</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drift_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stochastic_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_wrong_params</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drift</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_simulator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drift</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Drift and scale must have the same shape&quot;</span><span class="p">)</span>
        <span class="c1"># check if the scale matrix is symmetric and positive definite</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Scale matrix must be symmetric and positive definite&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MultivariateGeometricBrownianMotion.custom_increment">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.MultivariateGeometricBrownianMotion.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the custom increment for the process.</span>

<span class="sd">        :param X: Current values of the process</span>
<span class="sd">        :type X: List[float]</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: Increment for the process</span>
<span class="sd">        :rtype: List[float]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># mvbm = MultivariateBrownianMotion(drift=[0]*len(self._drift), scale=self._scale)</span>
        <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drift</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="n">timestep</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drift</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span>
        <span class="k">return</span> <span class="n">dX</span></div>


<div class="viewcode-block" id="MultivariateGeometricBrownianMotion.simulate_weights">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.MultivariateGeometricBrownianMotion.simulate_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                  <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the weights of the Multivariate Geometric Brownian Motion process.</span>

<span class="sd">        :param t: Total simulation time</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the results</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to plot the results</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return: Array of simulated weights</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Simulate the process</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Extract the simulated values (exclude the time column)</span>
        <span class="n">simulated_values</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>

        <span class="c1"># Calculate weights (shares)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">simulated_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">simulated_values</span> <span class="o">/</span> <span class="n">total</span>

        <span class="c1"># Prepare data for saving</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">weight_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">times</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_to_file</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                          <span class="sa">f</span><span class="s2">&quot;weights_simulation_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">, t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">, timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">, num_instances:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">,</span>
                          <span class="n">save</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Weight </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Weight&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Simulated Weights of Multivariate Brownian Motion&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;weights_plot_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">, t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">, timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">weight_data</span></div>


<div class="viewcode-block" id="MultivariateGeometricBrownianMotion.calculate_expected_log_growth_rate">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.MultivariateGeometricBrownianMotion.calculate_expected_log_growth_rate">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_expected_log_growth_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the expected log growth rate at each time step.</span>

<span class="sd">        :param weights: numpy array of shape (num_instances, num_time_steps)</span>
<span class="sd">        :type weights: np.ndarray</span>
<span class="sd">        :return: numpy array of expected log growth rates for each time step</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_time_steps</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">log_growth_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_time_steps</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_time_steps</span><span class="p">):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>

            <span class="c1"># First term: sum(w_i * mu_i)</span>
            <span class="n">term1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span><span class="p">)</span>

            <span class="c1"># Second term: -0.5 * (sum(w_i^2 * sigma_i^2) + sum(sum(w_i * w_j * cov(i,j))))</span>
            <span class="n">variance_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">))</span>

            <span class="n">covariance_term</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">):</span>
                    <span class="n">covariance_term</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

            <span class="n">term2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">variance_term</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">covariance_term</span><span class="p">)</span>

            <span class="n">log_growth_rates</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">term1</span> <span class="o">+</span> <span class="n">term2</span>

        <span class="k">return</span> <span class="n">log_growth_rates</span></div>


<div class="viewcode-block" id="MultivariateGeometricBrownianMotion.simulate_growth_rate">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.MultivariateGeometricBrownianMotion.simulate_growth_rate">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_growth_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span> <span class="n">n_simulations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">num_instances_default</span><span class="p">,</span>
                                           <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the expected log growth rate of the Multivariate Geometric Brownian Motion process.</span>

<span class="sd">        :param t: Total simulation time</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param n_simulations: Number of simulations to average</span>
<span class="sd">        :type n_simulations: int</span>
<span class="sd">        :param save: Whether to save the results</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to plot the results</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return: Array of simulated expected log growth rates</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">average_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_simulations</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_simulations</span><span class="p">):</span>
          <span class="c1"># Simulate weights</span>
            <span class="n">weight_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_weights</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Extract weights (exclude time column)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weight_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>

            <span class="c1"># Calculate expected log growth rate</span>
            <span class="n">log_growth_rates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_expected_log_growth_rate</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

            <span class="c1"># Combine data</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">weight_data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">combined_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">times</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">log_growth_rates</span><span class="p">))</span>
            <span class="n">average_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined_data</span>

        <span class="c1"># Calculate average data</span>
        <span class="n">combined_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">average_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;weights_and_growth_rate_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">, t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">, timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">.csv&quot;</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;weight_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;log_growth_rate&#39;</span><span class="p">])</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">combined_data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Weights and growth rate saved to </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_weights_and_growth_rate</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">log_growth_rates</span><span class="p">,</span> <span class="n">save</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">combined_data</span></div>


<div class="viewcode-block" id="MultivariateGeometricBrownianMotion.plot_weights_and_growth_rate">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.MultivariateGeometricBrownianMotion.plot_weights_and_growth_rate">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_weights_and_growth_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">log_growth_rates</span><span class="p">,</span> <span class="n">save</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the simulated weights and expected log growth rate of the Multivariate Geometric Brownian Motion process.</span>

<span class="sd">        :param times: Array of time values</span>
<span class="sd">        :type times: np.ndarray</span>
<span class="sd">        :param weights: Array of weights</span>
<span class="sd">        :type weights: np.ndarray</span>
<span class="sd">        :param log_growth_rates: Array of expected log growth rates</span>
<span class="sd">        :type log_growth_rates: np.ndarray</span>
<span class="sd">        :param save: Whether to save the plot</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Plot weights</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">):</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Weight </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Weight&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Simulated Weights of Multivariate Brownian Motion&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Plot log growth rate</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">log_growth_rates</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Log Growth Rate&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Log Growth Rate&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Expected Log Growth Rate&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;weights_and_growth_rate_plot_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="MultivariateGeometricBrownianMotion.simulate_ensemble">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.MultivariateGeometricBrownianMotion.simulate_ensemble">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_ensemble</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">num_instances_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a single path for a portfolio consisting of multiple instances.</span>

<span class="sd">        :param t: Total simulation time</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param num_instances: Number of instances in the portfolio</span>
<span class="sd">        :type num_instances: int</span>
<span class="sd">        :param save: Whether to save the results</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :return: Array of portfolio values and geometric means over time</span>
<span class="sd">        :rtype: Any</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">num_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drift</span><span class="p">)</span>
        <span class="n">num_instances</span> <span class="o">=</span> <span class="n">dim</span>

        <span class="c1"># Initialize arrays</span>
        <span class="n">portfolio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_instances</span><span class="p">,</span> <span class="n">num_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">geometric_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_instances</span><span class="p">,</span> <span class="n">num_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">num_instances</span>  <span class="c1"># Initialize weights</span>

        <span class="c1"># Ensure _scale is a numpy array for matrix operations</span>
        <span class="n">covariance_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Calculate weights</span>
            <span class="n">weights</span><span class="p">[:,</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">portfolio</span><span class="p">[:,</span> <span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">portfolio</span><span class="p">[:,</span> <span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Generate increments according to the formula</span>
            <span class="n">drift_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drift</span><span class="p">)</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[:,</span> <span class="n">step</span><span class="p">]</span> <span class="o">*</span> <span class="n">timestep</span>
            <span class="n">variance_term</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights</span><span class="p">[:,</span> <span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                                 <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">covariance_matrix</span><span class="p">,</span>
                                                        <span class="n">weights</span><span class="p">[:,</span> <span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="o">*</span> <span class="n">timestep</span>
            <span class="n">increments_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="c1"># Generate random normal values for the stochastic term</span>
                <span class="n">random_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">covariance_matrix</span> <span class="o">*</span> <span class="n">timestep</span><span class="p">)</span>
                <span class="n">increments</span> <span class="o">=</span> <span class="n">drift_term</span> <span class="o">-</span> <span class="n">variance_term</span> <span class="o">+</span> <span class="n">random_term</span>
                <span class="n">increments_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">increments</span><span class="p">)</span>

            <span class="n">increments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">increments_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Update portfolio values</span>
            <span class="n">portfolio</span><span class="p">[:,</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">portfolio</span><span class="p">[:,</span> <span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">increments</span><span class="p">)</span>

            <span class="c1"># Calculate the new geometric mean</span>
            <span class="n">geometric_means</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">portfolio</span><span class="p">[:,</span> <span class="n">step</span><span class="p">]</span> <span class="o">**</span> <span class="n">weights</span><span class="p">[:,</span> <span class="n">step</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">step</span><span class="o">/</span><span class="n">num_steps</span> <span class="o">%</span> <span class="mf">0.01</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">step</span><span class="o">/</span><span class="n">num_steps</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s1">% done&#39;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;portfolio&#39;</span><span class="p">:</span> <span class="n">portfolio</span><span class="p">,</span>
            <span class="s1">&#39;geometric_means&#39;</span><span class="p">:</span> <span class="n">geometric_means</span><span class="p">,</span>
            <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">weights</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;portfolio_simulation.npy&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

        <span class="c1"># Call the plotting function</span>
        <span class="n">plot_simulate_ensemble</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">save</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>
</div>


<span class="kn">from</span> <span class="nn">ergodicity.process.basic</span> <span class="kn">import</span> <span class="n">StandardFractionalBrownianMotion</span>

<div class="viewcode-block" id="GeometricFractionalBrownianMotion">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricFractionalBrownianMotion">[docs]</a>
<span class="k">class</span> <span class="nc">GeometricFractionalBrownianMotion</span><span class="p">(</span><span class="n">NonItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MultivariateGeometricBrownianMotion represents a sophisticated extension of Geometric Brownian Motion</span>
<span class="sd">    to multiple dimensions, providing a powerful framework for modeling correlated, exponentially growing</span>
<span class="sd">    processes subject to random fluctuations. This continuous-time stochastic process, denoted as</span>
<span class="sd">    (S_t)_{t≥0} where S_t is a vector in R^n, is characterized by the system of stochastic differential</span>
<span class="sd">    equations:</span>

<span class="sd">    dS_i(t) = μ_i S_i(t) dt + Σ_ij S_i(t) dW_j(t)  for i = 1, ..., n</span>

<span class="sd">    where:</span>

<span class="sd">    - μ (drift) is a vector representing the average rates of return or growth for each component</span>

<span class="sd">    - Σ (scale) is a matrix capturing both volatilities and correlations between components</span>

<span class="sd">    - W_t is a vector of standard Brownian motions</span>

<span class="sd">    Key properties include:</span>

<span class="sd">    1. Multiplicative nature in each dimension: Changes are proportional to current values, preserving</span>
<span class="sd">       non-negativity of each component.</span>

<span class="sd">    2. Log-normality: The logarithm of each component follows a multivariate normal distribution.</span>

<span class="sd">    3. Complex correlation structure: Allows modeling of intricate dependencies between components.</span>

<span class="sd">    4. Non-stationary: Variances and covariances increase over time.</span>

<span class="sd">    This implementation extends the MultivariateBrownianMotion class, adapting it to the geometric nature</span>
<span class="sd">    of the process. It&#39;s explicitly set as multiplicative (_multiplicative = True) and uses an internal</span>
<span class="sd">    simulator (_external_simulator = False) for precise control over the process generation.</span>

<span class="sd">    Notable features:</span>

<span class="sd">    - Flexible initialization: Accepts drift vector and scale matrix as inputs, allowing for detailed</span>
<span class="sd">      specification of growth rates and interdependencies.</span>

<span class="sd">    - Numpy integration: Utilizes numpy arrays for efficient computation and manipulation of</span>
<span class="sd">      multi-dimensional data.</span>

<span class="sd">    - Parameter handling: The _has_wrong_params flag is set to True, indicating potential need for</span>
<span class="sd">      parameter adjustment in certain contexts.</span>

<span class="sd">    - Initial state: _X is initialized to a vector of ones, reflecting the typical starting point for</span>
<span class="sd">      geometric processes.</span>

<span class="sd">    Researchers and practitioners should be aware of the increased complexity in parameter estimation</span>
<span class="sd">    and interpretation compared to univariate models. The interplay between drift components and the</span>
<span class="sd">    scale matrix requires careful consideration, particularly in high-dimensional settings. While</span>
<span class="sd">    powerful in capturing complex, correlated growth phenomena, users should ensure the model&#39;s</span>
<span class="sd">    assumptions align with the characteristics of the system being studied. The log-normal nature of</span>
<span class="sd">    the process may not be suitable for all applications, and consideration of alternative multivariate</span>
<span class="sd">    processes (e.g., based on Lévy processes) might be necessary for scenarios involving more extreme</span>
<span class="sd">    events or heavier tails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Geometric Fractional Brownian Motion&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mean</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">drift_term_default</span><span class="p">,</span> <span class="n">volatility</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">stochastic_term_default</span><span class="p">,</span> <span class="n">hurst</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">hurst_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Geometric Fractional Brownian Motion process.</span>

<span class="sd">        :param name: Name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: Class of the process</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param mean: Drift term of the process</span>
<span class="sd">        :type mean: float</span>
<span class="sd">        :param volatility: Volatility term of the process</span>
<span class="sd">        :type volatility: float</span>
<span class="sd">        :param hurst: Hurst parameter of the process</span>
<span class="sd">        :type hurst: float</span>
<span class="sd">        :raises ValueError: If the Hurst parameter is outside the valid range (0, 1)</span>
<span class="sd">        :raises ValueError: If the volatility is non-positive</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;geometric&quot;</span><span class="p">,</span> <span class="s2">&quot;fractional&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplicative</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">hurst</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">hurst</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Hurst parameter must be in the range (0, 1)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hurst</span> <span class="o">=</span> <span class="n">hurst</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drift_term</span> <span class="o">=</span> <span class="n">mean</span>
        <span class="k">if</span> <span class="n">volatility</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Volatility must be positive&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stochastic_term</span> <span class="o">=</span> <span class="n">volatility</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_wrong_params</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_simulator</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="GeometricFractionalBrownianMotion.custom_increment">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricFractionalBrownianMotion.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the custom increment for the process.</span>
<span class="sd">        :param X:   Current value of the process</span>
<span class="sd">        :param timestep:    Time step for the simulation</span>
<span class="sd">        :return:    Increment for the process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">FBM</span> <span class="o">=</span> <span class="n">StandardFractionalBrownianMotion</span><span class="p">(</span><span class="n">hurst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hurst</span><span class="p">)</span>
        <span class="n">dW</span> <span class="o">=</span> <span class="n">FBM</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">timestep_increment</span><span class="o">=</span><span class="n">timestep</span><span class="p">)</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drift_term</span> <span class="o">*</span> <span class="n">timestep</span> <span class="o">+</span> <span class="n">X</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stochastic_term</span> <span class="o">*</span> <span class="p">(</span><span class="n">timestep</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hurst</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span>
        <span class="k">return</span> <span class="n">dX</span></div>
</div>


<div class="viewcode-block" id="GeometricCauchyProcess">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricCauchyProcess">[docs]</a>
<span class="k">class</span> <span class="nc">GeometricCauchyProcess</span><span class="p">(</span><span class="n">GeometricLevyProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MultivariateGeometricBrownianMotion represents a sophisticated extension of Geometric Brownian Motion</span>
<span class="sd">    to multiple dimensions, providing a powerful framework for modeling correlated, exponentially growing</span>
<span class="sd">    processes subject to random fluctuations. This continuous-time stochastic process, denoted as</span>
<span class="sd">    (S_t)_{t≥0} where S_t is a vector in R^n, is characterized by the system of stochastic differential</span>
<span class="sd">    equations:</span>

<span class="sd">    dS_i(t) = μ_i S_i(t) dt + Σ_ij S_i(t) dW_j(t)  for i = 1, ..., n</span>

<span class="sd">    where:</span>

<span class="sd">    - μ (drift) is a vector representing the average rates of return or growth for each component</span>

<span class="sd">    - Σ (scale) is a matrix capturing both volatilities and correlations between components</span>

<span class="sd">    - W_t is a vector of standard Brownian motions</span>

<span class="sd">    Key properties include:</span>

<span class="sd">    1. Multiplicative nature in each dimension: Changes are proportional to current values, preserving</span>
<span class="sd">       non-negativity of each component.</span>

<span class="sd">    2. Log-normality: The logarithm of each component follows a multivariate normal distribution.</span>

<span class="sd">    3. Complex correlation structure: Allows modeling of intricate dependencies between components.</span>

<span class="sd">    4. Non-stationary: Variances and covariances increase over time.</span>

<span class="sd">    This implementation extends the MultivariateBrownianMotion class, adapting it to the geometric nature</span>
<span class="sd">    of the process. It&#39;s explicitly set as multiplicative (_multiplicative = True) and uses an internal</span>
<span class="sd">    simulator (_external_simulator = False) for precise control over the process generation.</span>

<span class="sd">    Notable features:</span>

<span class="sd">    - Flexible initialization: Accepts drift vector and scale matrix as inputs, allowing for detailed</span>
<span class="sd">      specification of growth rates and interdependencies.</span>

<span class="sd">    - Numpy integration: Utilizes numpy arrays for efficient computation and manipulation of</span>
<span class="sd">      multi-dimensional data.</span>

<span class="sd">    - Parameter handling: The _has_wrong_params flag is set to True, indicating potential need for</span>
<span class="sd">      parameter adjustment in certain contexts.</span>

<span class="sd">    - Initial state: _X is initialized to a vector of ones, reflecting the typical starting point for</span>
<span class="sd">      geometric processes.</span>

<span class="sd">    Researchers and practitioners should be aware of the increased complexity in parameter estimation</span>
<span class="sd">    and interpretation compared to univariate models. The interplay between drift components and the</span>
<span class="sd">    scale matrix requires careful consideration, particularly in high-dimensional settings. While</span>
<span class="sd">    powerful in capturing complex, correlated growth phenomena, users should ensure the model&#39;s</span>
<span class="sd">    assumptions align with the characteristics of the system being studied. The log-normal nature of</span>
<span class="sd">    the process may not be suitable for all applications, and consideration of alternative multivariate</span>
<span class="sd">    processes (e.g., based on Lévy processes) might be necessary for scenarios involving more extreme</span>
<span class="sd">    events or heavier tails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Geometric Cauchy Process&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">scale_default</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Geometric Cauchy Process with the specified parameters.</span>

<span class="sd">        :param name: Name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param scale: Scale parameter</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :param loc: Location parameter</span>
<span class="sd">        :type loc: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;geometric&quot;</span><span class="p">,</span> <span class="s2">&quot;cauchy&quot;</span><span class="p">]</span></div>


<span class="kn">from</span> <span class="nn">ergodicity.process.basic</span> <span class="kn">import</span> <span class="n">MultivariateLevy</span>
<div class="viewcode-block" id="MultivariateGeometricLevy">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.MultivariateGeometricLevy">[docs]</a>
<span class="k">class</span> <span class="nc">MultivariateGeometricLevy</span><span class="p">(</span><span class="n">MultivariateLevy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MultivariateGeometricLevy represents an advanced stochastic process that combines the heavy-tailed</span>
<span class="sd">    characteristics of multivariate Lévy stable distributions with the multiplicative nature of geometric</span>
<span class="sd">    processes in multiple dimensions. This sophisticated continuous-time process, denoted as (S_t)_{t≥0}</span>
<span class="sd">    where S_t is a vector in R^n, is defined by the exponential of a multivariate Lévy stable process:</span>

<span class="sd">    S_i(t) = S_i(0) * exp(X_i(t))  for i = 1, ..., n</span>

<span class="sd">    where X(t) = (X_1(t), ..., X_n(t)) is a multivariate Lévy stable process.</span>

<span class="sd">    Key parameters:</span>

<span class="sd">    1. alpha (α): Stability parameter (0 &lt; α ≤ 2), controlling tail heaviness across all dimensions.</span>

<span class="sd">    2. beta (β): Skewness parameter (-1 ≤ β ≤ 1), determining asymmetry.</span>

<span class="sd">    3. scale: Global scale parameter influencing the spread of the distribution.</span>

<span class="sd">    4. loc: Location vector (μ ∈ R^n), shifting the process in each dimension.</span>

<span class="sd">    5. correlation_matrix: Specifies the correlation structure between dimensions.</span>

<span class="sd">    6. pseudovariances: Vector of pseudovariances for each dimension, generalizing the concept of variance.</span>

<span class="sd">    Key properties:</span>

<span class="sd">    1. Heavy-tailed behavior: Capable of modeling extreme events in multiple dimensions simultaneously.</span>

<span class="sd">    2. Complex dependency structure: Captures intricate correlations between components.</span>

<span class="sd">    3. Multiplicative nature: Preserves non-negativity in each dimension, suitable for modeling quantities</span>
<span class="sd">       like prices or sizes.</span>

<span class="sd">    4. Potential for infinite variance: For α &lt; 2, allowing for highly volatile phenomena in multiple dimensions.</span>

<span class="sd">    This implementation extends the MultivariateLevy class, adapting it to a geometric framework. It&#39;s</span>
<span class="sd">    explicitly set as multiplicative (_multiplicative = True) and uses an internal simulator</span>
<span class="sd">    (_external_simulator = False) for precise control over the process generation.</span>

<span class="sd">    Notable features:</span>

<span class="sd">    - Flexible parameterization: Allows fine-tuning of tail behavior, skewness, scale, and multidimensional dependencies.</span>

<span class="sd">    - Initialization with unit values: _X is initialized to a vector of ones, reflecting the typical starting point</span>
<span class="sd">      for geometric processes.</span>

<span class="sd">    - Parameter handling: The _has_wrong_params flag is set to True, indicating potential need for parameter</span>
<span class="sd">      adjustment in certain contexts.</span>

<span class="sd">    Researchers and practitioners should be aware of several important considerations:</span>

<span class="sd">    1. Increased complexity in parameter estimation and interpretation compared to Gaussian-based multivariate models.</span>

<span class="sd">    2. Computational challenges in simulating and analyzing high-dimensional heavy-tailed processes.</span>

<span class="sd">    3. The need for specialized statistical techniques to handle the lack of finite moments when α &lt; 2.</span>

<span class="sd">    4. Careful interpretation of results, especially in risk assessment and forecasting, due to the process&#39;s</span>
<span class="sd">       capacity for extreme behaviors.</span>

<span class="sd">    While the MultivariateGeometricLevy process offers a powerful framework for modeling complex, correlated,</span>
<span class="sd">    heavy-tailed phenomena in multiple dimensions, its sophisticated nature requires judicious application.</span>
<span class="sd">    Users should ensure that the chosen parameters align with the underlying phenomena being modeled and be</span>
<span class="sd">    prepared for potentially counterintuitive results in statistical analyses. The process&#39;s rich behavior,</span>
<span class="sd">    especially for α &lt; 2, necessitates careful consideration in both theoretical development and practical applications.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Multivariate Geometric Levy Process&quot;</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">loc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">correlation_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">pseudovariances</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Multivariate Geometric Levy Process with the specified parameters.</span>

<span class="sd">        :param name: Name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param alpha: Stability parameter (0 &lt; α ≤ 2)</span>
<span class="sd">        :type alpha: float</span>
<span class="sd">        :param beta: Skewness parameter (-1 ≤ β ≤ 1)</span>
<span class="sd">        :type beta: float</span>
<span class="sd">        :param scale: Scale parameter</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :param loc: Location parameter</span>
<span class="sd">        :type loc: np.ndarray</span>
<span class="sd">        :param correlation_matrix: Correlation matrix</span>
<span class="sd">        :type correlation_matrix: np.ndarray</span>
<span class="sd">        :param pseudovariances: Pseudovariances</span>
<span class="sd">        :type pseudovariances: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span>
                         <span class="n">correlation_matrix</span><span class="o">=</span><span class="n">correlation_matrix</span><span class="p">,</span> <span class="n">pseudovariances</span><span class="o">=</span><span class="n">pseudovariances</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;geometric&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplicative</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_wrong_params</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_simulator</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="MultivariateGeometricLevy.custom_increment">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.MultivariateGeometricLevy.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the custom increment for the process.</span>

<span class="sd">        :param X: Current values of the process</span>
<span class="sd">        :type X: np.ndarray</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: Increment for the process</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate Levy increments</span>
        <span class="n">dL</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">custom_increment</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>

        <span class="c1"># Calculate the drift term</span>
        <span class="n">drift_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span> <span class="o">*</span> <span class="n">timestep</span>

        <span class="c1"># Calculate the variance term</span>
        <span class="n">variance_term</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">T</span><span class="p">))</span> <span class="o">*</span> <span class="n">timestep</span>

        <span class="c1"># Calculate the increments for the geometric process</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">drift_term</span> <span class="o">-</span> <span class="n">variance_term</span> <span class="o">+</span> <span class="n">dL</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span>

        <span class="k">return</span> <span class="n">dX</span></div>


<div class="viewcode-block" id="MultivariateGeometricLevy.simulate_ensemble">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.MultivariateGeometricLevy.simulate_ensemble">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_ensemble</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a single path for a portfolio consisting of multiple instances.</span>

<span class="sd">        :param t: Total simulation time</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param n: Number of simulations for each time step</span>
<span class="sd">        :type n: int</span>
<span class="sd">        :param timestep: Time step for simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the results</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :return: Dictionary containing portfolio values, geometric means, and weights over time</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">num_instances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span>

        <span class="c1"># Initialize arrays</span>
        <span class="n">portfolio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_instances</span><span class="p">,</span> <span class="n">num_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">geometric_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_instances</span><span class="p">,</span> <span class="n">num_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">num_instances</span>

        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Calculate weights</span>
            <span class="n">weights</span><span class="p">[:,</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">portfolio</span><span class="p">[:,</span> <span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">portfolio</span><span class="p">[:,</span> <span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Generate increments</span>
            <span class="n">increments_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">dX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_increment</span><span class="p">(</span><span class="n">portfolio</span><span class="p">[:,</span> <span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">timestep</span><span class="p">)</span>
                <span class="n">increments_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dX</span><span class="p">)</span>

            <span class="n">increments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">increments_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Update portfolio values</span>
            <span class="n">portfolio</span><span class="p">[:,</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">portfolio</span><span class="p">[:,</span> <span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">increments</span>

            <span class="c1"># Calculate the new geometric mean</span>
            <span class="n">geometric_means</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">portfolio</span><span class="p">[:,</span> <span class="n">step</span><span class="p">]</span> <span class="o">**</span> <span class="n">weights</span><span class="p">[:,</span> <span class="n">step</span><span class="p">])</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;portfolio&#39;</span><span class="p">:</span> <span class="n">portfolio</span><span class="p">,</span>
            <span class="s1">&#39;geometric_means&#39;</span><span class="p">:</span> <span class="n">geometric_means</span><span class="p">,</span>
            <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">weights</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;portfolio_simulation_levy.npy&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

        <span class="n">plot_simulate_ensemble</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">save</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>
</div>


<span class="kn">from</span> <span class="nn">.basic</span> <span class="kn">import</span> <span class="n">GeneralizedHyperbolicProcess</span>
<div class="viewcode-block" id="GeometricGeneralizedHyperbolicProcess">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricGeneralizedHyperbolicProcess">[docs]</a>
<span class="k">class</span> <span class="nc">GeometricGeneralizedHyperbolicProcess</span><span class="p">(</span><span class="n">GeneralizedHyperbolicProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GeometricGeneralizedHyperbolicProcess represents a multiplicative version of the Generalized Hyperbolic Process.</span>
<span class="sd">    This continuous-time stochastic process combines the flexibility of the Generalized Hyperbolic distribution</span>
<span class="sd">    with multiplicative dynamics, making it suitable for modeling phenomena where changes are proportional to</span>
<span class="sd">    the current state and exhibit complex distributional characteristics.</span>

<span class="sd">    The process is defined as:</span>
<span class="sd">    dS(t) = S(t) * dX(t)</span>

<span class="sd">    where X(t) is a Generalized Hyperbolic Process.</span>

<span class="sd">    Key properties include:</span>
<span class="sd">    1. Multiplicative nature: Changes are proportional to the current value, preserving non-negativity.</span>
<span class="sd">    2. Flexible distribution: Can model a wide range of tail behaviors and asymmetries.</span>
<span class="sd">    3. Nests several important distributions: Including normal, Student&#39;s t, variance-gamma, and normal-inverse Gaussian.</span>

<span class="sd">    This implementation extends the GeneralizedHyperbolicProcess class, adapting it to a multiplicative framework.</span>
<span class="sd">    It&#39;s explicitly set as multiplicative (_multiplicative = True) and uses an internal simulator for precise</span>
<span class="sd">    control over the process generation.</span>

<span class="sd">    Researchers and practitioners should be aware of the increased complexity in parameter estimation and</span>
<span class="sd">    interpretation compared to simpler processes. The rich behavior of this process requires careful consideration</span>
<span class="sd">    in both theoretical development and practical applications.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Multiplicative Generalized Hyperbolic Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">plambda</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.7</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0005</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
                 <span class="n">t_scaling</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Geometric Generalized Hyperbolic Process.</span>

<span class="sd">        :param name: Name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: Class of the process</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param plambda: The shape parameter (λ)</span>
<span class="sd">        :type plambda: float</span>
<span class="sd">        :param alpha: The shape parameter (α)</span>
<span class="sd">        :type alpha: float</span>
<span class="sd">        :param beta: The skewness parameter (β)</span>
<span class="sd">        :type beta: float</span>
<span class="sd">        :param loc: The location parameter (μ)</span>
<span class="sd">        :type loc: float</span>
<span class="sd">        :param delta: The scale parameter (δ)</span>
<span class="sd">        :type delta: float</span>
<span class="sd">        :param t_scaling: The scaling function for time increments</span>
<span class="sd">        :type t_scaling: Callable[[float], float]</span>
<span class="sd">        :param kwargs: Additional keyword arguments for the process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">plambda</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">t_scaling</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;multiplicative&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplicative</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_simulator</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="GeometricGeneralizedHyperbolicProcess.custom_increment">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricGeneralizedHyperbolicProcess.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the custom increment for the process.</span>

<span class="sd">        :param X: Current value of the process</span>
<span class="sd">        :type X: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: Increment for the process</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate increment from the base Generalized Hyperbolic Process</span>
        <span class="n">dX_base</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">custom_increment</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>

        <span class="c1"># Convert to multiplicative increment</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">dX_base</span>

        <span class="k">return</span> <span class="n">dX</span></div>
</div>


<span class="kn">from</span> <span class="nn">ergodicity.process.basic</span> <span class="kn">import</span> <span class="n">StandardBesselProcess</span>
<div class="viewcode-block" id="GeometricBesselProcess">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricBesselProcess">[docs]</a>
<span class="k">class</span> <span class="nc">GeometricBesselProcess</span><span class="p">(</span><span class="n">StandardBesselProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GeometricBesselProcess represents a multiplicative extension of the StandardBesselProcess.</span>
<span class="sd">    This process combines the characteristics of a Bessel process with the multiplicative nature of geometric processes.</span>
<span class="sd">    The resulting stochastic process, denoted as (S_t)_{t≥0}, is defined as:</span>

<span class="sd">    dS_t = S_t * dR_t</span>

<span class="sd">    where R_t is the StandardBesselProcess of dimension d.</span>

<span class="sd">    Key features of GeometricBesselProcess include:</span>
<span class="sd">    1. Multiplicative nature: Changes are proportional to the current value, preserving non-negativity.</span>
<span class="sd">    2. Dimension-dependent behavior: The underlying Bessel process characteristics (recurrence, transience) are preserved.</span>
<span class="sd">    3. Non-negative: The process is always positive, making it suitable for modeling quantities that cannot be negative.</span>

<span class="sd">    This implementation extends the StandardBesselProcess class, adapting it to a geometric framework.</span>
<span class="sd">    It inherits the dimension-dependent properties of the Bessel process while providing a multiplicative growth model.</span>

<span class="sd">    Applications of GeometricBesselProcess span various fields:</span>
<span class="sd">    - Finance: Modeling asset prices or interest rates with specific volatility structures.</span>
<span class="sd">    - Physics: Studying particle diffusion processes with multiplicative growth.</span>
<span class="sd">    - Biology: Analyzing population dynamics with radial growth patterns.</span>

<span class="sd">    Researchers and practitioners should be aware of the increased complexity in interpretation compared to the standard Bessel process.</span>
<span class="sd">    The multiplicative nature introduces new dynamics that require careful consideration in both theoretical development and practical applications.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Geometric Bessel Process&quot;</span><span class="p">,</span>
                 <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">dim_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the GeometricBesselProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param dim: The dimension of the underlying Bessel process</span>
<span class="sd">        :type dim: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;geometric&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplicative</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_simulator</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="GeometricBesselProcess.custom_increment">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricBesselProcess.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the custom increment for the process.</span>

<span class="sd">        :param X: Current value of the process</span>
<span class="sd">        :type X: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: Increment for the process</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate increment from the base Bessel Process</span>
        <span class="n">BP</span> <span class="o">=</span> <span class="n">StandardBesselProcess</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim</span><span class="p">)</span>
        <span class="n">dR</span> <span class="o">=</span> <span class="n">BP</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">timestep</span><span class="p">)</span>

        <span class="c1"># Convert to multiplicative increment</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">dR</span>

        <span class="k">return</span> <span class="n">dX</span></div>
</div>


<span class="kn">from</span> <span class="nn">.basic</span> <span class="kn">import</span> <span class="n">SquaredBesselProcess</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Any</span>

<div class="viewcode-block" id="GeometricSquaredBesselProcess">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricSquaredBesselProcess">[docs]</a>
<span class="k">class</span> <span class="nc">GeometricSquaredBesselProcess</span><span class="p">(</span><span class="n">SquaredBesselProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GeometricSquaredBesselProcess represents a multiplicative extension of the SquaredBesselProcess.</span>
<span class="sd">    This process combines the characteristics of a squared Bessel process with the multiplicative nature of geometric processes.</span>
<span class="sd">    The resulting stochastic process, denoted as (S_t)_{t≥0}, is defined as:</span>

<span class="sd">    dS_t = S_t * dR²_t</span>

<span class="sd">    where R²_t is the SquaredBesselProcess of dimension d.</span>

<span class="sd">    Key features of GeometricSquaredBesselProcess include:</span>
<span class="sd">    1. Multiplicative nature: Changes are proportional to the current value, preserving non-negativity.</span>
<span class="sd">    2. Dimension-dependent behavior: The underlying squared Bessel process characteristics are preserved.</span>
<span class="sd">    3. Non-negative: The process is always positive, making it suitable for modeling quantities that cannot be negative.</span>
<span class="sd">    4. Inherits properties of squared Bessel process: Including recurrence/transience behavior based on dimension.</span>

<span class="sd">    This implementation extends the SquaredBesselProcess class, adapting it to a geometric framework.</span>
<span class="sd">    It inherits the dimension-dependent properties of the squared Bessel process while providing a multiplicative growth model.</span>

<span class="sd">    Applications of GeometricSquaredBesselProcess span various fields:</span>
<span class="sd">    - Finance: Modeling volatility of asset prices or interest rates with specific structures.</span>
<span class="sd">    - Physics: Studying particle diffusion processes with multiplicative squared radial growth.</span>
<span class="sd">    - Biology: Analyzing population dynamics with quadratic radial growth patterns.</span>
<span class="sd">    - Queueing theory: Modeling busy periods with multiplicative squared characteristics.</span>

<span class="sd">    Researchers and practitioners should be aware of the increased complexity in interpretation compared to the standard squared Bessel process.</span>
<span class="sd">    The multiplicative nature introduces new dynamics that require careful consideration in both theoretical development and practical applications.</span>
<span class="sd">    The dimension parameter d plays a crucial role in determining the behavior of the process, affecting its recurrence properties and long-term behavior.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Geometric Squared Bessel Process&quot;</span><span class="p">,</span>
                 <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">dim_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the GeometricSquaredBesselProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param dim: The dimension of the underlying squared Bessel process</span>
<span class="sd">        :type dim: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;geometric&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplicative</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_simulator</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="GeometricSquaredBesselProcess.custom_increment">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.GeometricSquaredBesselProcess.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the custom increment for the process.</span>

<span class="sd">        :param X: Current value of the process</span>
<span class="sd">        :type X: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: Increment for the process</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate increment from the base Squared Bessel Process</span>
        <span class="n">SBP</span> <span class="o">=</span> <span class="n">SquaredBesselProcess</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim</span><span class="p">)</span>
        <span class="n">dR2</span> <span class="o">=</span> <span class="n">SBP</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">timestep</span><span class="p">)</span>

        <span class="c1"># Convert to multiplicative increment</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">dR2</span>

        <span class="k">return</span> <span class="n">dX</span></div>
</div>


<div class="viewcode-block" id="implied_levy_correction">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.implied_levy_correction">[docs]</a>
<span class="k">def</span> <span class="nf">implied_levy_correction</span><span class="p">(</span><span class="n">alpha_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                            <span class="n">beta_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                            <span class="n">time_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                            <span class="n">alpha_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                            <span class="n">beta_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                            <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                            <span class="n">loc</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                            <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                            <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                            <span class="n">save_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">save_html</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate and plot the correction term as a function of alpha and beta for a given loc and scale.</span>

<span class="sd">    :param alpha_range: Tuple of (min_alpha, max_alpha)</span>
<span class="sd">    :type alpha_range: Tuple[float, float]</span>
<span class="sd">    :param beta_range: Tuple of (min_beta, max_beta)</span>
<span class="sd">    :type beta_range: Tuple[float, float]</span>
<span class="sd">    :param time_range: Tuple of (min_time, max_time) or a single time value</span>
<span class="sd">    :type time_range: Tuple[float, float] or float</span>
<span class="sd">    :param alpha_step: Step size for alpha</span>
<span class="sd">    :type alpha_step: float</span>
<span class="sd">    :param beta_step: Step size for beta</span>
<span class="sd">    :type beta_step: float</span>
<span class="sd">    :param time_step: Step size for time</span>
<span class="sd">    :type time_step: float</span>
<span class="sd">    :param loc: Fixed loc parameter</span>
<span class="sd">    :type loc: float</span>
<span class="sd">    :param scale: Fixed scale parameter</span>
<span class="sd">    :type scale: float</span>
<span class="sd">    :param timestep: Fixed timestep for simulation</span>
<span class="sd">    :type timestep: float</span>
<span class="sd">    :param num_instances: Number of instances to simulate for each parameter combination</span>
<span class="sd">    :type num_instances: int</span>
<span class="sd">    :param save_path: Path to save the results (if None, results won&#39;t be saved)</span>
<span class="sd">    :type save_path: str</span>
<span class="sd">    :param save_html: If True, save the graph as an interactive HTML file</span>
<span class="sd">    :type save_html: bool</span>
<span class="sd">    :return: 3D numpy array of correction terms</span>
<span class="sd">    :rtype: NumPy array</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">alphas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">*</span><span class="n">alpha_range</span><span class="p">,</span> <span class="n">alpha_step</span><span class="p">)</span>
    <span class="n">betas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">*</span><span class="n">beta_range</span><span class="p">,</span> <span class="n">beta_step</span><span class="p">)</span>

    <span class="c1"># if times is float just convert it to list</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_range</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="n">time_range</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">*</span><span class="n">time_range</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>

    <span class="n">corrections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">alphas</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">betas</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alphas</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">beta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">betas</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">time</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
                <span class="n">process</span> <span class="o">=</span> <span class="n">GeometricLevyProcess</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>
                <span class="n">correction</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">implied_correction</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">timestep</span><span class="o">=</span><span class="n">timestep</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">corrections</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">correction</span>

    <span class="c1"># Create the 3D plot using matplotlib</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">betas</span><span class="p">,</span> <span class="n">alphas</span><span class="p">)</span>
    <span class="n">surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">corrections</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Beta&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Alpha&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Correction Term&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Correction Term vs Alpha and Beta (loc=</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s1">, scale=</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

    <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">save_path</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">save_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.png&#39;</span><span class="p">,</span> <span class="s1">&#39;.npy&#39;</span><span class="p">),</span> <span class="n">corrections</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># Create and save interactive 3D plot using Plotly</span>
    <span class="k">if</span> <span class="n">save_html</span><span class="p">:</span>
        <span class="n">fig_plotly</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">go</span><span class="o">.</span><span class="n">Surface</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">corrections</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">betas</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">alphas</span><span class="p">)])</span>
        <span class="n">fig_plotly</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Correction Term vs Alpha and Beta (loc=</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s1">, scale=</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">,</span>
                                 <span class="n">scene</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">xaxis_title</span><span class="o">=</span><span class="s1">&#39;Beta&#39;</span><span class="p">,</span>
                                            <span class="n">yaxis_title</span><span class="o">=</span><span class="s1">&#39;Alpha&#39;</span><span class="p">,</span>
                                            <span class="n">zaxis_title</span><span class="o">=</span><span class="s1">&#39;Correction Term&#39;</span><span class="p">))</span>

        <span class="n">html_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;levy_correction_loc_</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s1">_scale_</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s1">.html&#39;</span>
        <span class="n">fig_plotly</span><span class="o">.</span><span class="n">write_html</span><span class="p">(</span><span class="n">html_filename</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;3D interactive graph saved as </span><span class="si">{</span><span class="n">html_filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">corrections</span></div>


<div class="viewcode-block" id="estimate_sigma">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.process.html#ergodicity.process.multiplicative.estimate_sigma">[docs]</a>
<span class="k">def</span> <span class="nf">estimate_sigma</span><span class="p">(</span>
        <span class="n">num_steps_alpha</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">num_steps_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">max_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">min_time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">max_alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">min_alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">loc</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span>
        <span class="n">time_scale</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span>
        <span class="n">alpha_scale</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span>
        <span class="n">save_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">save_html</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate sigma(alpha, t) for GeometricLevyProcess.</span>

<span class="sd">    :param num_steps_alpha: Number of steps for alpha</span>
<span class="sd">    :type num_steps_alpha: int</span>
<span class="sd">    :param num_steps_time: Number of steps for time</span>
<span class="sd">    :type num_steps_time: int</span>
<span class="sd">    :param max_time: Maximum time</span>
<span class="sd">    :type max_time: float</span>
<span class="sd">    :param min_time: Minimum time (default: 1.0)</span>
<span class="sd">    :type min_time: float</span>
<span class="sd">    :param max_alpha: Maximum alpha (default: 2.0)</span>
<span class="sd">    :type max_alpha: float</span>
<span class="sd">    :param min_alpha: Minimum alpha (default: 0.01)</span>
<span class="sd">    :type min_alpha: float</span>
<span class="sd">    :param timestep: Fixed timestep for simulation</span>
<span class="sd">    :type timestep: float</span>
<span class="sd">    :param beta: Fixed beta parameter</span>
<span class="sd">    :type beta: float</span>
<span class="sd">    :param loc: Fixed loc parameter</span>
<span class="sd">    :type loc: float</span>
<span class="sd">    :param scale: Fixed scale parameter</span>
<span class="sd">    :type scale: float</span>
<span class="sd">    :param time_scale: &#39;linear&#39; or &#39;log&#39; for time sampling</span>
<span class="sd">    :type time_scale: str</span>
<span class="sd">    :param alpha_scale: &#39;linear&#39; or &#39;log&#39; for alpha sampling</span>
<span class="sd">    :type alpha_scale: str</span>
<span class="sd">    :param save_path: Path to save the results (if None, results won&#39;t be saved)</span>
<span class="sd">    :type save_path: str</span>
<span class="sd">    :param save_html: If True, save the graph as an interactive HTML file</span>
<span class="sd">    :type save_html: bool</span>
<span class="sd">    :return: 3D numpy array of sigma values, linear regression results, non-linear regression results</span>
<span class="sd">    :rtype: Tuple[np.ndarray, Any, Any]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">min_alpha</span> <span class="o">&lt;</span> <span class="n">max_alpha</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Alpha range must be within (0, 2] and min_alpha must be less than max_alpha&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">alpha_scale</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">alphas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_alpha</span><span class="p">,</span> <span class="n">max_alpha</span><span class="p">,</span> <span class="n">num_steps_alpha</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">alpha_scale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
        <span class="n">alphas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">min_alpha</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">max_alpha</span><span class="p">),</span> <span class="n">num_steps_alpha</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha_scale must be either &#39;linear&#39; or &#39;log&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">time_scale</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_time</span><span class="p">,</span> <span class="n">max_time</span><span class="p">,</span> <span class="n">num_steps_time</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">time_scale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">min_time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">max_time</span><span class="p">),</span> <span class="n">num_steps_time</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;time_scale must be either &#39;linear&#39; or &#39;log&#39;&quot;</span><span class="p">)</span>

    <span class="n">sigma_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">alphas</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alphas</span><span class="p">):</span>
        <span class="n">process</span> <span class="o">=</span> <span class="n">GeometricLevyProcess</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
            <span class="n">process</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="o">=</span><span class="n">timestep</span><span class="p">,</span> <span class="n">num_instances</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">sigma_values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">implied_correction</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Create 3D plot using Plotly</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">go</span><span class="o">.</span><span class="n">Surface</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">sigma_values</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">alphas</span><span class="p">)])</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span>
        <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Sigma vs Alpha and Time (beta=</span><span class="si">{</span><span class="n">beta</span><span class="si">}</span><span class="s1">, loc=</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s1">, scale=</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">,</span>
        <span class="n">scene</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">xaxis_title</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span>
            <span class="n">yaxis_title</span><span class="o">=</span><span class="s1">&#39;Alpha&#39;</span><span class="p">,</span>
            <span class="n">zaxis_title</span><span class="o">=</span><span class="s1">&#39;Sigma&#39;</span><span class="p">,</span>
            <span class="n">xaxis_type</span><span class="o">=</span><span class="s1">&#39;log&#39;</span> <span class="k">if</span> <span class="n">time_scale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span> <span class="k">else</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span>
            <span class="n">yaxis_type</span><span class="o">=</span><span class="s1">&#39;log&#39;</span> <span class="k">if</span> <span class="n">alpha_scale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span> <span class="k">else</span> <span class="s1">&#39;linear&#39;</span>
        <span class="p">),</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">height</span><span class="o">=</span><span class="mi">800</span>
    <span class="p">)</span>
    <span class="c1"># Create and save interactive 3D plot using Plotly</span>
    <span class="k">if</span> <span class="n">save_html</span><span class="p">:</span>
        <span class="n">fig_plotly</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">go</span><span class="o">.</span><span class="n">Surface</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">sigma_values</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">alphas</span><span class="p">)])</span>
        <span class="n">fig_plotly</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span>
            <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Sigma vs Alpha and Time (beta=</span><span class="si">{</span><span class="n">beta</span><span class="si">}</span><span class="s1">, loc=</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s1">, scale=</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">,</span>
            <span class="n">scene</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">xaxis_title</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span>
                <span class="n">yaxis_title</span><span class="o">=</span><span class="s1">&#39;Alpha&#39;</span><span class="p">,</span>
                <span class="n">zaxis_title</span><span class="o">=</span><span class="s1">&#39;Sigma&#39;</span><span class="p">,</span>
                <span class="n">xaxis_type</span><span class="o">=</span><span class="s1">&#39;log&#39;</span> <span class="k">if</span> <span class="n">time_scale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span> <span class="k">else</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                <span class="n">yaxis_type</span><span class="o">=</span><span class="s1">&#39;log&#39;</span> <span class="k">if</span> <span class="n">alpha_scale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span> <span class="k">else</span> <span class="s1">&#39;linear&#39;</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">html_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;sigma_estimation_beta_</span><span class="si">{</span><span class="n">beta</span><span class="si">}</span><span class="s1">_loc_</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s1">_scale_</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s1">.html&#39;</span>
        <span class="n">fig_plotly</span><span class="o">.</span><span class="n">write_html</span><span class="p">(</span><span class="n">html_filename</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;3D interactive graph saved as </span><span class="si">{</span><span class="n">html_filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="c1"># Perform regression analysis</span>

    <span class="c1"># Prepare data for regression</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">alphas</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">alphas</span><span class="p">))))</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">sigma_values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># Linear regression</span>
    <span class="n">linear_model</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
    <span class="n">linear_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">y_pred_linear</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">r2_linear</span> <span class="o">=</span> <span class="n">r2_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_pred_linear</span><span class="p">)</span>

    <span class="c1"># Non-linear regression</span>
    <span class="k">def</span> <span class="nf">non_linear_model</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span> <span class="o">**</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">non_linear_params</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">non_linear_model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">maxfev</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
        <span class="n">y_pred_non_linear</span> <span class="o">=</span> <span class="n">non_linear_model</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">non_linear_params</span><span class="p">)</span>
        <span class="n">r2_non_linear</span> <span class="o">=</span> <span class="n">r2_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_pred_non_linear</span><span class="p">)</span>
        <span class="n">non_linear_success</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non-linear regression failed to converge: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">non_linear_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">y_pred_non_linear</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">r2_non_linear</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">non_linear_success</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Plot regression results</span>
    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

    <span class="c1"># Linear regression plot</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_pred_linear</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()],</span> <span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()],</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Actual Sigma&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Predicted Sigma (Linear)&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Linear Regression (R² = </span><span class="si">{</span><span class="n">r2_linear</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

    <span class="c1"># Non-linear regression plot</span>
    <span class="k">if</span> <span class="n">non_linear_success</span><span class="p">:</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_pred_non_linear</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()],</span> <span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()],</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Actual Sigma&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Predicted Sigma (Non-linear)&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Non-linear Regression (R² = </span><span class="si">{</span><span class="n">r2_non_linear</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;Non-linear regression failed to converge&#39;</span><span class="p">,</span>
                 <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ax2</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">sigma_values</span><span class="p">,</span> <span class="n">linear_model</span><span class="p">,</span> <span class="n">non_linear_params</span><span class="p">,</span> <span class="n">r2_linear</span><span class="p">,</span> <span class="n">r2_non_linear</span></div>


</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Ergodicity Library</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Ihor Kendiukhov.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>