<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ergodicity.tools.partial_sde &#8212; Ergodicity Library 0.3.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../_static/documentation_options.js?v=e259d695"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ergodicity.tools.partial_sde</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">partial_sde Submodule</span>

<span class="sd">The `Partial SDE` submodule provides functionality for simulating, visualizing, and analyzing stochastic partial differential equations (SPDEs). The core of this module is the `PSDESimulator` class, which implements numerical solutions to SPDEs, allowing users to model systems with both deterministic drift and stochastic diffusion terms over time and space.</span>

<span class="sd">Key Features:</span>

<span class="sd">1. **Stochastic PDE Simulation**:</span>

<span class="sd">   - The simulator models the evolution of a spatially distributed quantity `u(t, x)` over time with specified drift and diffusion terms. These terms represent the deterministic and stochastic components of the equation, respectively.</span>

<span class="sd">   - The simulator supports different boundary conditions including Dirichlet, Neumann, and periodic.</span>

<span class="sd">2. **Numerical Solution**:</span>

<span class="sd">   - The SPDE is solved using a finite difference approach in both time and space, with the option to include stochastic noise (via a Wiener process) at each time step.</span>

<span class="sd">3. **Visualization**:</span>

<span class="sd">   - **2D Plots**: The `plot_results` method provides a 2D surface plot of the solution over time and space, along with a time slice at the final time step.</span>

<span class="sd">   - **3D Plots**: The `plot_3d` method generates a 3D surface plot to visualize the evolution of the solution.</span>

<span class="sd">   - **Animations**: The `create_animation` method generates an animation of the solution&#39;s evolution, saved as a video file.</span>

<span class="sd">4. **Customizability**:</span>

<span class="sd">   - Users can define their own drift and diffusion terms, initial conditions, and boundary conditions to simulate a wide variety of SPDEs.</span>

<span class="sd">   - The spatial and temporal resolution can be adjusted through the `nx` (number of spatial points) and `nt` (number of time points) parameters.</span>

<span class="sd">Example Usage:</span>

<span class="sd">if __name__ == &quot;__main__&quot;:</span>

<span class="sd">    # Define the drift (deterministic) term of the SPDE (e.g., heat equation)</span>

<span class="sd">    def drift(t, x, u, u_x, u_xx):</span>

<span class="sd">        return 0.01 * u_xx  # Heat equation term</span>

<span class="sd">    # Define the diffusion (stochastic) term of the SPDE</span>

<span class="sd">    def diffusion(t, x, u):</span>

<span class="sd">        return 0.1 * np.ones_like(x)  # Constant noise term</span>

<span class="sd">    # Define the initial condition</span>

<span class="sd">    def initial_condition(x):</span>

<span class="sd">        return np.sin(np.pi * x)  # Initial sine wave</span>

<span class="sd">    # Initialize the simulator</span>

<span class="sd">    simulator = PSDESimulator(</span>
<span class="sd">        drift=drift,</span>
<span class="sd">        diffusion=diffusion,</span>
<span class="sd">        initial_condition=initial_condition,</span>
<span class="sd">        x_range=(0, 1),</span>
<span class="sd">        t_range=(0, 1),</span>
<span class="sd">        nx=100,</span>
<span class="sd">        nt=1000</span>
<span class="sd">    )</span>

<span class="sd">    # Run the simulation</span>

<span class="sd">    simulator.simulate()</span>

<span class="sd">    # Visualize the results</span>

<span class="sd">    simulator.plot_results()</span>

<span class="sd">    simulator.plot_3d()</span>

<span class="sd">    simulator.create_animation(&quot;spde_evolution.mp4&quot;)</span>

<span class="sd">    print(&quot;Simulation and visualization complete.&quot;)</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">animation</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">ergodicity.process.basic</span> <span class="kn">import</span> <span class="n">WienerProcess</span>

<div class="viewcode-block" id="wiener_increment_function">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.partial_sde.wiener_increment_function">[docs]</a>
<span class="k">def</span> <span class="nf">wiener_increment_function</span><span class="p">(</span><span class="n">timestep_increment</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate Wiener process increments.</span>
<span class="sd">    This is a default increment function for the PSDE simulator.</span>
<span class="sd">    It can be changed to use different increments, such as for example Levy increments.</span>

<span class="sd">    :param timestep_increment: The time step of the discrete increment</span>
<span class="sd">    :type timestep_increment: float</span>
<span class="sd">    :return: The Wiener process increment</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">WP</span> <span class="o">=</span> <span class="n">WienerProcess</span><span class="p">()</span>
    <span class="n">dW</span> <span class="o">=</span> <span class="n">WP</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">timestep_increment</span><span class="o">=</span><span class="n">timestep_increment</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dW</span></div>


<div class="viewcode-block" id="PSDESimulator">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.partial_sde.PSDESimulator">[docs]</a>
<span class="k">class</span> <span class="nc">PSDESimulator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Partial Stochastic Differential Equation (PSDE) Simulator.</span>
<span class="sd">    This class provides functionality to simulate and visualize the stochastic evolution of a spatially distributed quantity</span>

<span class="sd">    Attributes:</span>

<span class="sd">        drift (Callable): The drift function f(t, x, u, u_x, u_xx)</span>

<span class="sd">        diffusion (Callable): The diffusion function g(t, x, u)</span>

<span class="sd">        initial_condition (Callable): The initial condition u(0, x)</span>

<span class="sd">        x_range (tuple): The spatial range (x_min, x_max)</span>

<span class="sd">        t_range (tuple): The time range (t_min, t_max)</span>

<span class="sd">        nx (int): Number of spatial points</span>

<span class="sd">        nt (int): Number of time points</span>

<span class="sd">        boundary_type (str): Type of boundary condition (e.g., &quot;dirichlet&quot;, &quot;neumann&quot;, &quot;periodic&quot;)</span>

<span class="sd">        boundary_func (Callable): The boundary condition function</span>

<span class="sd">        x (ndarray): Spatial grid points</span>

<span class="sd">        t (ndarray): Time grid points</span>

<span class="sd">        dx (float): Spatial step size</span>

<span class="sd">        dt (float): Time step size</span>

<span class="sd">        u (ndarray): Array to store the solution u(t, x)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">drift</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                 <span class="n">diffusion</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                 <span class="n">initial_condition</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                 <span class="n">x_range</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
                 <span class="n">t_range</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
                 <span class="n">nx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">nt</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">boundary_condition</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dirichlet&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">),</span> <span class="n">increment</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">wiener_increment_function</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the PSDE simulator.</span>

<span class="sd">        :param drift: The drift function f(t, x, u, u_x, u_xx)</span>
<span class="sd">        :type drift: Callable</span>
<span class="sd">        :param diffusion: The diffusion function g(t, x, u)</span>
<span class="sd">        :type diffusion: Callable</span>
<span class="sd">        :param initial_condition: The initial condition u(0, x)</span>
<span class="sd">        :type initial_condition: Callable</span>
<span class="sd">        :param x_range: The spatial range (x_min, x_max)</span>
<span class="sd">        :type x_range: tuple</span>
<span class="sd">        :param t_range: The time range (t_min, t_max)</span>
<span class="sd">        :type t_range: tuple</span>
<span class="sd">        :param nx: Number of spatial points</span>
<span class="sd">        :type nx: int</span>
<span class="sd">        :param nt: Number of time points</span>
<span class="sd">        :type nt: int</span>
<span class="sd">        :param boundary_condition: Type of boundary condition and function. It can be &quot;dirichlet&quot;, &quot;neumann&quot;, or &quot;periodic&quot;</span>
<span class="sd">        :type boundary_condition: Tuple[str, Callable]</span>
<span class="sd">        :param increment: The increment function for the stochastic term (default: Wiener process)</span>
<span class="sd">        :type increment: Callable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drift</span> <span class="o">=</span> <span class="n">drift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diffusion</span> <span class="o">=</span> <span class="n">diffusion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_condition</span> <span class="o">=</span> <span class="n">initial_condition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_range</span> <span class="o">=</span> <span class="n">x_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_range</span> <span class="o">=</span> <span class="n">t_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">=</span> <span class="n">nx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nt</span> <span class="o">=</span> <span class="n">nt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_func</span> <span class="o">=</span> <span class="n">boundary_condition</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nt</span><span class="p">,</span> <span class="n">nx</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">initial_condition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Apply initial boundary conditions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_boundary_condition</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">increment</span> <span class="o">=</span> <span class="n">increment</span>

<div class="viewcode-block" id="PSDESimulator.apply_boundary_condition">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.partial_sde.PSDESimulator.apply_boundary_condition">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_boundary_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply boundary conditions at time step n.</span>

<span class="sd">        :param n: The time step index</span>
<span class="sd">        :type n: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_type</span> <span class="o">==</span> <span class="s2">&quot;dirichlet&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_type</span> <span class="o">==</span> <span class="s2">&quot;neumann&quot;</span><span class="p">:</span>
            <span class="c1"># Forward difference for left boundary, backward for right</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_type</span> <span class="o">==</span> <span class="s2">&quot;periodic&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported boundary condition type&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PSDESimulator.simulate">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.partial_sde.PSDESimulator.simulate">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the simulation.</span>

<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="p">):</span>
            <span class="c1"># dW = np.sqrt(self.dt) * np.random.normal(0, 1, self.nx)</span>
            <span class="n">dW</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">timestep_increment</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">)]</span>

            <span class="n">u_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
            <span class="n">u_xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">u_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>

            <span class="n">drift_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">u_x</span><span class="p">,</span> <span class="n">u_xx</span><span class="p">)</span>
            <span class="n">diffusion_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diffusion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                         <span class="n">drift_term</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">+</span>
                         <span class="n">diffusion_term</span> <span class="o">*</span> <span class="n">dW</span><span class="p">)</span>

            <span class="c1"># Apply boundary conditions after each time step</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_boundary_condition</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="PSDESimulator.plot_results">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.partial_sde.PSDESimulator.plot_results">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the results of the simulation. This includes a 2D surface plot of the function evolution and a time slice at the final time step.</span>

<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

        <span class="c1"># Surface plot</span>
        <span class="n">T</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">surf</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Surface Plot of u(t,x)&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>

        <span class="c1"># Final time slice</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;u(t,x) at t = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="PSDESimulator.plot_3d">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.partial_sde.PSDESimulator.plot_3d">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a 3D plot of the function evolution.</span>
<span class="sd">        This plot shows the surface of u(t,x) over time and space.</span>

<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>

        <span class="n">T</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;3D Evolution of u(t,x)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">surf</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="PSDESimulator.create_animation">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.partial_sde.PSDESimulator.create_animation">[docs]</a>
    <span class="k">def</span> <span class="nf">create_animation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;psde_evolution.mp4&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an animation of the function evolution.</span>
<span class="sd">        The animation shows the spatial distribution of u at each time step.</span>

<span class="sd">        :param filename: The name of the output file (default: &#39;psde_evolution.mp4&#39;)</span>
<span class="sd">        :type filename: str</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_range</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],</span> <span class="p">[])</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="k">def</span> <span class="nf">animate</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;t = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="n">anim</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">animate</span><span class="p">,</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span>
                                       <span class="n">frames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">anim</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="s1">&#39;ffmpeg&#39;</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span></div>
</div>


<span class="c1"># Example usage: Heat equation with stochastic forcing</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Define the PSDE components</span>
    <span class="k">def</span> <span class="nf">drift</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_x</span><span class="p">,</span> <span class="n">u_xx</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">u_xx</span>  <span class="c1"># Heat equation term</span>


    <span class="k">def</span> <span class="nf">diffusion</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Constant noise</span>


    <span class="k">def</span> <span class="nf">initial_condition</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>  <span class="c1"># Initial sine wave</span>


    <span class="c1"># Set up the simulation</span>
    <span class="n">simulator</span> <span class="o">=</span> <span class="n">PSDESimulator</span><span class="p">(</span>
        <span class="n">drift</span><span class="o">=</span><span class="n">drift</span><span class="p">,</span>
        <span class="n">diffusion</span><span class="o">=</span><span class="n">diffusion</span><span class="p">,</span>
        <span class="n">initial_condition</span><span class="o">=</span><span class="n">initial_condition</span><span class="p">,</span>
        <span class="n">x_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">t_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">nx</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">nt</span><span class="o">=</span><span class="mi">1000</span>
    <span class="p">)</span>

    <span class="c1"># Run the simulation</span>
    <span class="n">simulator</span><span class="o">.</span><span class="n">simulate</span><span class="p">()</span>

    <span class="c1"># Plot the results</span>
    <span class="n">simulator</span><span class="o">.</span><span class="n">plot_results</span><span class="p">()</span>

    <span class="c1"># Create 3D plot</span>
    <span class="n">simulator</span><span class="o">.</span><span class="n">plot_3d</span><span class="p">()</span>

    <span class="c1"># Create animation</span>
    <span class="n">simulator</span><span class="o">.</span><span class="n">create_animation</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Simulation and visualization complete.&quot;</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Ergodicity Library</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Ihor Kendiukhov.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>