<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ergodicity.process.basic &#8212; Ergodicity Library 0.3.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../_static/documentation_options.js?v=e259d695"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ergodicity.process.basic</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">basic.py</span>

<span class="sd">This module provides foundational stochastic processes used in simulations, particularly focusing on</span>
<span class="sd">Itô and non-Itô processes. These processes are employed to model various types of continuous-time</span>
<span class="sd">stochastic behaviors, including Brownian motion, Bessel processes, and more complex, specialized</span>
<span class="sd">stochastic processes like the Brownian bridge, Brownian meander, and fractional Brownian motion.</span>

<span class="sd">Classes:</span>

<span class="sd">    - EmptyProcess: A process that remains constant at 0 or 1, used for placeholder or null-action purposes.</span>

<span class="sd">    - StandardBesselProcess: Represents a standard Bessel process, modeling the Euclidean distance of a Brownian motion from the origin.</span>

<span class="sd">    - StandardBrownianBridge: Models a Brownian motion constrained to start and end at specified points over a fixed time interval.</span>

<span class="sd">    - StandardBrownianExcursion: Models a Brownian motion conditioned to stay positive and to start and end at zero over a fixed time interval.</span>

<span class="sd">    - StandardBrownianMeander: Models a Brownian motion conditioned to stay positive with an unconstrained endpoint.</span>

<span class="sd">    - BrownianMotion: Represents standard Brownian motion (Wiener process), a fundamental stochastic process in various fields.</span>

<span class="sd">    - CauchyProcess: Models random motion with heavy-tailed distributions following a Cauchy distribution.</span>

<span class="sd">    - StandardFractionalBrownianMotion: Models fractional Brownian motion with long-range dependence and self-similarity, governed by the Hurst parameter.</span>

<span class="sd">    - FractionalBrownianMotion: Extends the fractional Brownian motion to include a deterministic trend (mean).</span>

<span class="sd">    - GammaProcess: Models a process with independent, stationary increments following a gamma distribution.</span>

<span class="sd">    - InverseGaussianProcess: Models independent, stationary increments following an inverse Gaussian distribution.</span>

<span class="sd">    - StandardMultifractionalBrownianMotion: Represents a multifractional Brownian motion with a time-varying Hurst parameter.</span>

<span class="sd">    - SquaredBesselProcess: Models the square of the Euclidean norm of a d-dimensional Brownian motion.</span>

<span class="sd">    - VarianceGammaProcess: Represents a variance-gamma process with a mix of Gaussian and gamma process characteristics.</span>

<span class="sd">    - WienerProcess: A standard implementation of Brownian motion, a cornerstone of stochastic models.</span>

<span class="sd">    - PoissonProcess: Models the occurrence of random events at a constant average rate, a pure jump process.</span>

<span class="sd">    - LevyStableProcess: Generalizes the Gaussian distribution to allow for heavy tails and skewness.</span>

<span class="sd">    - LevyStableStandardProcess: A standardized version of the Lévy stable process.</span>

<span class="sd">    - MultivariateBrownianMotion: Models correlated Brownian motion in multiple dimensions.</span>

<span class="sd">    - MultivariateLevy: Extends the Lévy stable process to multiple dimensions, allowing for complex, correlated phenomena.</span>

<span class="sd">    - GeneralizedHyperbolicProcess: A versatile process encompassing a wide range of distributions like variance-gamma and normal-inverse Gaussian.</span>

<span class="sd">    - ParetoProcess: Represents a process based on the Pareto distribution, modeling heavy-tailed phenomena.</span>

<span class="sd">Dependencies:</span>

<span class="sd">    - math, numpy, matplotlib, plotly: Libraries used for mathematical operations and visualization.</span>

<span class="sd">    - scipy.stats: Statistical functions used to model different distributions.</span>

<span class="sd">    - stochastic: Provides the base stochastic processes extended by this module.</span>

<span class="sd">    - aiohttp.client_exceptions: Used for exception handling in certain client processes.</span>

<span class="sd">This module is essential for defining different stochastic processes used throughout the library, including basic and advanced processes for financial modeling, physics, biology, and more.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">aiohttp.client_exceptions</span> <span class="kn">import</span> <span class="n">ssl_error_bases</span>

<span class="kn">from</span> <span class="nn">.definitions</span> <span class="kn">import</span> <span class="n">ItoProcess</span>
<span class="kn">from</span> <span class="nn">.definitions</span> <span class="kn">import</span> <span class="n">NonItoProcess</span>
<span class="kn">from</span> <span class="nn">.definitions</span> <span class="kn">import</span> <span class="n">Process</span>
<span class="kn">from</span> <span class="nn">.default_values</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.definitions</span> <span class="kn">import</span> <span class="n">simulation_decorator</span>
<span class="kn">from</span> <span class="nn">ergodicity.configurations</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">plotly.graph_objects</span> <span class="k">as</span> <span class="nn">go</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<div class="viewcode-block" id="EmptyProcess">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.EmptyProcess">[docs]</a>
<span class="k">class</span> <span class="nc">EmptyProcess</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A process that is always zero or one.</span>
<span class="sd">    It may be used as a placeholder, for testing purposes, or often in the agents module as a null-action.</span>

<span class="sd">    :param name: The name of the process</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param zero_or_one: The value of the process (0 or 1)</span>
<span class="sd">    :type zero_or_one: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Empty Process&quot;</span><span class="p">,</span> <span class="n">zero_or_one</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the EmptyProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param zero_or_one: The value of the process (0 or 1)</span>
<span class="sd">        :type zero_or_one: float</span>
<span class="sd">        :raises ValueError: If zero_or_one is not 0 or 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;empty&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">zero_or_one</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;zero_or_one must be 0 or 1.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zero_or_one</span> <span class="o">=</span> <span class="n">zero_or_one</span>

<div class="viewcode-block" id="EmptyProcess.custom_increment">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.EmptyProcess.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom increment function for the process.</span>

<span class="sd">        :param X: The current value of the process</span>
<span class="sd">        :type X: float</span>
<span class="sd">        :param timestep: The time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: The increment value, which is always 0 in this case</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="EmptyProcess.simulate">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.EmptyProcess.simulate">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span> <span class="n">num_instances</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">num_instances_default</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the process.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param num_instances: Number of instances to simulate</span>
<span class="sd">        :type num_instances: int</span>
<span class="sd">        :param save: Whether to save the simulation results</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to plot the simulation results</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return: The simulated data</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero_or_one</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_instances</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_instances</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span></div>
</div>


<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">BesselProcess</span> <span class="k">as</span> <span class="n">StochasticBesselProcess</span>
<div class="viewcode-block" id="StandardBesselProcess">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.StandardBesselProcess">[docs]</a>
<span class="k">class</span> <span class="nc">StandardBesselProcess</span><span class="p">(</span><span class="n">ItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A standard Bessel process.</span>
<span class="sd">    A StandardBesselProcess represents a continuous-time stochastic process that models the Euclidean distance of a</span>
<span class="sd">    Brownian motion from its starting point. As an Itô process, it follows the rules of stochastic calculus and is</span>
<span class="sd">    defined mathematically as R_t = ||B_t||, where (B_t)_{t≥0} is a d-dimensional Brownian motion and ||·|| denotes</span>
<span class="sd">    the Euclidean norm. This process is characterized by its dimension (d), which influences its behavior, including</span>
<span class="sd">    non-negativity, martingale properties (for d=2), and recurrence/transience (recurrent for d≤2, transient for d&gt;2).</span>
<span class="sd">    The Bessel process maintains continuous sample paths and finds applications in mathematical finance for interest</span>
<span class="sd">    rate modeling, statistical physics for particle diffusion studies, and probability theory as a fundamental</span>
<span class="sd">    process. It is initialized with a name, process class, and dimension, using default drift</span>
<span class="sd">    and stochastic terms inherited from the ItoProcess parent class. The StandardBesselProcess is categorized as both</span>
<span class="sd">    a &quot;bessel&quot; and &quot;standard&quot; process type, reflecting its nature and standardized implementation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Bessel Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticBesselProcess</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">dim_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the StandardBesselProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param dim: The dimension of the Bessel process</span>
<span class="sd">        :type dim: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">drift_term</span><span class="o">=</span><span class="n">drift_term_default</span><span class="p">,</span> <span class="n">stochastic_term</span><span class="o">=</span><span class="n">stochastic_term_default</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;bessel&quot;</span><span class="p">,</span> <span class="s2">&quot;standard&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="n">dim</span></div>


<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">BrownianBridge</span> <span class="k">as</span> <span class="n">StochasticBrownianBridge</span>
<div class="viewcode-block" id="StandardBrownianBridge">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.StandardBrownianBridge">[docs]</a>
<span class="k">class</span> <span class="nc">StandardBrownianBridge</span><span class="p">(</span><span class="n">ItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A StandardBrownianBridge represents a continuous-time stochastic process that models a Brownian motion constrained</span>
<span class="sd">    to start and end at specified points, typically 0 and b, over a fixed time interval [0, 1]. This process, denoted</span>
<span class="sd">    as (B_t)_{0≤t≤1}, is defined by B_t = W_t - tW_1, where (W_t) is a standard Brownian motion. The bridge process</span>
<span class="sd">    is characterized by its non-independent increments and its &quot;tied-down&quot; nature at the endpoints. It exhibits</span>
<span class="sd">    several key properties: it&#39;s a Gaussian process, has continuous sample paths, and maintains a covariance structure</span>
<span class="sd">    of min(s,t) - st. The StandardBrownianBridge finds applications in statistical inference, particularly in</span>
<span class="sd">    goodness-of-fit tests, as well as in finance for interest rate modeling and in biology for modeling evolutionary</span>
<span class="sd">    processes. As an Itô process, it adheres to the principles of stochastic calculus. It is</span>
<span class="sd">    initialized with a name, process class, and an endpoint value b, using default drift and stochastic terms</span>
<span class="sd">    inherited from the ItoProcess parent class. The StandardBrownianBridge is explicitly categorized as both a</span>
<span class="sd">    &quot;bridge&quot; and &quot;standard&quot; process type, reflecting its nature as a standard implementation of the Brownian bridge</span>
<span class="sd">    concept. The _independent attribute is set to False, highlighting the process&#39;s non-independent increment</span>
<span class="sd">    property, which distinguishes it from standard Brownian motion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Standard Brownian Bridge&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticBrownianBridge</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the StandardBrownianBridge class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param b: The endpoint value for the bridge process</span>
<span class="sd">        :type b: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;bridge&quot;</span><span class="p">,</span> <span class="s2">&quot;standard&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">drift_term</span><span class="o">=</span><span class="n">drift_term_default</span><span class="p">,</span> <span class="n">stochastic_term</span><span class="o">=</span><span class="n">stochastic_term_default</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_independent</span> <span class="o">=</span> <span class="kc">False</span></div>


<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">BrownianExcursion</span> <span class="k">as</span> <span class="n">StochasticBrownianExcursion</span>
<div class="viewcode-block" id="StandardBrownianExcursion">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.StandardBrownianExcursion">[docs]</a>
<span class="k">class</span> <span class="nc">StandardBrownianExcursion</span><span class="p">(</span><span class="n">ItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A StandardBrownianExcursion represents a continuous-time stochastic process that models a Brownian motion</span>
<span class="sd">    conditioned to be positive and to start and end at zero over a fixed time interval, typically [0, 1]. This</span>
<span class="sd">    process, denoted as (E_t)_{0≤t≤1}, can be conceptualized as the absolute value of a Brownian bridge scaled to</span>
<span class="sd">    have a maximum of 1. Mathematically, it&#39;s related to the Brownian bridge (B_t) by E_t = |B_t| / max(|B_t|).</span>
<span class="sd">    The excursion process is characterized by its non-negative paths, non-independent increments, and its constrained</span>
<span class="sd">    behavior at the endpoints. It exhibits several key properties: it&#39;s a non-Markovian process, has continuous</span>
<span class="sd">    sample paths, and its probability density at time t is related to the Airy function. The StandardBrownianExcursion</span>
<span class="sd">    finds applications in various fields, including queueing theory, where it models busy periods, in statistical</span>
<span class="sd">    physics for studying polymer chains, and in probability theory as a fundamental object related to Brownian motion.</span>
<span class="sd">    As an Itô process, it adheres to the principles of stochastic calculus, although its specific dynamics are more</span>
<span class="sd">    complex due to its constrained nature. It is initialized with a name and process</span>
<span class="sd">    class, using default drift and stochastic terms inherited from the ItoProcess parent class. The</span>
<span class="sd">    StandardBrownianExcursion is explicitly categorized as both an &quot;excursion&quot; and &quot;standard&quot; process type, reflecting</span>
<span class="sd">    its nature as a standard implementation of the Brownian excursion concept. The _independent attribute is set to</span>
<span class="sd">    False, emphasizing the process&#39;s non-independent increment property, which is a crucial characteristic</span>
<span class="sd">    distinguishing it from standard Brownian motion and highlighting its unique constrained behavior.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Standard Brownian Excursion&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticBrownianExcursion</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the StandardBrownianExcursion class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;excursion&quot;</span><span class="p">,</span> <span class="s2">&quot;standard&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">drift_term</span><span class="o">=</span><span class="n">drift_term_default</span><span class="p">,</span> <span class="n">stochastic_term</span><span class="o">=</span><span class="n">stochastic_term_default</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_independent</span> <span class="o">=</span> <span class="kc">False</span></div>


<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">BrownianMeander</span> <span class="k">as</span> <span class="n">StochasticBrownianMeander</span>
<div class="viewcode-block" id="StandardBrownianMeander">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.StandardBrownianMeander">[docs]</a>
<span class="k">class</span> <span class="nc">StandardBrownianMeander</span><span class="p">(</span><span class="n">ItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A StandardBrownianMeander represents a continuous-time stochastic process that models a Brownian motion</span>
<span class="sd">    conditioned to stay positive over a fixed time interval, typically [0, 1], with an unconstrained endpoint.</span>
<span class="sd">    This process, denoted as (M_t)_{0≤t≤1}, can be constructed from a standard Brownian motion (B_t) by</span>
<span class="sd">    M_t = |B_t| / √(1-t) for 0 ≤ t &lt; 1, with a specific limiting distribution at t = 1. The meander process</span>
<span class="sd">    is characterized by its non-negative paths, non-independent increments, and its free endpoint behavior.</span>
<span class="sd">    It exhibits several key properties: it&#39;s a non-Markovian process, has continuous sample paths, and its</span>
<span class="sd">    transition probability density is related to the heat kernel on the half-line with absorbing boundary</span>
<span class="sd">    conditions. The StandardBrownianMeander finds applications in various fields, including queuing theory</span>
<span class="sd">    for modeling busy periods with unfinished work, in financial mathematics for studying asset prices</span>
<span class="sd">    conditioned on positivity, and in probability theory as a fundamental object related to Brownian motion</span>
<span class="sd">    and its local time. As an Itô process, it adheres to the principles of stochastic calculus, although its</span>
<span class="sd">    specific dynamics are more complex due to its constrained nature. It is initialized with a name and process</span>
<span class="sd">    class, using default drift and stochastic terms inherited from the ItoProcess parent class. The</span>
<span class="sd">    StandardBrownianMeander is explicitly categorized as both a &quot;meander&quot; and &quot;standard&quot; process type,</span>
<span class="sd">    reflecting its nature as a standard implementation of the Brownian meander concept. The _independent</span>
<span class="sd">    attribute is set to False, emphasizing the process&#39;s non-independent increment property, which is a</span>
<span class="sd">    crucial characteristic distinguishing it from standard Brownian motion and highlighting its unique</span>
<span class="sd">    constrained behavior while allowing for endpoint flexibility.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Standard Brownian Meander&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticBrownianMeander</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the StandardBrownianMeander class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;meander&quot;</span><span class="p">,</span> <span class="s2">&quot;standard&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">drift_term</span><span class="o">=</span><span class="n">drift_term_default</span><span class="p">,</span> <span class="n">stochastic_term</span><span class="o">=</span><span class="n">stochastic_term_default</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_independent</span> <span class="o">=</span> <span class="kc">False</span></div>

        
<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">BrownianMotion</span> <span class="k">as</span> <span class="n">StochasticBrownianMotion</span>
<div class="viewcode-block" id="BrownianMotion">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.BrownianMotion">[docs]</a>
<span class="k">class</span> <span class="nc">BrownianMotion</span><span class="p">(</span><span class="n">ItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    BrownianMotion represents a fundamental continuous-time stochastic process, also known as Wiener process,</span>
<span class="sd">    which models random motion observed in particles suspended in a fluid. This process, denoted as (W_t)_{t≥0},</span>
<span class="sd">    is characterized by its independent increments, continuous paths, and Gaussian distribution. Mathematically,</span>
<span class="sd">    for 0 ≤ s &lt; t, the increment W_t - W_s follows a normal distribution N(μ(t-s), σ²(t-s)), where μ is the drift</span>
<span class="sd">    and σ is the scale parameter. Key properties include: stationary and independent increments, continuous sample</span>
<span class="sd">    paths (almost surely), and self-similarity. The process starts at 0 (W_0 = 0) and has an expected value of</span>
<span class="sd">    E[W_t] = μt and variance Var(W_t) = σ²t. As an Itô process, Brownian motion is fundamental in stochastic</span>
<span class="sd">    calculus and serves as a building block for more complex stochastic processes. It finds widespread applications</span>
<span class="sd">    in various fields, including physics (particle diffusion), finance (stock price modeling), biology (population</span>
<span class="sd">    dynamics), and engineering (noise in electronic systems). This implementation allows for both standard</span>
<span class="sd">    (μ = 0, σ = 1) and generalized Brownian motion. The class is initialized with customizable drift and scale</span>
<span class="sd">    parameters, defaulting to standard values. It&#39;s categorized under the &quot;brownian&quot; type, reflecting its nature.</span>
<span class="sd">    The _has_wrong_params attribute is set to True, indicating that the parameters might need adjustment or</span>
<span class="sd">    special handling in certain contexts, particularly when integrating this process into larger systems or</span>
<span class="sd">    when transitioning between different time scales.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Standard Brownian Motion&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticBrownianMotion</span><span class="p">,</span> <span class="n">drift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">drift_term_default</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">stochastic_term_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the BrownianMotion class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param drift: The drift term for the process</span>
<span class="sd">        :type drift: float</span>
<span class="sd">        :param scale: The stochastic term for the process</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;brownian&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">drift_term</span><span class="o">=</span><span class="n">drift</span><span class="p">,</span> <span class="n">stochastic_term</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span> <span class="o">=</span> <span class="n">drift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drift_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_wrong_params</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="BrownianMotion.custom_increment">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.BrownianMotion.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom increment function for the process.</span>

<span class="sd">        :param X: The current value of the process</span>
<span class="sd">        :type X: float</span>
<span class="sd">        :param timestep: The time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: The increment value</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">timestep</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span> <span class="o">+</span> <span class="p">(</span><span class="n">timestep</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dX</span></div>
</div>


<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">CauchyProcess</span> <span class="k">as</span> <span class="n">StochasticCauchyProcess</span>
<div class="viewcode-block" id="CauchyProcess">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.CauchyProcess">[docs]</a>
<span class="k">class</span> <span class="nc">CauchyProcess</span><span class="p">(</span><span class="n">NonItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CauchyProcess represents a continuous-time stochastic process that models random motion with heavy-tailed</span>
<span class="sd">    distributions. This process, denoted as (C_t)_{t≥0}, is characterized by its stable distribution with index</span>
<span class="sd">    α = 1, making it a special case of Lévy processes. Unlike Brownian motion, the Cauchy process has undefined</span>
<span class="sd">    moments beyond the first order, including an undefined mean and infinite variance. It exhibits several key</span>
<span class="sd">    properties: stationary and independent increments, self-similarity, and sample paths that are continuous but</span>
<span class="sd">    highly irregular with frequent large jumps. For any time interval [s, t], the increment C_t - C_s follows a</span>
<span class="sd">    Cauchy distribution with location parameter 0 and scale parameter |t-s|. The process is non-Gaussian and</span>
<span class="sd">    does not satisfy the conditions of the central limit theorem, leading to its classification as a NonItoProcess.</span>
<span class="sd">    CauchyProcess finds applications in various fields, including physics (modeling resonance phenomena), finance</span>
<span class="sd">    (risk assessment in markets with extreme events), and signal processing (robust statistical methods). It&#39;s</span>
<span class="sd">    particularly useful in scenarios where extreme events or outliers play a significant role. This implementation</span>
<span class="sd">    is initialized with a name and process class, and is categorized under the &quot;cauchy&quot; type. The lack of defined</span>
<span class="sd">    drift and stochastic terms reflects the process&#39;s unique nature, where traditional moment-based analysis does</span>
<span class="sd">    not apply. Researchers and practitioners should be aware of the challenges in working with Cauchy processes,</span>
<span class="sd">    including the inapplicability of standard statistical tools that rely on finite moments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Cauchy Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticCauchyProcess</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the CauchyProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cauchy&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">)</span></div>


<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">FractionalBrownianMotion</span> <span class="k">as</span> <span class="n">StochasticFractionalBrownianMotion</span>
<div class="viewcode-block" id="StandardFractionalBrownianMotion">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.StandardFractionalBrownianMotion">[docs]</a>
<span class="k">class</span> <span class="nc">StandardFractionalBrownianMotion</span><span class="p">(</span><span class="n">NonItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    StandardFractionalBrownianMotion (fBm) represents a generalization of classical Brownian motion, characterized</span>
<span class="sd">    by long-range dependence and self-similarity. This continuous-time Gaussian process, denoted as (B^H_t)_{t≥0},</span>
<span class="sd">    is uniquely determined by its Hurst parameter H ∈ (0,1), which governs its correlation structure and path</span>
<span class="sd">    properties. The process exhibits several key features: stationary increments, self-similarity with parameter H,</span>
<span class="sd">    and long-range dependence for H &gt; 0.5. Its covariance function is given by E[B^H_t B^H_s] = 0.5(|t|^2H + |s|^2H -</span>
<span class="sd">    |t-s|^2H). When H = 0.5, fBm reduces to standard Brownian motion; for H &gt; 0.5, it shows persistent behavior,</span>
<span class="sd">    while for H &lt; 0.5, it displays anti-persistent behavior. Unlike standard Brownian motion, fBm is not a</span>
<span class="sd">    semimartingale for H ≠ 0.5 and thus does not fit into the classical Itô calculus framework, hence its</span>
<span class="sd">    classification as a NonItoProcess. The process finds wide applications in various fields: in finance for</span>
<span class="sd">    modeling long-term dependencies in asset returns, in network traffic analysis for capturing self-similar</span>
<span class="sd">    patterns, in hydrology for studying long-term correlations in river flows, and in biophysics for analyzing</span>
<span class="sd">    anomalous diffusion phenomena. This implementation is initialized with a name, process class, and Hurst</span>
<span class="sd">    parameter (defaulting to 0.5), and is categorized as both &quot;standard&quot; and &quot;fractional&quot;. The _independent</span>
<span class="sd">    attribute is set to False, reflecting the process&#39;s inherent long-range dependence. Researchers and</span>
<span class="sd">    practitioners should be aware of the unique challenges in working with fBm, including the need for specialized</span>
<span class="sd">    stochastic calculus tools and careful interpretation of its long-range dependence properties in practical</span>
<span class="sd">    applications.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Standard Fractional Brownian Motion&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticFractionalBrownianMotion</span><span class="p">,</span> <span class="n">hurst</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the StandardFractionalBrownianMotion class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param hurst: The Hurst parameter for the fractional Brownian motion</span>
<span class="sd">        :type hurst: float</span>
<span class="sd">        :raises ValueError: If the Hurst parameter is outside the range (0, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="s2">&quot;fractional&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">)</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">hurst</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hurst</span> <span class="o">=</span> <span class="n">hurst</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The Hurst parameter must be in the range (0, 1).&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_independent</span> <span class="o">=</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="FractionalBrownianMotion">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.FractionalBrownianMotion">[docs]</a>
<span class="k">class</span> <span class="nc">FractionalBrownianMotion</span><span class="p">(</span><span class="n">StandardFractionalBrownianMotion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FractionalBrownianMotion extends the StandardFractionalBrownianMotion, offering a more generalized implementation</span>
<span class="sd">    with additional parametric flexibility. This process, denoted as (X^H_t)_{t≥0}, is a continuous-time Gaussian</span>
<span class="sd">    process characterized by its Hurst parameter H and a constant mean μ. It is defined as X^H_t = μt + B^H_t, where</span>
<span class="sd">    B^H_t is the standard fractional Brownian motion. The process inherits key properties from fBm, including</span>
<span class="sd">    self-similarity with parameter H, stationary increments, and long-range dependence for H &gt; 0.5. Its covariance</span>
<span class="sd">    structure is given by Cov(X^H_t, X^H_s) = 0.5(|t|^2H + |s|^2H - |t-s|^2H), independent of μ. The mean parameter</span>
<span class="sd">    allows for modeling scenarios with deterministic trends superimposed on the fractal behavior of fBm. This</span>
<span class="sd">    implementation is particularly useful in fields where both long-term correlations and underlying trends are</span>
<span class="sd">    significant, such as in financial econometrics for modeling asset returns with both momentum and mean-reversion,</span>
<span class="sd">    in climate science for analyzing temperature anomalies with long-term trends, and in telecommunications for</span>
<span class="sd">    studying network traffic with evolving baselines. The class is initialized with a name, optional process class,</span>
<span class="sd">    mean (defaulting to the standard drift term), and Hurst parameter (defaulting to a predefined value). It&#39;s</span>
<span class="sd">    categorized specifically under the &quot;fractional&quot; type, emphasizing its nature as a fractional process. Researchers</span>
<span class="sd">    and practitioners should note that while the added mean parameter enhances modeling flexibility, it does not</span>
<span class="sd">    affect the fundamental fractal properties governed by the Hurst parameter. Care should be taken in estimation</span>
<span class="sd">    and interpretation, particularly in distinguishing between the effects of the mean trend and the intrinsic</span>
<span class="sd">    long-range dependence of the process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Fractional Brownian Motion&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mean</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">drift_term_default</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">stochastic_term_default</span><span class="p">,</span> <span class="n">hurst</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">hurst_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the FractionalBrownianMotion class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param mean: The mean value for the process</span>
<span class="sd">        :type mean: float</span>
<span class="sd">        :param scale: The scale parameter for the process</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :param hurst: The Hurst parameter for the fractional Brownian motion</span>
<span class="sd">        :type hurst: float</span>
<span class="sd">        :raises ValueError: If the scale parameter is negative</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">hurst</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;fractional&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mean</span> <span class="o">=</span> <span class="n">mean</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The scale parameter must be non-negative.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="FractionalBrownianMotion.custom_increment">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.FractionalBrownianMotion.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom increment function for the process.</span>

<span class="sd">        :param X: The current value of the process</span>
<span class="sd">        :type X: float</span>
<span class="sd">        :param timestep: The time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: The increment value</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">FBM</span> <span class="o">=</span> <span class="n">StandardFractionalBrownianMotion</span><span class="p">(</span><span class="n">hurst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hurst</span><span class="p">)</span>
        <span class="n">dW</span> <span class="o">=</span> <span class="n">FBM</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">timestep_increment</span><span class="o">=</span><span class="n">timestep</span><span class="p">)</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mean</span> <span class="o">*</span> <span class="n">timestep</span> <span class="o">+</span> <span class="p">(</span><span class="n">timestep</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hurst</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span>
        <span class="k">return</span> <span class="n">dX</span></div>
</div>


<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">GammaProcess</span> <span class="k">as</span> <span class="n">StochasticGammaProcess</span>
<div class="viewcode-block" id="GammaProcess">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.GammaProcess">[docs]</a>
<span class="k">class</span> <span class="nc">GammaProcess</span><span class="p">(</span><span class="n">NonItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GammaProcess represents a continuous-time stochastic process with independent, stationary increments following</span>
<span class="sd">    a gamma distribution. This process, denoted as (G_t)_{t≥0}, is characterized by its rate parameter α &gt; 0 and</span>
<span class="sd">    scale parameter θ &gt; 0. For any time interval [s, t], the increment G_t - G_s follows a gamma distribution with</span>
<span class="sd">    shape α(t-s) and scale θ. Key properties include: strictly increasing sample paths (making it suitable for</span>
<span class="sd">    modeling cumulative processes), infinite divisibility, and self-similarity. The process has expected value</span>
<span class="sd">    E[G_t] = αθt and variance Var(G_t) = αθ²t. As a Lévy process, it possesses jumps and is not a semimartingale,</span>
<span class="sd">    hence its classification as a NonItoProcess. GammaProcess finds diverse applications: in finance for modeling</span>
<span class="sd">    aggregate claims in insurance or cumulative losses, in reliability theory for describing degradation processes,</span>
<span class="sd">    and in physics for studying certain types of particle emissions. It&#39;s particularly useful in scenarios requiring</span>
<span class="sd">    non-negative, increasing processes with possible jumps. This implementation is initialized with a name, process</span>
<span class="sd">    class, rate (α, defaulting to 1.0), and scale (θ, defaulting to a predefined stochastic term). It&#39;s categorized</span>
<span class="sd">    under the &quot;gamma&quot; type. The separate rate and scale parameters offer flexibility in modeling, allowing for</span>
<span class="sd">    fine-tuning of both the frequency (via rate) and magnitude (via scale) of the increments. Practitioners should</span>
<span class="sd">    be aware of the process&#39;s non-Gaussian nature and the implications for statistical analysis and risk assessment,</span>
<span class="sd">    particularly in heavy-tailed scenarios where the gamma process can provide a more realistic model than</span>
<span class="sd">    Gaussian-based alternatives.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Gamma Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticGammaProcess</span><span class="p">,</span> <span class="n">rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">stochastic_term_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the GammaProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param rate: The rate parameter for the gamma process</span>
<span class="sd">        :type rate: float</span>
<span class="sd">        :param scale: The scale parameter for the gamma process</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :raises ValueError: If the rate parameter is non-positive</span>
<span class="sd">        :raises ValueError: If the scale parameter is negative</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gamma&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rate</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The rate parameter must be positive.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rate</span> <span class="o">=</span> <span class="n">rate</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The scale parameter must be non-negative.&quot;</span><span class="p">)</span></div>


<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">InverseGaussianProcess</span> <span class="k">as</span> <span class="n">StochasticInverseGaussianProcess</span>
<div class="viewcode-block" id="InverseGaussianProcess">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.InverseGaussianProcess">[docs]</a>
<span class="k">class</span> <span class="nc">InverseGaussianProcess</span><span class="p">(</span><span class="n">NonItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    InverseGaussianProcess represents a continuous-time stochastic process with independent, stationary increments</span>
<span class="sd">    following an inverse Gaussian distribution. This process, denoted as (IG_t)_{t≥0}, is characterized by its</span>
<span class="sd">    mean function μ(t) and scale parameter λ &gt; 0. For any time interval [s, t], the increment IG_t - IG_s follows</span>
<span class="sd">    an inverse Gaussian distribution with mean μ(t) - μ(s) and shape parameter λ(t-s). Key properties include:</span>
<span class="sd">    strictly increasing sample paths, infinite divisibility, and a more complex self-similarity structure compared</span>
<span class="sd">    to the Gamma process. The process has expected value E[IG_t] = μ(t) and variance Var(IG_t) = μ(t)³/λ. As a</span>
<span class="sd">    Lévy process, it exhibits jumps and is not a semimartingale, hence its classification as a NonItoProcess.</span>
<span class="sd">    InverseGaussianProcess finds applications in various fields: in finance for modeling first passage times in</span>
<span class="sd">    diffusion processes or asset returns with asymmetric distributions, in hydrology for describing particle</span>
<span class="sd">    transport in porous media, and in reliability theory for modeling degradation processes with a natural barrier.</span>
<span class="sd">    It&#39;s particularly useful in scenarios requiring non-negative, increasing processes with possible jumps and</span>
<span class="sd">    where the relationship between mean and variance is non-linear. This implementation is initialized with a name,</span>
<span class="sd">    process class, mean function (defaulting to the identity function λ(t) = t), and scale parameter (defaulting</span>
<span class="sd">    to a predefined stochastic term). It&#39;s categorized under both &quot;inverse&quot; and &quot;gaussian&quot; types, reflecting its</span>
<span class="sd">    nature as an inverse Gaussian process. The flexible mean function allows for modeling time-varying trends,</span>
<span class="sd">    while the scale parameter controls the variability of the process. Practitioners should be aware of the</span>
<span class="sd">    process&#39;s unique distributional properties, particularly its skewness and heavy right tail, which can be</span>
<span class="sd">    advantageous in modeling phenomena with occasional large positive deviations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Inverse Gaussian Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticInverseGaussianProcess</span><span class="p">,</span> <span class="n">mean</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">stochastic_term_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the InverseGaussianProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param mean: The mean function for the process</span>
<span class="sd">        :type mean: Callable[[float], float]</span>
<span class="sd">        :param scale: The scale parameter for the process</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :raises ValueError: If the scale parameter is negative</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mean</span> <span class="o">=</span> <span class="n">mean</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The scale parameter must be non-negative.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;inverse&quot;</span><span class="p">,</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">]</span></div>


<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">MultifractionalBrownianMotion</span> <span class="k">as</span> <span class="n">StochasticMultifractionalBrownianMotion</span>
<div class="viewcode-block" id="StandardMultifractionalBrownianMotion">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.StandardMultifractionalBrownianMotion">[docs]</a>
<span class="k">class</span> <span class="nc">StandardMultifractionalBrownianMotion</span><span class="p">(</span><span class="n">NonItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    StandardMultifractionalBrownianMotion (mBm) represents a generalization of fractional Brownian motion, allowing</span>
<span class="sd">    for a time-varying Hurst parameter. This continuous-time Gaussian process, denoted as (B^H(t)_t)_{t≥0}, is</span>
<span class="sd">    characterized by its Hurst function H(t) : [0,∞) → (0,1), which governs its local regularity and correlation</span>
<span class="sd">    structure. The process exhibits several key features: non-stationary increments, local self-similarity, and</span>
<span class="sd">    variable long-range dependence. Its covariance structure is complex, approximated by E[B^H(t)_t B^H(s)_s] ≈</span>
<span class="sd">    0.5(t^(H(t)+H(s)) + s^(H(t)+H(s)) - |t-s|^(H(t)+H(s))). When H(t) is constant, mBm reduces to fractional</span>
<span class="sd">    Brownian motion. The process allows for modeling phenomena with time-varying fractal behavior, where the local</span>
<span class="sd">    regularity evolves over time. As a non-stationary and generally non-Markovian process, it is classified as a</span>
<span class="sd">    NonItoProcess, requiring specialized stochastic calculus techniques. StandardMultifractionalBrownianMotion</span>
<span class="sd">    finds wide applications in various fields: in finance for modeling assets with time-varying volatility and</span>
<span class="sd">    long-range dependence, in image processing for texture analysis with varying local regularity, in geophysics</span>
<span class="sd">    for studying seismic data with evolving fractal characteristics, and in network traffic analysis for capturing</span>
<span class="sd">    time-dependent self-similar patterns. This implementation is initialized with a name, process class, and a</span>
<span class="sd">    Hurst function (defaulting to a constant function H(t) = 0.5, which corresponds to standard Brownian motion).</span>
<span class="sd">    It&#39;s categorized under &quot;multifractional&quot;, &quot;fractional&quot;, &quot;standard&quot;, and &quot;brownian&quot; types, reflecting its nature</span>
<span class="sd">    as a generalized Brownian motion. The _independent attribute is set to False, emphasizing the process&#39;s complex</span>
<span class="sd">    dependence structure. Researchers and practitioners should be aware of the challenges in working with mBm,</span>
<span class="sd">    including parameter estimation of the Hurst function, interpretation of local and global properties, and the</span>
<span class="sd">    need for advanced numerical methods for simulation and analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Multifractional Brownian Motion&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticMultifractionalBrownianMotion</span><span class="p">,</span> <span class="n">hurst</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the StandardMultifractionalBrownianMotion class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param hurst: The Hurst parameter function for the multifractional Brownian motion</span>
<span class="sd">        :type hurst: Callable[[float], float]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;multifractional&quot;</span><span class="p">,</span> <span class="s2">&quot;fractional&quot;</span><span class="p">,</span> <span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="s1">&#39;brownian&#39;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hurst</span> <span class="o">=</span> <span class="n">hurst</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_independent</span> <span class="o">=</span> <span class="kc">False</span></div>


<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">SquaredBesselProcess</span> <span class="k">as</span> <span class="n">StochasticSquaredBesselProcess</span>
<div class="viewcode-block" id="SquaredBesselProcess">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.SquaredBesselProcess">[docs]</a>
<span class="k">class</span> <span class="nc">SquaredBesselProcess</span><span class="p">(</span><span class="n">ItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SquaredBesselProcess represents a continuous-time stochastic process that models the square of the Euclidean</span>
<span class="sd">    norm of a d-dimensional Brownian motion. This process, denoted as (R²_t)_{t≥0}, is characterized by its</span>
<span class="sd">    dimension parameter d &gt; 0, which need not be an integer. For a d-dimensional Brownian motion (B_t), the squared</span>
<span class="sd">    Bessel process is defined as R²_t = ||B_t||². It satisfies the stochastic differential equation dR²_t = d dt +</span>
<span class="sd">    2√(R²_t) dW_t, where W_t is a standard Brownian motion. Key properties include: non-negativity, the dimension</span>
<span class="sd">    parameter d determining its behavior (recurrent for 0 &lt; d &lt; 2, transient for d ≥ 2), and its role in the</span>
<span class="sd">    Pitman-Yor process for d = 0. The process exhibits different characteristics based on d: for d ≥ 2, it never</span>
<span class="sd">    reaches zero; for 0 &lt; d &lt; 2, it touches zero but immediately rebounds; for d = 0, it is absorbed at zero.</span>
<span class="sd">    SquaredBesselProcess finds applications in various fields: in financial mathematics for modeling interest rates</span>
<span class="sd">    and volatility (particularly in the Cox-Ingersoll-Ross model), in population genetics for describing the</span>
<span class="sd">    evolution of genetic diversity, and in queueing theory for analyzing busy periods in certain queue models. As</span>
<span class="sd">    an Itô process, it follows the rules of Itô calculus, making it amenable to standard stochastic calculus</span>
<span class="sd">    techniques. This implementation is initialized with a name, process class, and dimension parameter (defaulting</span>
<span class="sd">    to a predefined value). It&#39;s categorized under both &quot;squared&quot; and &quot;bessel&quot; types, reflecting its nature as the</span>
<span class="sd">    square of a Bessel process. The drift and stochastic terms are set to default values, with the actual dynamics</span>
<span class="sd">    governed by the dimension parameter. Researchers and practitioners should be aware of the process&#39;s unique</span>
<span class="sd">    properties, particularly its dimension-dependent behavior, which can be crucial in accurately modeling and</span>
<span class="sd">    analyzing phenomena in various applications.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Squared Bessel Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticSquaredBesselProcess</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">dim_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the SquaredBesselProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param dim: The dimension of the squared Bessel process</span>
<span class="sd">        :type dim: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;squared&quot;</span><span class="p">,</span> <span class="s2">&quot;bessel&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">drift_term</span><span class="o">=</span><span class="n">drift_term_default</span><span class="p">,</span> <span class="n">stochastic_term</span><span class="o">=</span><span class="n">stochastic_term_default</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="n">dim</span></div>


<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">VarianceGammaProcess</span> <span class="k">as</span> <span class="n">StochasticVarianceGammaProcess</span>
<div class="viewcode-block" id="VarianceGammaProcess">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.VarianceGammaProcess">[docs]</a>
<span class="k">class</span> <span class="nc">VarianceGammaProcess</span><span class="p">(</span><span class="n">NonItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GeneralizedHyperbolicProcess represents a highly flexible class of continuous-time stochastic processes that</span>
<span class="sd">    encompasses a wide range of distributions, including normal, Student&#39;s t, variance-gamma, and normal-inverse</span>
<span class="sd">    Gaussian as special or limiting cases. This process, denoted as (X_t)_{t≥0}, is characterized by five parameters:</span>
<span class="sd">    α (tail heaviness), β (asymmetry), μ (location), δ (scale), and λ (a shape parameter, often denoted as &#39;a&#39; in</span>
<span class="sd">    the implementation). The process is defined through its increments, which follow a generalized hyperbolic</span>
<span class="sd">    distribution. Key properties include: semi-heavy tails (heavier than Gaussian but lighter than power-law),</span>
<span class="sd">    ability to model skewness, and a complex autocorrelation structure. The process allows for both large jumps</span>
<span class="sd">    and continuous movements, making it highly adaptable to various phenomena. It&#39;s particularly noted for its</span>
<span class="sd">    capacity to capture both the central behavior and the extreme events in a unified framework.</span>

<span class="sd">    Parameter restrictions are crucial for the proper definition of the process:</span>

<span class="sd">    - α &gt; 0: Controls the tail heaviness, with larger values leading to lighter tails.</span>

<span class="sd">    - |β| &lt; α: Determines the skewness, with β = 0 yielding symmetric distributions.</span>

<span class="sd">    - δ &gt; 0: Acts as a scaling factor.</span>

<span class="sd">    - μ can take any real value.</span>

<span class="sd">    - λ (if provided via kwargs) can be any real number, affecting the shape of the distribution.</span>

<span class="sd">    The GeneralizedHyperbolicProcess finds extensive applications in finance for modeling asset returns, particularly</span>
<span class="sd">    in markets exhibiting skewness and kurtosis; in risk management for more accurate tail risk assessment; in</span>
<span class="sd">    physics for describing particle movements in heterogeneous media; and in signal processing for modeling</span>
<span class="sd">    non-Gaussian noise. This implementation is initialized with parameters α, β, μ (loc), and δ (scale), with</span>
<span class="sd">    additional parameters possible through kwargs. It&#39;s categorized under both &quot;generalized&quot; and &quot;hyperbolic&quot; types,</span>
<span class="sd">    reflecting its nature as a broad, hyperbolic-based process. The class uses a custom increment function,</span>
<span class="sd">    indicated by the _external_simulator flag set to False. This allows for precise control over the generation</span>
<span class="sd">    of process increments, crucial for accurately representing the complex distribution. Researchers and</span>
<span class="sd">    practitioners should be aware of the computational challenges in parameter estimation and simulation,</span>
<span class="sd">    particularly in high-dimensional settings or with extreme parameter values. The flexibility of the generalized</span>
<span class="sd">    hyperbolic process comes with increased model complexity, requiring careful consideration in application and</span>
<span class="sd">    interpretation. Its ability to nest simpler models allows for sophisticated hypothesis testing and model</span>
<span class="sd">    selection in empirical studies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Variance Gamma Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticVarianceGammaProcess</span><span class="p">,</span> <span class="n">drift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">drift_term_default</span><span class="p">,</span> <span class="n">variance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">stochastic_term_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the VarianceGammaProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param drift: The drift term for the process</span>
<span class="sd">        :type drift: float</span>
<span class="sd">        :param variance: The variance parameter for the process</span>
<span class="sd">        :type variance: float</span>
<span class="sd">        :param scale: The scale parameter for the process</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :raises ValueError: If the scale parameter is negative</span>
<span class="sd">        :raises ValueError: If the variance parameter is non-positive</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;variance&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span> <span class="o">=</span> <span class="n">drift</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The scale parameter must be non-negative.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">variance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_variance</span> <span class="o">=</span> <span class="n">variance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The variance parameter must be positive.&quot;</span><span class="p">)</span></div>


<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">WienerProcess</span> <span class="k">as</span> <span class="n">StochasticWienerProcess</span>
<div class="viewcode-block" id="WienerProcess">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.WienerProcess">[docs]</a>
<span class="k">class</span> <span class="nc">WienerProcess</span><span class="p">(</span><span class="n">ItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    WienerProcess represents the fundamental continuous-time stochastic process, also known as standard Brownian</span>
<span class="sd">    motion, which forms the cornerstone of many stochastic models in science and finance. This process, denoted as</span>
<span class="sd">    (W_t)_{t≥0}, is characterized by its properties of independent increments, continuous paths, and Gaussian</span>
<span class="sd">    distribution. For any time interval [s,t], the increment W_t - W_s follows a normal distribution N(0, t-s).</span>
<span class="sd">    Key properties include: almost surely continuous sample paths, non-differentiability at any point, self-similarity,</span>
<span class="sd">    and the strong Markov property. The process starts at 0 (W_0 = 0) and has an expected value of E[W_t] = 0 and</span>
<span class="sd">    variance Var(W_t) = t. As the quintessential Itô process, it serves as the building block for more complex</span>
<span class="sd">    stochastic differential equations and is central to Itô calculus. WienerProcess finds ubiquitous applications</span>
<span class="sd">    across various fields: in physics for modeling Brownian motion and diffusion processes, in financial mathematics</span>
<span class="sd">    for describing stock price movements and as a basis for the Black-Scholes model, in signal processing for</span>
<span class="sd">    representing white noise, and in control theory for modeling disturbances in dynamical systems. This implementation</span>
<span class="sd">    is initialized with a name and process class, with drift term fixed at 0 and stochastic term at 1, adhering to</span>
<span class="sd">    the standard definition. It&#39;s categorized under both &quot;wiener&quot; and &quot;standard&quot; types, emphasizing its nature as</span>
<span class="sd">    the canonical continuous-time stochastic process. The simplicity of its parameter-free definition belies the</span>
<span class="sd">    complexity and richness of its behavior, making it a versatile tool in stochastic modeling. Researchers and</span>
<span class="sd">    practitioners should be aware of both its power as a modeling tool and its limitations, particularly in capturing</span>
<span class="sd">    more complex real-world phenomena that may require extensions or generalizations of the basic Wiener process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Wiener Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticWienerProcess</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the WienerProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;wiener&quot;</span><span class="p">,</span> <span class="s1">&#39;standard&#39;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">drift_term</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stochastic_term</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<span class="kn">from</span> <span class="nn">stochastic.processes.continuous</span> <span class="kn">import</span> <span class="n">PoissonProcess</span> <span class="k">as</span> <span class="n">StochasticPoissonProcess</span>
<div class="viewcode-block" id="PoissonProcess">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.PoissonProcess">[docs]</a>
<span class="k">class</span> <span class="nc">PoissonProcess</span><span class="p">(</span><span class="n">NonItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PoissonProcess represents a fundamental continuous-time stochastic process that models the occurrence of</span>
<span class="sd">    random events or arrivals at a constant average rate. This process, denoted as (N_t)_{t≥0}, is characterized</span>
<span class="sd">    by its rate parameter λ &gt; 0, which represents the average number of events per unit time. For any time</span>
<span class="sd">    interval [s,t], the number of events N_t - N_s follows a Poisson distribution with parameter λ(t-s). Key</span>
<span class="sd">    properties include: independent increments, stationary increments, right-continuous step function sample paths,</span>
<span class="sd">    and the memoryless property. The process starts at 0 (N_0 = 0) and has an expected value of E[N_t] = λt and</span>
<span class="sd">    variance Var(N_t) = λt. As a pure jump process, it is classified as a NonItoProcess, distinct from continuous</span>
<span class="sd">    processes like Brownian motion. PoissonProcess finds extensive applications across various fields: in queueing</span>
<span class="sd">    theory for modeling arrival processes, in reliability theory for describing failure occurrences, in insurance</span>
<span class="sd">    for modeling claim arrivals, in neuroscience for representing neuronal firing patterns, and in physics for</span>
<span class="sd">    modeling radioactive decay. This implementation is initialized with a name, process class, and a rate parameter</span>
<span class="sd">    (defaulting to 2.0), allowing for flexible modeling of event frequencies. It&#39;s categorized under the &quot;poisson&quot;</span>
<span class="sd">    type, reflecting its nature as a Poisson process. The simplicity of its single-parameter definition belies its</span>
<span class="sd">    powerful modeling capabilities, particularly for discrete events in continuous time. Researchers and</span>
<span class="sd">    practitioners should be aware of both its strengths in modeling random occurrences and its limitations,</span>
<span class="sd">    such as the assumption of constant rate and independence between events, which may not hold in all real-world</span>
<span class="sd">    scenarios. Extensions like non-homogeneous Poisson processes or compound Poisson processes can address some</span>
<span class="sd">    of these limitations for more complex modeling needs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Poisson Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">StochasticPoissonProcess</span><span class="p">,</span> <span class="n">rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the PoissonProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param rate: The rate parameter for the Poisson process</span>
<span class="sd">        :type rate: float</span>
<span class="sd">        :raises ValueError: If the rate parameter is non-positive</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;poisson&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rate</span> <span class="o">=</span> <span class="n">rate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The rate parameter must be positive.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="PoissonProcess.simulate">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.PoissonProcess.simulate">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span> <span class="n">num_instances</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">num_instances_default</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the Poisson process, plot, and save it.</span>

<span class="sd">        :param t: The time horizon for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: The time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param num_instances: The number of process instances to simulate</span>
<span class="sd">        :type num_instances: int</span>
<span class="sd">        :param save: Whether to save the simulation results</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to plot the simulation results</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return: The simulated Poisson process dataset as a NumPy array of shape (num_instances+1, num_steps)</span>
<span class="sd">        :rtype: Any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_steps</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_for_simulation</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">num_instances</span><span class="p">)</span>

        <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_class</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_instances</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">data_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">times</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">data</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data_full</span><span class="p">,</span> <span class="n">num_instances</span><span class="p">,</span> <span class="n">save</span><span class="p">,</span> <span class="n">plot</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_full</span></div>
</div>


<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">levy_stable</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">levy_stable</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.definitions</span> <span class="kn">import</span> <span class="n">NonItoProcess</span>

<div class="viewcode-block" id="LevyStableProcess">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.LevyStableProcess">[docs]</a>
<span class="k">class</span> <span class="nc">LevyStableProcess</span><span class="p">(</span><span class="n">NonItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LevyStableProcess represents a versatile class of continuous-time stochastic processes that generalize the</span>
<span class="sd">    Gaussian distribution to allow for heavy tails and skewness. This process, denoted as (X_t)_{t≥0}, is</span>
<span class="sd">    characterized by four parameters: α (stability), β (skewness), σ (scale), and μ (location). The α parameter,</span>
<span class="sd">    ranging from 0 to 2, determines the tail heaviness, with α = 2 corresponding to Gaussian behavior. Key</span>
<span class="sd">    properties include: stable distribution of increments, self-similarity, and, for α &lt; 2, infinite variance</span>
<span class="sd">    and potential for large jumps. The process offers remarkable flexibility, encompassing Gaussian (α = 2),</span>
<span class="sd">    Cauchy (α = 1, β = 0), and Lévy (α = 0.5, β = 1) processes as special cases. This implementation extends</span>
<span class="sd">    the basic Lévy stable process with options for tempering and truncation, allowing for more nuanced modeling</span>
<span class="sd">    of extreme events. Tempering introduces exponential decay in the tails, while truncation (either &#39;hard&#39; or</span>
<span class="sd">    &#39;soft&#39;) limits the maximum jump size. These modifications can be crucial in financial modeling to ensure</span>
<span class="sd">    finite moments or in physical systems with natural limits. The process finds wide applications in finance</span>
<span class="sd">    for modeling asset returns and risk, in physics for describing anomalous diffusion, in telecommunications</span>
<span class="sd">    for network traffic analysis, and in geophysics for modeling natural phenomena. The class includes built-in</span>
<span class="sd">    validity checks and informative comments about special cases. It allows for scaled parameterization and</span>
<span class="sd">    provides methods for generating increments, including tempered and truncated variants. The differential</span>
<span class="sd">    and elementary expressions offer insights into the process&#39;s structure. Researchers and practitioners</span>
<span class="sd">    should be aware of the computational challenges in simulating and estimating Lévy stable processes,</span>
<span class="sd">    particularly for small α values, and the interpretative complexities introduced by tempering and truncation.</span>
<span class="sd">    This implementation strikes a balance between the theoretical richness of Lévy stable processes and the</span>
<span class="sd">    practical needs of modeling real-world phenomena with potentially bounded extreme events.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Levy Stable Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">alpha_default</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">beta_default</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">scale_default</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">loc_default</span><span class="p">,</span> <span class="n">default_comments</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">default_comments</span><span class="p">,</span> <span class="n">tempering</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">truncation_level</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">truncation_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;hard&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the LevyStableProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param alpha: The stability parameter (0 &lt; α ≤ 2)</span>
<span class="sd">        :type alpha: float</span>
<span class="sd">        :param beta: The skewness parameter (-1 ≤ β ≤ 1)</span>
<span class="sd">        :type beta: float</span>
<span class="sd">        :param scale: The scale parameter (σ &gt; 0)</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :param loc: The location parameter (μ)</span>
<span class="sd">        :type loc: float</span>
<span class="sd">        :param default_comments: Whether to display default comments</span>
<span class="sd">        :type default_comments: bool</span>
<span class="sd">        :param tempering: The tempering parameter (λ)</span>
<span class="sd">        :type tempering: float</span>
<span class="sd">        :param truncation_level: The truncation level for the process</span>
<span class="sd">        :type truncation_level: float</span>
<span class="sd">        :param truncation_type: The type of truncation (&#39;hard&#39; or &#39;soft&#39;)</span>
<span class="sd">        :type truncation_type: str</span>
<span class="sd">        :raises ValueError: If the stability parameter is outside the range (0, 2]</span>
<span class="sd">        :raises ValueError: If the skewness parameter is outside the range [-1, 1]</span>
<span class="sd">        :raises ValueError: If the scale parameter is non-positive</span>
<span class="sd">        :raises ValueError: If the tempering parameter is negative</span>
<span class="sd">        :raises ValueError: If the truncation level is negative</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;stable&quot;</span><span class="p">,</span> <span class="s2">&quot;levy stable&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The stability parameter alpha must be in the interval (0, 2].&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="k">if</span> <span class="n">beta</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The skewness parameter beta must be in the interval [-1, 1].&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The scale parameter sigma must be positive.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loc_scaled</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">/</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comments</span> <span class="o">=</span> <span class="n">default_comments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_simulator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">tempering</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The tempering parameter must be non-negative.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tempering</span> <span class="o">=</span> <span class="n">tempering</span>
        <span class="k">if</span> <span class="n">truncation_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">truncation_level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The truncation level must be non-negative.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_level</span> <span class="o">=</span> <span class="n">truncation_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_type</span> <span class="o">=</span> <span class="n">truncation_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="n">truncation_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Determine if the process is tempered</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tempering</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tempered</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tempered</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Determine if truncation is applied</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_truncated</span> <span class="o">=</span> <span class="n">truncation_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="c1"># Set this true to use normal process variance equivalent as the scale parameter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_scale</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_scale</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="o">**</span><span class="mf">0.5</span>

        <span class="c1"># Validity checks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Scale parameter must be positive.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Alpha parameter must be in the interval (0, 2].&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_level</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Truncation level must be positive.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comments</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_comments</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_generate_comments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate default comments based on the process parameters.</span>
<span class="sd">        It provides information on the type of process created.</span>
<span class="sd">        This is helpfull if you need to know the specifics of the process you created.</span>

<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Congratulations! With your parameters, you created a Brownian Motion Process with drift = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="si">}</span><span class="s1"> and scale = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="s1">&#39;brownian&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Even more, you created a Standard Brownian Motion Process!&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="s1">&#39;standard&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.00001</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.99999</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Even more, you created a Wiener Process!&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="s1">&#39;wiener&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Congratulations! With your parameters, you created a Cauchy Process with drift = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="si">}</span><span class="s1"> and scale = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="s1">&#39;cauchy&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">==</span> <span class="mf">0.5</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Congratulations! With your parameters, you created a Levy Process with drift = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="si">}</span><span class="s1"> and scale = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="s1">&#39;levy&#39;</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The stability parameter (0 &lt; α ≤ 2).</span>

<span class="sd">        :return: The stability parameter</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span>

    <span class="nd">@alpha</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter method for the stability parameter.</span>

<span class="sd">        :param alpha: The stability parameter</span>
<span class="sd">        :type alpha: float</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">beta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The skewness parameter (-1 ≤ β ≤ 1).</span>

<span class="sd">        :return: The skewness parameter</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span>

    <span class="nd">@beta</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">beta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter method for the skewness parameter.</span>

<span class="sd">        :param beta: The skewness parameter</span>
<span class="sd">        :type beta: float</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">beta</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The skewness parameter beta must be in the interval [-1, 1].&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">=</span> <span class="n">beta</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The scale parameter (σ &gt; 0).</span>
<span class="sd">        :return: The scale parameter</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="nd">@scale</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter method for the scale parameter.</span>

<span class="sd">        :param scale: The scale parameter</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The scale parameter sigma must be positive.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The location parameter (μ).</span>

<span class="sd">        :return: The location parameter</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span>

    <span class="nd">@loc</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter method for the location parameter.</span>

<span class="sd">        :param loc: The location parameter</span>
<span class="sd">        :type loc: float</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loc_scaled</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">/</span> <span class="mi">10</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tempering</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The tempering parameter (λ).</span>
<span class="sd">        :return: The tempering parameter</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tempering</span>

    <span class="nd">@tempering</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">tempering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tempering</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter method for the tempering parameter.</span>

<span class="sd">        :param tempering: The tempering parameter</span>
<span class="sd">        :type tempering: float</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tempering</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The tempering parameter must be non-negative.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tempering</span> <span class="o">=</span> <span class="n">tempering</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">truncation_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The truncation level for the process.</span>

<span class="sd">        :return: The truncation level</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_level</span>

    <span class="nd">@truncation_level</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">truncation_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truncation_level</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter method for the truncation level.</span>

<span class="sd">        :param truncation_level: The truncation level</span>
<span class="sd">        :type truncation_level: float</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">truncation_level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The truncation level must be non-negative.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_level</span> <span class="o">=</span> <span class="n">truncation_level</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">truncation_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The type of truncation (&#39;hard&#39; or &#39;soft&#39;).</span>

<span class="sd">        :return: The type of truncation</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_type</span>

    <span class="nd">@truncation_type</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">truncation_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truncation_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter method for the truncation type.</span>

<span class="sd">        :param truncation_type: The type of truncation</span>
<span class="sd">        :type truncation_type: str</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_type</span> <span class="o">=</span> <span class="n">truncation_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tempered</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the process is tempered.</span>

<span class="sd">        :return: Whether the process is tempered</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tempered</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">truncated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the process is truncated.</span>

<span class="sd">        :return: Whether the process is truncated</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncated</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scaled_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This getter method is needed because the scale parameter has a different scale in the library which is used for the simulation.</span>

<span class="sd">        :return: The scaled scale parameter</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_scale</span>

    <span class="nd">@scaled_scale</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">scaled_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaled_scale</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This setter method is needed because the scale parameter has a different scale in the library which is used for the simulation.</span>

<span class="sd">        :param scaled_scale: The scaled scale parameter</span>
<span class="sd">        :type scaled_scale: bool</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scaled_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;scaled_scale must be a boolean.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_scale</span> <span class="o">=</span> <span class="n">scaled_scale</span>

<div class="viewcode-block" id="LevyStableProcess.tempered_stable_rvs">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.LevyStableProcess.tempered_stable_rvs">[docs]</a>
    <span class="k">def</span> <span class="nf">tempered_stable_rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a tempered stable random variable.</span>
<span class="sd">        Tempering is applied by multiplying the Levy stable random variable with an exponential factor.</span>
<span class="sd">        Tempering parameter must be non-negative.</span>

<span class="sd">        :return: A tempered stable random variable</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate a sample from a Levy stable distribution</span>
        <span class="n">levy_sample</span> <span class="o">=</span> <span class="n">levy_stable</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">)</span>
        <span class="c1"># Apply the exponential tempering</span>
        <span class="n">tempered_sample</span> <span class="o">=</span> <span class="n">levy_sample</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_tempering</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">levy_sample</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tempered_sample</span></div>


<div class="viewcode-block" id="LevyStableProcess.truncate">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.LevyStableProcess.truncate">[docs]</a>
    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Truncate the value based on the truncation level and type.</span>
<span class="sd">        Truncation can be &#39;hard&#39; (capping the value) or &#39;soft&#39; (applying exponential tempering).</span>
<span class="sd">        Truncation is a common technique to limit the impact of extreme values in a process.</span>
<span class="sd">        It may be needed to apply for a Levy process because of its heavy tails, especially for small alpha.</span>
<span class="sd">        Truncation parameter must be positive.</span>

<span class="sd">        :param value: The value to truncate</span>
<span class="sd">        :type value: float</span>
<span class="sd">        :return: The truncated value</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        :raises ValueError: If the truncation type is invalid (not &#39;hard&#39; or &#39;soft&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_type</span> <span class="o">==</span> <span class="s1">&#39;hard&#39;</span><span class="p">:</span>
            <span class="c1"># Hard truncation: cap the value at the truncation level</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_truncation_level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_level</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_type</span> <span class="o">==</span> <span class="s1">&#39;soft&#39;</span><span class="p">:</span>
            <span class="c1"># Soft truncation: apply exponential tempering</span>
            <span class="k">return</span> <span class="n">value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Truncation type must be either &#39;hard&#39; or &#39;soft&#39;.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="LevyStableProcess.custom_increment">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.LevyStableProcess.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom increment function for the process.</span>

<span class="sd">        :param X: The current value of the process</span>
<span class="sd">        :type X: float</span>
<span class="sd">        :param timestep: The time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: The increment value</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tempered</span><span class="p">:</span>
            <span class="n">dX</span> <span class="o">=</span> <span class="p">(</span><span class="n">timestep</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">))</span> <span class="o">*</span> <span class="n">levy_stable</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc_scaled</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dX</span> <span class="o">=</span> <span class="p">(</span><span class="n">timestep</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tempered_stable_rvs</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncated</span><span class="p">:</span>
            <span class="n">dX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">dX</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dX</span></div>


<div class="viewcode-block" id="LevyStableProcess.differential">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.LevyStableProcess.differential">[docs]</a>
    <span class="k">def</span> <span class="nf">differential</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Express the Levy process as a differential equation.</span>

<span class="sd">        :return: The differential equation of the process</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">truncation_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; with truncation level </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_truncation_level</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_truncation_type</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncated</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">tempering_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; tempered by exp(-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_tempering</span><span class="si">}</span><span class="s2"> * |X|)&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tempered</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;dX(t) = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="si">}</span><span class="s2"> * dt + dt^(1/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="si">}</span><span class="s2">) * </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="si">}</span><span class="s2"> * levy_stable(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span><span class="si">}</span><span class="s2">, 0, 1)</span><span class="si">{</span><span class="n">tempering_str</span><span class="si">}{</span><span class="n">truncation_str</span><span class="si">}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="LevyStableProcess.express_as_elementary">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.LevyStableProcess.express_as_elementary">[docs]</a>
    <span class="k">def</span> <span class="nf">express_as_elementary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Express a given Levy process as a function of an elementary Levy process.</span>

<span class="sd">        :return: The Levy process expressed in terms of elementary Levy processes</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;X(t) = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="si">}</span><span class="s2"> * t + </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="si">}</span><span class="s2"> * LevyStableProcess(alpha=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="si">}</span><span class="s2">, beta=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span><span class="si">}</span><span class="s2">, truncation=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_truncation_level</span><span class="si">}</span><span class="s2">, type=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_truncation_type</span><span class="si">}</span><span class="s2">).increment()&quot;</span></div>
</div>


<div class="viewcode-block" id="LevyStableStandardProcess">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.LevyStableStandardProcess">[docs]</a>
<span class="k">class</span> <span class="nc">LevyStableStandardProcess</span><span class="p">(</span><span class="n">LevyStableProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LevyStableStandardProcess represents a standardized version of the Lévy stable process, a class of</span>
<span class="sd">    continuous-time stochastic processes known for their ability to model heavy-tailed distributions and</span>
<span class="sd">    asymmetry. This process, denoted as (X_t)_{t≥0}, is a special case of the general Lévy stable process</span>
<span class="sd">    with fixed scale and location parameters (set to 1/2**0.5 and 0 correspondingly). It is primarily characterized by two parameters:</span>

<span class="sd">    1. α (alpha): The stability parameter, where 0 &lt; α ≤ 2. This parameter determines the tail heaviness</span>
<span class="sd">       of the distribution. As α approaches 2, the process behaves more like Brownian motion, while</span>
<span class="sd">       smaller values lead to heavier tails and more extreme jumps.</span>

<span class="sd">    2. β (beta): The skewness parameter, where -1 ≤ β ≤ 1. This parameter controls the asymmetry of the</span>
<span class="sd">       distribution. When β = 0, the process is symmetric.</span>

<span class="sd">    The process is standardized with a scale parameter of 1/√2 and a location parameter of 0. This</span>
<span class="sd">    standardization allows for easier comparison and analysis across different α and β combinations.</span>

<span class="sd">    Key properties of the LevyStableStandardProcess include:</span>

<span class="sd">    - Self-similarity: The distribution of the process at any time t is the same as that at time 1,</span>
<span class="sd">      up to a scaling factor.</span>

<span class="sd">    - Stable distributions: The sum of independent copies of the process follows the same distribution,</span>
<span class="sd">      up to scaling and shifting.</span>

<span class="sd">    - Potential for infinite variance: For α &lt; 2, the process has infinite variance, capturing extreme</span>
<span class="sd">      events more effectively than Gaussian processes.</span>

<span class="sd">    The &#39;standard&#39; type is added to the process classification.</span>
<span class="sd">    This allows for more straightforward theoretical analysis and comparison between different</span>
<span class="sd">    parameterizations of the Lévy stable family.</span>

<span class="sd">    Researchers and practitioners should be aware that while this standardized form offers analytical</span>
<span class="sd">    advantages, it may require rescaling and shifting for practical applications. The process&#39;s rich</span>
<span class="sd">    behavior, especially for α &lt; 2, necessitates careful interpretation and often specialized numerical</span>
<span class="sd">    methods for simulation and statistical inference.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Standard Levy Stable Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the LevyStableStandardProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param alpha: The stability parameter (0 &lt; α ≤ 2)</span>
<span class="sd">        :type alpha: float</span>
<span class="sd">        :param beta: The skewness parameter (-1 ≤ β ≤ 1)</span>
<span class="sd">        :type beta: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="s1">&#39;standard&#39;</span><span class="p">)</span></div>


<span class="c1"># https://pylevy.readthedocs.io/en/latest/levy.html#classes</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.animation</span> <span class="k">as</span> <span class="nn">animation</span>
<div class="viewcode-block" id="MultivariateBrownianMotion">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateBrownianMotion">[docs]</a>
<span class="k">class</span> <span class="nc">MultivariateBrownianMotion</span><span class="p">(</span><span class="n">ItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MultivariateBrownianMotion represents a generalization of the standard Brownian motion to multiple dimensions,</span>
<span class="sd">    providing a powerful tool for modeling correlated random processes in various fields. This continuous-time</span>
<span class="sd">    stochastic process, denoted as (X_t)_{t≥0} where X_t is a vector in R^n, is characterized by its drift vector</span>
<span class="sd">    μ ∈ R^n and a positive semi-definite covariance matrix Σ. For any time interval [s,t], the increment</span>
<span class="sd">    X_t - X_s follows a multivariate normal distribution N(μ(t-s), Σ(t-s)). Key properties include: independent</span>
<span class="sd">    and stationary increments, continuous sample paths in each dimension, and the preservation of the Markov</span>
<span class="sd">    property. The process starts at 0 (X_0 = 0) and has an expected value of E[X_t] = μt and covariance matrix</span>
<span class="sd">    Cov(X_t) = Σt. As a multivariate Itô process, it extends the mathematical framework of stochastic calculus</span>
<span class="sd">    to vector-valued processes, enabling the modeling of complex, interrelated phenomena. MultivariateBrownianMotion</span>
<span class="sd">    finds extensive applications across various domains: in finance for modeling correlated asset prices and risk</span>
<span class="sd">    factors, in physics for describing the motion of particles in multiple dimensions, in biology for analyzing</span>
<span class="sd">    the joint evolution of different species or genes, and in engineering for simulating multi-dimensional noise</span>
<span class="sd">    in control systems. This implementation is initialized with a name, optional process class, drift vector, and</span>
<span class="sd">    scale matrix (representing Σ), allowing for flexible specification of the process&#39;s statistical properties.</span>
<span class="sd">    It&#39;s categorized under both &quot;multivariate&quot; and &quot;brownian&quot; types, reflecting its nature as a vector-valued</span>
<span class="sd">    extension of Brownian motion. The class handles the dimensionality automatically based on the input drift</span>
<span class="sd">    vector, and stores the state in the _X attribute. The _external_simulator flag is set to False, indicating</span>
<span class="sd">    that the simulation is handled internally. Researchers and practitioners should be aware of the increased</span>
<span class="sd">    complexity in simulating and analyzing multivariate processes, particularly in high dimensions, and the</span>
<span class="sd">    importance of ensuring the positive semi-definiteness of the scale matrix for valid covariance structures.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Multivariate Brownian Motion&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">drift</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_list_default</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="n">variance_matrix_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the MultivariateBrownianMotion class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param drift: The drift term for the process</span>
<span class="sd">        :type drift: List[float]</span>
<span class="sd">        :param scale: The scale parameter for the process</span>
<span class="sd">        :type scale: List[List[float]]</span>
<span class="sd">        :raises ValueError: If the scale matrix is not positive definite</span>
<span class="sd">        :raises ValueError: If the scale matrix does not match the dimension of the drift vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;multivariate&quot;</span><span class="p">,</span> <span class="s2">&quot;brownian&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">drift_term</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stochastic_term</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">drift</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">drift</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The scale matrix must be positive definite.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The scale matrix must be square and match the dimension of the drift vector.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">drift</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_simulator</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="MultivariateBrownianMotion.custom_increment">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateBrownianMotion.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom increment function for the process.</span>

<span class="sd">        :param X: The current value of the process</span>
<span class="sd">        :type X: List[float]</span>
<span class="sd">        :param timestep: The time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: The increment value</span>
<span class="sd">        :rtype: List[float]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_drift</span> <span class="o">*</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dX</span></div>


<div class="viewcode-block" id="MultivariateBrownianMotion.simulate">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateBrownianMotion.simulate">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the Multivariate Brownian Motion process, plot, and save it.</span>

<span class="sd">        :param t: The time horizon for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: The time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the simulation results</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to plot the simulation results</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return: The simulated process dataset as a NumPy array of shape (num_instances+1, num_steps)</span>
<span class="sd">        :rtype: Any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_instances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span>
        <span class="n">num_steps</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_for_simulation</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">num_instances</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_instances</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">))</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[:,</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
            <span class="n">dX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_increment</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">dX</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulating step </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">, X = </span><span class="si">{</span><span class="n">X</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">times</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">data</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_to_file</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                          <span class="sa">f</span><span class="s2">&quot;process_simulation_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">, t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">, timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">, num_instances:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">,</span>
                          <span class="n">save</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">num_instances</span><span class="p">,</span> <span class="n">save</span><span class="p">,</span> <span class="n">plot</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="MultivariateBrownianMotion.simulate_weights">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateBrownianMotion.simulate_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                  <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the weights (relative shares) of the instances of a Multivariate Brownian Motion process.</span>

<span class="sd">        :param t: The time horizon for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: The time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the simulation results</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to plot the simulation results</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return: The simulated weights dataset as a NumPy array of shape (num_instances+1, num_steps)</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Simulate the process</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Extract the simulated values (exclude the time column)</span>
        <span class="n">simulated_values</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>

        <span class="c1"># Ensure non-negative values by exponentiating</span>
        <span class="n">exp_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">simulated_values</span><span class="p">)</span>

        <span class="c1"># Calculate weights (shares)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">exp_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">exp_values</span> <span class="o">/</span> <span class="n">total</span>

        <span class="c1"># Prepare data for saving</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">weight_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">times</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_to_file</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                          <span class="sa">f</span><span class="s2">&quot;weights_simulation_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">, t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">, timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">, num_instances:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">,</span>
                          <span class="n">save</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Weight </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Weight&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Simulated Weights of Multivariate Brownian Motion&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;weights_plot_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">, t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">, timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">weight_data</span></div>



<div class="viewcode-block" id="MultivariateBrownianMotion.simulate_live">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateBrownianMotion.simulate_live">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_live</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the process live and save as a video file.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: Video file name of the simulation</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">num_instances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span>

        <span class="n">num_steps</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_instances</span><span class="p">)]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Simulation of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Value&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],</span> <span class="p">[])</span>
            <span class="k">return</span> <span class="n">lines</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_instances</span><span class="p">):</span>
                <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">times</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">lines</span>

        <span class="n">ani</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ani</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_simulation.mp4&#39;</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="s1">&#39;ffmpeg&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_simulation.mp4&#39;</span></div>


<div class="viewcode-block" id="MultivariateBrownianMotion.simulate_2d">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateBrownianMotion.simulate_2d">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span>
                    <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a 2D Multivariate Brownian Motion.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the simulation results</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to plot the simulation results</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :raises ValueError: If the process is not 2D</span>
<span class="sd">        :return: Simulated 2D data array</span>
<span class="sd">        :rtype: Any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This method is only for 2D Multivariate Brownian Motion&quot;</span><span class="p">)</span>

        <span class="n">num_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">)</span>

        <span class="n">data_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">))</span>  <span class="c1"># 3 rows: time, x, y</span>
        <span class="n">data_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">times</span>

        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># Use only first two dimensions</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
            <span class="n">data_2d</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
            <span class="n">dX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_increment</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># Use only first two dimensions</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">dX</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;process_simulation_2d_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">, t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">, timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">.csv&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_to_file</span><span class="p">(</span><span class="n">data_2d</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">save</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_2d</span><span class="p">(</span><span class="n">data_2d</span><span class="p">,</span> <span class="n">save</span><span class="p">,</span> <span class="n">plot</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_2d</span></div>


<div class="viewcode-block" id="MultivariateBrownianMotion.simulate_live_2d">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateBrownianMotion.simulate_live_2d">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_live_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span>
                         <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">speed</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the 2D process live and save as a video file.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the simulation data</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param speed: Speed multiplier for the video</span>
<span class="sd">        :type speed: float</span>
<span class="sd">        :return: Video file name of the simulation</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_2d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">num_steps</span> <span class="o">=</span> <span class="n">data_2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;2D Simulation of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],</span> <span class="p">[])</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">x_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="n">fps</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">speed</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">fps</span>  <span class="c1"># interval in milliseconds</span>

        <span class="n">ani</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">)</span>
        <span class="n">video_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_2d_simulation_t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">_timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s1">.mp4&#39;</span>

        <span class="n">ani</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">video_filename</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="s1">&#39;ffmpeg&#39;</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_2d_simulation_data_t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">_timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s1">.csv&#39;</span><span class="p">,</span> <span class="n">data_2d</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">video_filename</span></div>


<div class="viewcode-block" id="MultivariateBrownianMotion.simulate_3d">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateBrownianMotion.simulate_3d">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span>
                    <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a 3D Multivariate Brownian Motion.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the simulation results</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to plot the simulation results</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :raises ValueError: If the process is not 3D</span>
<span class="sd">        :return: Simulated 3D data array</span>
<span class="sd">        :rtype: Any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This method is only for 3D Multivariate Brownian Motion&quot;</span><span class="p">)</span>

        <span class="n">num_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">)</span>

        <span class="n">data_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">))</span>  <span class="c1"># 4 rows: time, x, y, z</span>
        <span class="n">data_3d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">times</span>

        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span>  <span class="c1"># Use all three dimensions</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
            <span class="n">data_3d</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
            <span class="n">dX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_increment</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">dX</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;process_simulation_3d_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">, t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">, timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">.csv&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_to_file</span><span class="p">(</span><span class="n">data_3d</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">save</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_3d</span><span class="p">(</span><span class="n">data_3d</span><span class="p">,</span> <span class="n">save</span><span class="p">,</span> <span class="n">plot</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_3d</span></div>


<div class="viewcode-block" id="MultivariateBrownianMotion.simulate_live_3d">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateBrownianMotion.simulate_live_3d">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_live_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span>
                         <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">speed</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the 3D process live and save as a video file.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the simulation data</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param speed: Speed multiplier for the video</span>
<span class="sd">        :type speed: float</span>
<span class="sd">        :return: Video file name of the simulation</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_3d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">data_3d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">data_3d</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">data_3d</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">z_data</span> <span class="o">=</span> <span class="n">data_3d</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">num_steps</span> <span class="o">=</span> <span class="n">data_3d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;3D Simulation of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Z dimension&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],</span> <span class="p">[])</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_3d_properties</span><span class="p">([])</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">x_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_3d_properties</span><span class="p">(</span><span class="n">z_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">frame</span><span class="p">)</span>  <span class="c1"># Rotate view for 3D effect</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="n">fps</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">speed</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">fps</span>  <span class="c1"># interval in milliseconds</span>

        <span class="n">ani</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">)</span>
        <span class="n">video_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_3d_simulation_t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">_timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s1">.mp4&#39;</span>

        <span class="n">ani</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">video_filename</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="s1">&#39;ffmpeg&#39;</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_3d_simulation_data_t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">_timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s1">.csv&#39;</span><span class="p">,</span> <span class="n">data_3d</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">video_filename</span></div>


<div class="viewcode-block" id="MultivariateBrownianMotion.simulate_live_2dt">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateBrownianMotion.simulate_live_2dt">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_live_2dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">t_default</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">,</span>
                          <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">speed</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the 2D process live with time as the third dimension and save as a video file and interactive plot.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the simulation data</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param speed: Speed multiplier for the video (default is 1.0, higher values make the video faster)</span>
<span class="sd">        :type speed: float</span>
<span class="sd">        :return: Tuple of video file name and interactive plot file name</span>
<span class="sd">        :rtype: tuple[str, str]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_2d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">num_steps</span> <span class="o">=</span> <span class="n">data_2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">times</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;2D Simulation of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> with Time&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">azim</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],</span> <span class="p">[])</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_3d_properties</span><span class="p">([])</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="n">fps</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">speed</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">fps</span>  <span class="c1"># interval in milliseconds</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">x_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_3d_properties</span><span class="p">(</span><span class="n">times</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="n">ani</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="n">num_steps</span><span class="p">,</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">)</span>
        <span class="n">video_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_2d_time_simulation_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s1">_t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">_timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s1">.mp4&#39;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">ani</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">video_filename</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="s1">&#39;ffmpeg&#39;</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">codec</span><span class="o">=</span><span class="s1">&#39;libx264&#39;</span><span class="p">,</span> <span class="n">bitrate</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">extra_args</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;-pix_fmt&#39;</span><span class="p">,</span> <span class="s1">&#39;yuv420p&#39;</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;2D with time simulation video saved as </span><span class="si">{</span><span class="n">video_filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">CalledProcessError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error saving 2D with time simulation video: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_2d_time_simulation_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">_t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">_timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">,</span>
                       <span class="n">data_2d</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

        <span class="c1"># Create Plotly figure</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">()</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter3d</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">x_data</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y_data</span><span class="p">,</span>
            <span class="n">z</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;lines&#39;</span><span class="p">,</span>
            <span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">),</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;2D Brownian Motion&#39;</span>
        <span class="p">))</span>

        <span class="c1"># Update layout for better visibility</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span>
            <span class="n">scene</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">xaxis_title</span><span class="o">=</span><span class="s1">&#39;X dimension&#39;</span><span class="p">,</span>
                <span class="n">yaxis_title</span><span class="o">=</span><span class="s1">&#39;Y dimension&#39;</span><span class="p">,</span>
                <span class="n">zaxis_title</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span>
                <span class="n">aspectmode</span><span class="o">=</span><span class="s1">&#39;manual&#39;</span><span class="p">,</span>
                <span class="n">aspectratio</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;2D Simulation of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> with Time&#39;</span>
        <span class="p">)</span>

        <span class="c1"># Show figure (optional)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># Save as interactive HTML file</span>
        <span class="n">object_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_2d_time_object_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s1">_t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">_timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s1">.html&#39;</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">write_html</span><span class="p">(</span><span class="n">object_filename</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;2D with time object saved as </span><span class="si">{</span><span class="n">object_filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">video_filename</span><span class="p">,</span> <span class="n">object_filename</span></div>
</div>


<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">genhyperbolic</span>
<div class="viewcode-block" id="GeneralizedHyperbolicProcess">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.GeneralizedHyperbolicProcess">[docs]</a>
<span class="k">class</span> <span class="nc">GeneralizedHyperbolicProcess</span><span class="p">(</span><span class="n">NonItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GeneralizedHyperbolicProcess represents a highly flexible class of continuous-time stochastic processes that</span>
<span class="sd">    encompasses a wide range of distributions, including normal, Student&#39;s t, variance-gamma, and normal-inverse</span>
<span class="sd">    Gaussian as special or limiting cases. This process, denoted as (X_t)_{t≥0}, is characterized by five parameters:</span>
<span class="sd">    α (tail heaviness), β (asymmetry), μ (location), δ (scale), and λ (a shape parameter, often denoted as &#39;a&#39; in</span>
<span class="sd">    the implementation). The process is defined through its increments, which follow a generalized hyperbolic</span>
<span class="sd">    distribution. Key properties include: semi-heavy tails (heavier than Gaussian but lighter than power-law),</span>
<span class="sd">    ability to model skewness, and a complex autocorrelation structure. The process allows for both large jumps</span>
<span class="sd">    and continuous movements, making it highly adaptable to various phenomena. It&#39;s particularly noted for its</span>
<span class="sd">    capacity to capture both the central behavior and the extreme events in a unified framework. The</span>
<span class="sd">    GeneralizedHyperbolicProcess finds extensive applications in finance for modeling asset returns, particularly</span>
<span class="sd">    in markets exhibiting skewness and kurtosis; in risk management for more accurate tail risk assessment; in</span>
<span class="sd">    physics for describing particle movements in heterogeneous media; and in signal processing for modeling</span>
<span class="sd">    non-Gaussian noise. This implementation is initialized with parameters α, β, μ (loc), and δ (scale), with</span>
<span class="sd">    additional parameters possible through kwargs. It&#39;s categorized under both &quot;generalized&quot; and &quot;hyperbolic&quot; types,</span>
<span class="sd">    reflecting its nature as a broad, hyperbolic-based process. The class uses a custom increment function,</span>
<span class="sd">    indicated by the _external_simulator flag set to False. This allows for precise control over the generation</span>
<span class="sd">    of process increments, crucial for accurately representing the complex distribution. Researchers and</span>
<span class="sd">    practitioners should be aware of the computational challenges in parameter estimation and simulation,</span>
<span class="sd">    particularly in high-dimensional settings or with extreme parameter values. The flexibility of the generalized</span>
<span class="sd">    hyperbolic process comes with increased model complexity, requiring careful consideration in application and</span>
<span class="sd">    interpretation. Its ability to nest simpler models allows for sophisticated hypothesis testing and model</span>
<span class="sd">    selection in empirical studies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Generalized Hyperbolic Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.7</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0005</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.003</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the GeneralizedHyperbolicProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param alpha: The shape parameter (α)</span>
<span class="sd">        :type alpha: float</span>
<span class="sd">        :param beta: The skewness parameter (β)</span>
<span class="sd">        :type beta: float</span>
<span class="sd">        :param loc: The location parameter (μ)</span>
<span class="sd">        :type loc: float</span>
<span class="sd">        :param scale: The scale parameter (σ)</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :param kwargs: Additional keyword arguments for the process</span>
<span class="sd">        :raises ValueError: If the scale parameter is non-positive</span>
<span class="sd">        :raises ValueError: If the shape parameter (a) is non-positive</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;generalized&quot;</span><span class="p">,</span> <span class="s2">&quot;hyperbolic&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_simulator</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Using custom increment function</span>

        <span class="c1"># Compute &#39;a&#39; based on alpha and beta if not provided directly</span>
        <span class="k">if</span> <span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

        <span class="c1"># Validity checks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Scale parameter must be positive.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;a&#39; must be positive.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the shape parameter (α) of the process.</span>

<span class="sd">        :return: The shape parameter (α)</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">beta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the skewness parameter (β) of the process.</span>

<span class="sd">        :return: The skewness parameter (β)</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the location parameter (μ) of the process.</span>

<span class="sd">        :return: The location parameter (μ)</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the scale parameter (σ) of the process.</span>

<span class="sd">        :return: The scale parameter (σ)</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the shape parameter &#39;a&#39; of the process.</span>

<span class="sd">        :return: The shape parameter &#39;a&#39;</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span>

<div class="viewcode-block" id="GeneralizedHyperbolicProcess.custom_increment">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.GeneralizedHyperbolicProcess.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom increment function for the process.</span>

<span class="sd">        :param X: The current value of the process</span>
<span class="sd">        :type X: float</span>
<span class="sd">        :param timestep: The time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: The increment value</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="p">(</span><span class="n">timestep</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">genhyperbolic</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dX</span></div>


<div class="viewcode-block" id="GeneralizedHyperbolicProcess.differential">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.GeneralizedHyperbolicProcess.differential">[docs]</a>
    <span class="k">def</span> <span class="nf">differential</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">        Return the differential equation of the process.</span>

<span class="sd">        :return: The differential equation of the process</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;dX(t) = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="si">}</span><span class="s2">*dt + (dt)^0.5 * </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="si">}</span><span class="s2"> * GH(alpha=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="si">}</span><span class="s2">, beta=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span><span class="si">}</span><span class="s2">, loc=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="si">}</span><span class="s2">, scale=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="si">}</span><span class="s2">, a=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="si">}</span><span class="s2">)&quot;</span></div>


<div class="viewcode-block" id="GeneralizedHyperbolicProcess.express_as_elementary">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.GeneralizedHyperbolicProcess.express_as_elementary">[docs]</a>
    <span class="k">def</span> <span class="nf">express_as_elementary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Express a given Generalized Hyperbolic process as a function of an elementary Hyperbolic process.</span>

<span class="sd">        :return: The Generalized Hyperbolic process expressed in terms of elementary Hyperbolic processes</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;X(t) = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="si">}</span><span class="s2">*t + </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="si">}</span><span class="s2"> * GeneralizedHyperbolic(alpha=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="si">}</span><span class="s2">, beta=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span><span class="si">}</span><span class="s2">, a=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="si">}</span><span class="s2">).increment()&quot;</span></div>
</div>


<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">pareto</span>
<div class="viewcode-block" id="ParetoProcess">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.ParetoProcess">[docs]</a>
<span class="k">class</span> <span class="nc">ParetoProcess</span><span class="p">(</span><span class="n">NonItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ParetoProcess represents a continuous-time stochastic process based on the Pareto distribution, known for</span>
<span class="sd">    modeling phenomena with power-law tail behavior. This process, denoted as (X_t)_{t≥0}, is characterized by</span>
<span class="sd">    three parameters: shape (α), scale (σ), and location (μ). The Pareto distribution is renowned for its &quot;80-20</span>
<span class="sd">    rule&quot; or &quot;law of the vital few&quot; property, making it particularly suitable for modeling size distributions in</span>
<span class="sd">    various natural and social contexts.</span>

<span class="sd">    Key parameters:</span>

<span class="sd">    - shape (α &gt; 0): Determines the tail behavior of the distribution. Smaller values lead to heavier tails,</span>
<span class="sd">      representing more extreme events.</span>

<span class="sd">    - scale (σ &gt; 0): Sets the minimum scale of the process, effectively acting as a threshold parameter.</span>

<span class="sd">    - loc (μ): Shifts the entire distribution, allowing for flexibility in modeling.</span>

<span class="sd">    The process exhibits several important properties:</span>

<span class="sd">    1. Heavy-tailed behavior: For α &lt; 2, the process has infinite variance, capturing extreme events more</span>
<span class="sd">       effectively than processes based on normal distributions.</span>

<span class="sd">    2. Scale invariance: The relative probabilities of large events remain consistent regardless of scale.</span>

<span class="sd">    3. Power-law decay: The probability of extreme events decays as a power law, rather than exponentially.</span>

<span class="sd">    This implementation uses a custom increment function (_external_simulator = False), allowing for precise</span>
<span class="sd">    control over the generation of process increments. The class performs validity checks to ensure that the</span>
<span class="sd">    shape and scale parameters are strictly positive, which is crucial for maintaining the integrity of the</span>
<span class="sd">    Pareto distribution.</span>

<span class="sd">    Researchers and practitioners should be aware of the challenges in parameter estimation, especially for</span>
<span class="sd">    small shape values where moments may not exist. The process&#39;s heavy-tailed nature can lead to</span>
<span class="sd">    counterintuitive results in statistical analyses and requires careful interpretation. While powerful in</span>
<span class="sd">    modeling extreme phenomena, the Pareto process should be used judiciously, with consideration of its</span>
<span class="sd">    underlying assumptions and their applicability to the system being modeled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Pareto Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the ParetoProcess class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param shape: The shape parameter (α)</span>
<span class="sd">        :type shape: float</span>
<span class="sd">        :param scale: The scale parameter (x_m)</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :param loc: The location parameter (x_0)</span>
<span class="sd">        :type loc: float</span>
<span class="sd">        :raises ValueError: If the shape parameter is non-positive</span>
<span class="sd">        :raises ValueError: If the scale parameter is non-positive</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;pareto&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_simulator</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Using custom increment function</span>

        <span class="c1"># Validity checks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape parameter must be positive.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Scale parameter must be positive.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the shape parameter (α) of the process.</span>

<span class="sd">        :return: The shape parameter (α)</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the scale parameter (σ) of the process.</span>

<span class="sd">        :return: The scale parameter (σ)</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the location parameter (μ) of the process.</span>

<span class="sd">        :return: The location parameter (μ)</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span>

<div class="viewcode-block" id="ParetoProcess.custom_increment">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.ParetoProcess.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom increment function for the process.</span>

<span class="sd">        :param X: The current value of the process</span>
<span class="sd">        :type X: float</span>
<span class="sd">        :param timestep: The time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: The increment value</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">pareto</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">)</span> <span class="o">*</span> <span class="n">timestep</span>
        <span class="k">return</span> <span class="n">dX</span></div>


<div class="viewcode-block" id="ParetoProcess.differential">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.ParetoProcess.differential">[docs]</a>
    <span class="k">def</span> <span class="nf">differential</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the differential equation of the process.</span>

<span class="sd">        :return: The differential equation of the process</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;dX(t) = (dt) * Pareto(shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="si">}</span><span class="s2">, scale=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="si">}</span><span class="s2">, loc=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="si">}</span><span class="s2">)&quot;</span></div>


<div class="viewcode-block" id="ParetoProcess.express_as_elementary">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.ParetoProcess.express_as_elementary">[docs]</a>
    <span class="k">def</span> <span class="nf">express_as_elementary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Express a given Pareto process as a function of elementary processes.</span>

<span class="sd">        :return: The Pareto process expressed in terms of elementary processes</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;X(t) = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="si">}</span><span class="s2">*t + </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="si">}</span><span class="s2"> * ParetoProcess(shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="si">}</span><span class="s2">, scale=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="si">}</span><span class="s2">).increment()&quot;</span></div>
</div>


<div class="viewcode-block" id="MultivariateLevy">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateLevy">[docs]</a>
<span class="k">class</span> <span class="nc">MultivariateLevy</span><span class="p">(</span><span class="n">LevyStableProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MultivariateLevy represents a sophisticated extension of the Lévy stable process to multiple dimensions,</span>
<span class="sd">    providing a powerful tool for modeling complex, correlated heavy-tailed phenomena. This continuous-time</span>
<span class="sd">    stochastic process, denoted as (X_t)_{t≥0} where X_t is a vector in R^n, inherits the fundamental</span>
<span class="sd">    characteristics of Lévy stable distributions while incorporating cross-dimensional dependencies.</span>

<span class="sd">    Key parameters:</span>

<span class="sd">    - α (alpha): Stability parameter (0 &lt; α ≤ 2), governing tail heaviness across all dimensions.</span>

<span class="sd">    - β (beta): Skewness parameter (-1 ≤ β ≤ 1), controlling asymmetry.</span>

<span class="sd">    - scale: Global scale parameter for the process.</span>

<span class="sd">    - loc: Location vector (μ ∈ R^n), shifting the process in each dimension.</span>

<span class="sd">    - correlation_matrix: Specifies the correlation structure between dimensions.</span>

<span class="sd">    - pseudovariances: Vector of pseudovariances for each dimension, generalizing the concept of variance.</span>

<span class="sd">    Advanced features:</span>

<span class="sd">    - Tempering: Optional exponential tempering to ensure finite moments.</span>

<span class="sd">    - Truncation: &#39;Hard&#39; or &#39;soft&#39; truncation options to limit extreme values.</span>

<span class="sd">    The process is constructed using a Cholesky decomposition of the correlation matrix, scaled by</span>
<span class="sd">    pseudovariances, ensuring a valid covariance structure. This approach allows for modeling complex</span>
<span class="sd">    interdependencies while maintaining the heavy-tailed nature of Lévy stable processes in each dimension.</span>

<span class="sd">    Key properties:</span>

<span class="sd">    1. Multivariate stability: The sum of independent copies of the process follows the same distribution,</span>
<span class="sd">       up to affine transformations.</span>

<span class="sd">    2. Heavy tails and potential infinite variance in each dimension for α &lt; 2.</span>

<span class="sd">    3. Complex dependency structures captured by the correlation matrix and pseudovariances.</span>

<span class="sd">    The class implements custom simulation methods, including a specialized increment function that</span>
<span class="sd">    respects the multivariate structure. It includes extensive error checking to ensure the validity of</span>
<span class="sd">    input parameters, particularly for the correlation matrix and pseudovariances.</span>

<span class="sd">    Researchers and practitioners should be aware of the computational challenges in simulating and</span>
<span class="sd">    estimating multivariate Lévy stable processes, especially in high dimensions or with extreme</span>
<span class="sd">    parameter values. The interplay between α, the correlation structure, and pseudovariances requires</span>
<span class="sd">    careful interpretation. While offering great flexibility in modeling complex, heavy-tailed multivariate</span>
<span class="sd">    phenomena, users should exercise caution in parameter selection and model interpretation, particularly</span>
<span class="sd">    when dealing with empirical data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Multivariate Levy Stable Process&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">default_comments</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tempering</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">truncation_level</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">truncation_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;hard&#39;</span><span class="p">,</span> <span class="n">correlation_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">pseudovariances</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the MultivariateLevy class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The specific stochastic process class to use for simulation</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param alpha: The stability parameter (0 &lt; α ≤ 2)</span>
<span class="sd">        :type alpha: float</span>
<span class="sd">        :param beta: The skewness parameter (-1 ≤ β ≤ 1)</span>
<span class="sd">        :type beta: float</span>
<span class="sd">        :param scale: The scale parameter (σ &gt; 0)</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :param loc: The location parameter (μ)</span>
<span class="sd">        :type loc: np.ndarray</span>
<span class="sd">        :param default_comments: Whether to include default comments in the process description</span>
<span class="sd">        :type default_comments: bool</span>
<span class="sd">        :param tempering: The tempering parameter (0 ≤ θ ≤ 1)</span>
<span class="sd">        :type tempering: float</span>
<span class="sd">        :param truncation_level: The truncation level for the process</span>
<span class="sd">        :type truncation_level: float</span>
<span class="sd">        :param truncation_type: The type of truncation (&#39;hard&#39; or &#39;soft&#39;)</span>
<span class="sd">        :type truncation_type: str</span>
<span class="sd">        :param correlation_matrix: The correlation matrix for the multivariate process</span>
<span class="sd">        :type correlation_matrix: np.ndarray</span>
<span class="sd">        :param pseudovariances:The pseudovariances for the multivariate process</span>
<span class="sd">        :type pseudovariances: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First, initialize the base class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">default_comments</span><span class="o">=</span><span class="n">default_comments</span><span class="p">,</span>
                         <span class="n">tempering</span><span class="o">=</span><span class="n">tempering</span><span class="p">,</span> <span class="n">truncation_level</span><span class="o">=</span><span class="n">truncation_level</span><span class="p">,</span> <span class="n">truncation_type</span><span class="o">=</span><span class="n">truncation_type</span><span class="p">)</span>

        <span class="c1"># Then, initialize MultivariateLevy-specific attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_multivariate</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">correlation_matrix</span><span class="p">,</span> <span class="n">pseudovariances</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_multivariate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">correlation_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pseudovariances</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the multivariate parameters for the process.</span>

<span class="sd">        :param loc: The location vector (μ)</span>
<span class="sd">        :type loc: np.ndarray</span>
<span class="sd">        :param correlation_matrix: The correlation matrix for the process</span>
<span class="sd">        :type correlation_matrix: np.ndarray</span>
<span class="sd">        :param pseudovariances: The pseudovariances for the process</span>
<span class="sd">        :type pseudovariances: np.ndarray</span>
<span class="sd">        :raises ValueError: If the correlation matrix is not symmetric</span>
<span class="sd">        :raises ValueError: If the correlation matrix is not positive definite</span>
<span class="sd">        :raises ValueError: If the correlation matrix is not symmetric</span>
<span class="sd">        :raises ValueError: If the correlation matrix shape do not match the dimensions of the process</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">correlation_matrix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pseudovariances</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Correlation matrix and pseudovariances must be provided.&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure pseudovariances is a 1D array</span>
        <span class="n">pseudovariances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">pseudovariances</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pseudovariances</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Debug: pseudovariances shape: </span><span class="si">{</span><span class="n">pseudovariances</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Debug: self._dims: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Handle loc as a numpy array</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">loc</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">,):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;loc must be a numpy array of shape (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="si">}</span><span class="s2">,)&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Debug: correlation_matrix shape: </span><span class="si">{</span><span class="n">correlation_matrix</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">correlation_matrix</span><span class="p">,</span> <span class="n">correlation_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Correlation matrix must be symmetric.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">correlation_matrix</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Correlation matrix must be positive definite.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_correlation_matrix</span> <span class="o">=</span> <span class="n">correlation_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pseudovariances</span> <span class="o">=</span> <span class="n">pseudovariances</span>

        <span class="c1"># Compute the Cholesky decomposition of the correlation matrix</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_correlation_matrix</span><span class="p">)</span>

        <span class="c1"># Create the matrix A by scaling L with the standard deviations (square roots of pseudovariances)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pseudovariances</span><span class="p">)),</span> <span class="n">L</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Debug: self._A shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Debug: Final self._dims: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected self._A to be a </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="si">}</span><span class="s2">x</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="si">}</span><span class="s2"> matrix, but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">correlation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the correlation matrix of the process.</span>

<span class="sd">        :return: The correlation matrix</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correlation_matrix</span>

    <span class="nd">@correlation_matrix</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">correlation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">correlation_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the correlation matrix of the process.</span>

<span class="sd">        :param correlation_matrix: A new correlation matrix</span>
<span class="sd">        :type correlation_matrix: np.ndarray</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="n">correlation_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_correlation_matrix</span> <span class="o">=</span> <span class="n">correlation_matrix</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pseudovariances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the pseudovariances of the process.</span>

<span class="sd">        :return: The pseudovariances</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pseudovariances</span>

    <span class="nd">@pseudovariances</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pseudovariances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pseudovariances</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the pseudovariances of the process.</span>

<span class="sd">        :param pseudovariances: A new set of pseudovariances</span>
<span class="sd">        :type pseudovariances: np.ndarray</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pseudovariances</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pseudovariances</span> <span class="o">=</span> <span class="n">pseudovariances</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the location vector of the process.</span>

<span class="sd">        :return: The location vector</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span>

    <span class="nd">@loc</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the location vector of the process.</span>

<span class="sd">        :param loc: A new location vector</span>
<span class="sd">        :type loc: np.ndarray</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span> <span class="o">=</span> <span class="n">loc</span>

<div class="viewcode-block" id="MultivariateLevy.custom_increment">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateLevy.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a custom increment for the multivariate process.</span>

<span class="sd">        :param X: The current value of the process</span>
<span class="sd">        :type X: np.ndarray</span>
<span class="sd">        :param timestep: The time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: The multivariate increment</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate independent increments for each component</span>
        <span class="n">dZ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">levy_stable</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">)])</span>

        <span class="c1"># Scale the increments by timestep</span>
        <span class="n">dZ</span> <span class="o">*=</span> <span class="n">timestep</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">)</span>

        <span class="c1"># Reshape dZ to a column vector</span>
        <span class="n">dZ</span> <span class="o">=</span> <span class="n">dZ</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Apply matrix A to create correlated increments</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">dZ</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># Add loc * timestep to the increment</span>
        <span class="n">dX</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span> <span class="o">*</span> <span class="n">timestep</span>

        <span class="c1"># Apply truncation and/or tempering if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tempered</span><span class="p">:</span>
            <span class="n">dX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">tempered_stable_rvs</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dX</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncated</span><span class="p">:</span>
            <span class="n">dX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">dX</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">dX</span></div>


<div class="viewcode-block" id="MultivariateLevy.simulate">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateLevy.simulate">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">num_instances</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the multivariate Lévy process.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param num_instances: Number of simulation instances to generate</span>
<span class="sd">        :type num_instances: int</span>
<span class="sd">        :param save: Whether to save the simulation data</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to plot the simulation results</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return: The simulated data array of shape (dims+1, num_steps)</span>
<span class="sd">        :rtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_steps</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Ensure at least 2 steps</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_instances</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_instances</span><span class="p">):</span>
            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">instance</span><span class="p">,</span> <span class="p">:,</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
                <span class="n">dX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_increment</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">dX</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_to_file</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;levy_process_simulation_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">_t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">_timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">_num_instances:</span><span class="si">{</span><span class="n">num_instances</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">,</span>
                              <span class="n">save</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">save</span><span class="p">,</span> <span class="n">plot</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="MultivariateLevy.plot">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateLevy.plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the simulation results.</span>

<span class="sd">        :param times: The time points for the simulation</span>
<span class="sd">        :type times: np.ndarray</span>
<span class="sd">        :param data: The simulated data array</span>
<span class="sd">        :type data: np.ndarray</span>
<span class="sd">        :param save: Whether to save the plot</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to display the plot</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :raises ValueError: If there are insufficient time points to plot the simulation</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Insufficient time points to plot the simulation. Ensure there are at least two time steps.&quot;</span><span class="p">)</span>

            <span class="n">t</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">timestep</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">num_instances</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_instances</span><span class="p">):</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="p">:],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Dim </span><span class="si">{</span><span class="n">d</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">, Inst </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Simulation of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Value&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_output_dir</span><span class="p">,</span>
                                         <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s1">_t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">_timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s1">_num_instances:</span><span class="si">{</span><span class="n">num_instances</span><span class="si">}</span><span class="s1">_process_simulation.png&#39;</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="MultivariateLevy.plot_2d">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateLevy.plot_2d">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_2d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the 2D simulation results.</span>

<span class="sd">        :param data_2d: 2D simulation data</span>
<span class="sd">        :type data_2d: np.ndarray</span>
<span class="sd">        :param save: Whether to save the plot</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to display the plot</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return None</span>
<span class="sd">        :rtype None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">plot</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;2D Process Simulation (t=</span><span class="si">{</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, timestep=</span><span class="si">{</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;X dimension&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Y dimension&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;2d_simulation_plot_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="MultivariateLevy.plot_2dt">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateLevy.plot_2dt">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_2dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_2d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the 2D simulation results in a 3D graph with time as the third dimension.</span>

<span class="sd">        :param data_2d: 2D simulation data</span>
<span class="sd">        :type data_2d: np.ndarray</span>
<span class="sd">        :param save: Whether to save the plot</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to display the plot</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return None</span>
<span class="sd">        :rtype None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">plot</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;3D Visualization of 2D Process Simulation</span><span class="se">\n</span><span class="s2">(t=</span><span class="si">{</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, timestep=</span><span class="si">{</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;3d_simulation_plot_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="MultivariateLevy.plot_3d">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateLevy.plot_3d">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_3d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the 3D simulation results.</span>

<span class="sd">        :param data_3d: 3D simulation data</span>
<span class="sd">        :type data_3d: np.ndarray</span>
<span class="sd">        :param save: Whether to save the plot</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to display the plot</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return None</span>
<span class="sd">        :rtype None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">plot</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">data_3d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">data_3d</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">data_3d</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">z_data</span> <span class="o">=</span> <span class="n">data_3d</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">z_data</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Z dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;3D Process Simulation</span><span class="se">\n</span><span class="s2">(t=</span><span class="si">{</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, timestep=</span><span class="si">{</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;3d_simulation_plot_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="MultivariateLevy.simulate_live">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateLevy.simulate_live">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_live</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the process live and save as a video file.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: The filename of the saved video</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">num_instances</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Dimension </span><span class="si">{</span><span class="n">d</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">)]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Simulation of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Value&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],</span> <span class="p">[])</span>
            <span class="k">return</span> <span class="n">lines</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
                <span class="n">lines</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">times</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="p">:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">lines</span>

        <span class="n">ani</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">video_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_simulation.mp4&#39;</span>
        <span class="n">ani</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">video_filename</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="s1">&#39;ffmpeg&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">video_filename</span></div>


<div class="viewcode-block" id="MultivariateLevy.simulate_2d">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateLevy.simulate_2d">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the 2D Multivariate Lévy Process.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the simulation data</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to plot the simulation results</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :raises ValueError: If the process is not 2D</span>
<span class="sd">        :return: The simulated 2D data array of shape (3, num_steps)</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This method is only for 2D Multivariate Lévy Process&quot;</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">data_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>  <span class="c1"># 3 rows: time, x, y</span>
        <span class="n">data_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">times</span>
        <span class="n">data_2d</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>  <span class="c1"># Use the first (and only) instance</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_to_file</span><span class="p">(</span><span class="n">data_2d</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;levy_process_2d_simulation_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">_t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">_timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">,</span>
                              <span class="n">save</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_2d</span><span class="p">(</span><span class="n">data_2d</span><span class="p">,</span> <span class="n">save</span><span class="p">,</span> <span class="n">plot</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_2d</span></div>


<div class="viewcode-block" id="MultivariateLevy.simulate_live_2d">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateLevy.simulate_live_2d">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_live_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">speed</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the 2D process live and save as a video file.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the video</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param speed: Speed of the simulation</span>
<span class="sd">        :type speed: float</span>
<span class="sd">        :return: The filename of the saved video</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_2d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;2D Simulation of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],</span> <span class="p">[])</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">x_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="n">fps</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">speed</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">fps</span>  <span class="c1"># interval in milliseconds</span>

        <span class="n">ani</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">)</span>
        <span class="n">video_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_2d_simulation.mp4&#39;</span>
        <span class="n">ani</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">video_filename</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="s1">&#39;ffmpeg&#39;</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">video_filename</span></div>


<div class="viewcode-block" id="MultivariateLevy.simulate_3d">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateLevy.simulate_3d">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the 3D Multivariate Lévy Process.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the simulation data</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param plot: Whether to plot the simulation results</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :raises ValueError: If the process is not 3D</span>
<span class="sd">        :return: The simulated 3D data array of shape (4, num_steps)</span>
<span class="sd">        :rtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This method is only for 3D Multivariate Lévy Process&quot;</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">data_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>  <span class="c1"># 4 rows: time, x, y, z</span>
        <span class="n">data_3d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">times</span>
        <span class="n">data_3d</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>  <span class="c1"># Use the first (and only) instance</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_to_file</span><span class="p">(</span><span class="n">data_3d</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;levy_process_3d_simulation_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">_t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">_timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">,</span>
                              <span class="n">save</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_3d</span><span class="p">(</span><span class="n">data_3d</span><span class="p">,</span> <span class="n">save</span><span class="p">,</span> <span class="n">plot</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_3d</span></div>


<div class="viewcode-block" id="MultivariateLevy.simulate_live_3d">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateLevy.simulate_live_3d">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_live_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">speed</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the 3D process live and save as a video file.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the video</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param speed: Speed of the simulation</span>
<span class="sd">        :type speed: float</span>
<span class="sd">        :return: The filename of the saved video</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_3d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">data_3d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">data_3d</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">data_3d</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">z_data</span> <span class="o">=</span> <span class="n">data_3d</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;3D Simulation of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Z dimension&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],</span> <span class="p">[])</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_3d_properties</span><span class="p">([])</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">x_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_3d_properties</span><span class="p">(</span><span class="n">z_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">frame</span><span class="p">)</span>  <span class="c1"># Rotate view for 3D effect</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="n">fps</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">speed</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">fps</span>  <span class="c1"># interval in milliseconds</span>

        <span class="n">ani</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">)</span>
        <span class="n">video_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_3d_simulation.mp4&#39;</span>
        <span class="n">ani</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">video_filename</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="s1">&#39;ffmpeg&#39;</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">video_filename</span></div>


<div class="viewcode-block" id="MultivariateLevy.simulate_live_2dt">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.basic.MultivariateLevy.simulate_live_2dt">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_live_2dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">speed</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the 2D process live with time and save as a video file.</span>

<span class="sd">        :param t: Total time for the simulation</span>
<span class="sd">        :type t: float</span>
<span class="sd">        :param timestep: Time step for the simulation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :param save: Whether to save the video</span>
<span class="sd">        :type save: bool</span>
<span class="sd">        :param speed: Speed of the simulation</span>
<span class="sd">        :type speed: float</span>
<span class="sd">        :return: The filenames of the saved video and interactive object</span>
<span class="sd">        :rtype: tuple[str, str]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_2d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">data_2d</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_data</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">times</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;2D Simulation of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> with Time&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y dimension&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">azim</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],</span> <span class="p">[])</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_3d_properties</span><span class="p">([])</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="n">fps</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">speed</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">fps</span>  <span class="c1"># interval in milliseconds</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">x_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_data</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_3d_properties</span><span class="p">(</span><span class="n">times</span><span class="p">[:</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">,</span>

        <span class="n">ani</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">)</span>
        <span class="n">video_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_2d_time_simulation.mp4&#39;</span>
        <span class="n">ani</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">video_filename</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="s1">&#39;ffmpeg&#39;</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">codec</span><span class="o">=</span><span class="s1">&#39;libx264&#39;</span><span class="p">,</span> <span class="n">bitrate</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">extra_args</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;-pix_fmt&#39;</span><span class="p">,</span> <span class="s1">&#39;yuv420p&#39;</span><span class="p">])</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_2d_time_simulation_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="si">}</span><span class="s2">_t:</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">_timestep:</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">,</span> <span class="n">data_2d</span><span class="p">,</span>
                       <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

        <span class="c1"># Create Plotly figure</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">()</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter3d</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">x_data</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y_data</span><span class="p">,</span>
            <span class="n">z</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;lines&#39;</span><span class="p">,</span>
            <span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">),</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;2D Lévy Process&#39;</span>
        <span class="p">))</span>

        <span class="c1"># Update layout for better visibility</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span>
            <span class="n">scene</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">xaxis_title</span><span class="o">=</span><span class="s1">&#39;X dimension&#39;</span><span class="p">,</span>
                <span class="n">yaxis_title</span><span class="o">=</span><span class="s1">&#39;Y dimension&#39;</span><span class="p">,</span>
                <span class="n">zaxis_title</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span>
                <span class="n">aspectmode</span><span class="o">=</span><span class="s1">&#39;manual&#39;</span><span class="p">,</span>
                <span class="n">aspectratio</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;2D Simulation of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> with Time&#39;</span>
        <span class="p">)</span>

        <span class="c1"># Show figure (optional)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># Save as interactive HTML file</span>
        <span class="n">object_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_2d_time_object.html&#39;</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">write_html</span><span class="p">(</span><span class="n">object_filename</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">video_filename</span><span class="p">,</span> <span class="n">object_filename</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Ergodicity Library</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Ihor Kendiukhov.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>