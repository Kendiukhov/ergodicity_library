<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ergodicity.process.with_memory &#8212; Ergodicity Library 0.3.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../_static/documentation_options.js?v=e259d695"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ergodicity.process.with_memory</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">with_memory Submodule</span>

<span class="sd">The `With Memory` Submodule focuses on stochastic processes that retain and utilize historical information to influence their future behavior. These processes deviate from classical Markovian models, which rely solely on the current state, by incorporating **memory mechanisms** that adjust their dynamics based on past states or increments. This submodule provides a framework for modeling **non-Markovian processes** with varying types of memory effects.</span>

<span class="sd">Key Features:</span>

<span class="sd">1. **Non-Markovian Dynamics**:</span>

<span class="sd">    - Unlike Markovian processes where future behavior is independent of the past (given the present), processes in this submodule leverage historical data to influence their future states. This makes them suitable for modeling phenomena with long-range dependence or adaptive behavior.</span>

<span class="sd">2. **Adaptive Drift and Volatility**:</span>

<span class="sd">    - The processes typically feature **adaptive drift** or volatility, which changes based on the process&#39;s past trajectory. This allows for more complex and realistic modeling of systems where trends evolve over time, such as financial markets, physical systems, or biological processes.</span>

<span class="sd">3. **Memory Update Mechanism**:</span>

<span class="sd">    - A core aspect of these processes is the **memory update mechanism**, which adjusts key parameters like drift or volatility based on historical increments or states. This can lead to a variety of interesting behaviors, such as mean reversion, long-term memory, or even self-learning dynamics.</span>

<span class="sd">4. **Wide Applications**:</span>

<span class="sd">    - Processes with memory are particularly useful in areas where past behavior significantly impacts the future, including:</span>

<span class="sd">      - **Financial markets**: Modeling asset prices with trends influenced by historical performance.</span>

<span class="sd">      - **Control systems**: Adapting control mechanisms based on past errors or deviations.</span>

<span class="sd">      - **Environmental science**: Modeling systems with long-term dependencies, such as climate data.</span>

<span class="sd">      - **Machine learning**: Adaptive stochastic optimization methods that incorporate past performance into their future decisions.</span>

<span class="sd">## Illustrative Example: Brownian Motion With Mean Memory</span>

<span class="sd">The **BrownianMotionWithMeanMemory** class provides a concrete example of a process with memory, where the drift term dynamically adjusts based on the process&#39;s history. This process evolves according to the following dynamics:</span>

<span class="sd">\[ dX_t = \mu_t dt + \left( \frac{\sigma}{\mu_t} \right) dW_t \]</span>

<span class="sd">Where:</span>

<span class="sd">- \( \mu_t \) is the **time-varying drift** that updates based on the process&#39;s history.</span>

<span class="sd">- \( \sigma \) is a **scale parameter** controlling the magnitude of random fluctuations.</span>

<span class="sd">- \( W_t \) is a standard **Brownian motion**.</span>

<span class="sd">Key Characteristics:</span>

<span class="sd">1. **Adaptive Drift**: The drift term \( \mu_t \) is adjusted based on past increments, allowing the process to learn from its own behavior.</span>

<span class="sd">2. **Memory Mechanism**: A **memory update function** dynamically modifies the drift using an exponential moving average of the past increments.</span>

<span class="sd">3. **Scale Modulation**: The volatility is inversely proportional to the drift, introducing a unique coupling between the random and deterministic parts of the process.</span>

<span class="sd">Code Example:</span>

<span class="sd">class BrownianMotionWithMeanMemory(NonItoProcess):</span>

<span class="sd">    def __init__(self, name: str = &quot;Brownian Motion With Mean Memory&quot;, process_class: Type[Any] = None,</span>
<span class="sd">                 drift: float = drift_term_default, scale: float = stochastic_term_default):</span>

<span class="sd">        super().__init__(name, process_class)</span>

<span class="sd">        self._memory = drift</span>

<span class="sd">        self._drift = drift</span>

<span class="sd">        self._scale = scale if scale &gt; 0 else ValueError(&quot;The scale parameter must be positive.&quot;)</span>

<span class="sd">        self._dx = 0</span>

<span class="sd">    def custom_increment(self, X: float, timestep: float = timestep_default) -&gt; Any:</span>

<span class="sd">        dX = timestep * self._drift + (timestep ** 0.5) * self._scale * np.random.normal(0, 1) / self._memory</span>

<span class="sd">        self._dx = dX</span>

<span class="sd">        return dX</span>

<span class="sd">    def memory_update(self, step):</span>

<span class="sd">        step += 1</span>

<span class="sd">        delta1, delta2 = 1 / step, (step - 1) / step</span>

<span class="sd">        new_memory = self._memory * delta2 + delta1 * self._dx</span>

<span class="sd">        return new_memory</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">ergodicity.process.basic</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">ergodicity.process.definitions</span> <span class="kn">import</span> <span class="o">*</span>

<div class="viewcode-block" id="BrownianMotionWithMeanMemory">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.with_memory.BrownianMotionWithMeanMemory">[docs]</a>
<span class="k">class</span> <span class="nc">BrownianMotionWithMeanMemory</span><span class="p">(</span><span class="n">NonItoProcess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    BrownianMotionWithMeanMemory is an illustrative example of a process with memory which represents an extension of standard Brownian motion,</span>
<span class="sd">    incorporating a dynamic, self-adjusting drift based on the process&#39;s history. This continuous-time</span>
<span class="sd">    stochastic process, denoted as (X_t)_{t≥0}, evolves according to the following dynamics:</span>

<span class="sd">    dX_t = μ_t dt + (σ / μ_t) dW_t</span>

<span class="sd">    where:</span>

<span class="sd">    - μ_t is the time-varying drift, updated based on the process&#39;s history</span>

<span class="sd">    - σ is the scale parameter, controlling the magnitude of random fluctuations</span>

<span class="sd">    - W_t is a standard Brownian motion</span>

<span class="sd">    Key features:</span>

<span class="sd">    1. Adaptive Drift: The drift term μ_t is dynamically updated, reflecting the process&#39;s mean behavior</span>
<span class="sd">       over time. This adaptation allows the process to &quot;learn&quot; from its past trajectory.</span>

<span class="sd">    2. Memory Mechanism: The process maintains a memory of its increments, used to adjust the drift.</span>
<span class="sd">       This feature introduces a form of long-range dependence not present in standard Brownian motion.</span>

<span class="sd">    3. Scale Modulation: The stochastic term is modulated by the inverse of the current drift, creating</span>
<span class="sd">       a unique interplay between the deterministic and random components.</span>

<span class="sd">    The process is initialized with a name, optional process class, initial drift, and scale parameters.</span>
<span class="sd">    It inherits the core functionality of BrownianMotion while implementing custom increment generation</span>
<span class="sd">    and memory update mechanisms.</span>

<span class="sd">    Key methods:</span>

<span class="sd">    1. custom_increment: Generates the next increment of the process, incorporating the memory-adjusted</span>
<span class="sd">       drift and scale modulation.</span>

<span class="sd">    2. memory_update: Updates the memory (drift) based on the most recent increment, using an exponential</span>
<span class="sd">       moving average approach.</span>

<span class="sd">    Researchers and practitioners should note several important considerations:</span>

<span class="sd">    1. Non-Markovian nature: The dependence on history makes this process non-Markovian, requiring</span>
<span class="sd">       specialized analysis techniques.</span>

<span class="sd">    2. Parameter sensitivity: The interplay between drift updates and scale modulation can lead to</span>
<span class="sd">       complex dynamics, necessitating careful parameter calibration.</span>

<span class="sd">    3. Computational considerations: The continuous updating of the drift parameter may increase</span>
<span class="sd">       computational overhead in simulations.</span>

<span class="sd">    4. Theoretical implications: The process&#39;s unique structure may require the development of new</span>
<span class="sd">       mathematical tools for rigorous analysis.</span>

<span class="sd">    While BrownianMotionWithMeanMemory offers a novel approach to modeling adaptive stochastic processes,</span>
<span class="sd">    its use should be carefully considered in the context of specific applications. The memory mechanism</span>
<span class="sd">    introduces a form of &quot;learning&quot; into the process, potentially capturing more complex behaviors than</span>
<span class="sd">    standard Brownian motion, but also introducing additional complexity in analysis and interpretation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Brownian Motion With Mean Memory&quot;</span><span class="p">,</span> <span class="n">process_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">drift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">drift_term_default</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">stochastic_term_default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Brownian Motion With Mean Memory class.</span>

<span class="sd">        :param name: The name of the process</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param process_class: The class of the process</span>
<span class="sd">        :type process_class: Type[Any]</span>
<span class="sd">        :param drift: The initial drift term</span>
<span class="sd">        :type drift: float</span>
<span class="sd">        :param scale: The scale parameter for the stochastic term</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :raises ValueError: If the scale parameter is non-positive</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Call the parent class constructor to initialize inherited attributes</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">process_class</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memory</span> <span class="o">=</span> <span class="n">drift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span> <span class="o">=</span> <span class="n">drift</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The scale parameter must be positive.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dx</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="BrownianMotionWithMeanMemory.custom_increment">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.with_memory.BrownianMotionWithMeanMemory.custom_increment">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">timestep</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">timestep_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the next increment of the process, incorporating memory-adjusted drift and scale modulation.</span>

<span class="sd">        :param X: The current value of the process</span>
<span class="sd">        :type X: float</span>
<span class="sd">        :param timestep: The time step for the increment generation</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :return: The next increment of the process</span>
<span class="sd">        :rtype: Any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">timestep</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drift</span> <span class="o">+</span> <span class="p">(</span><span class="n">timestep</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_memory</span><span class="p">)</span>
        <span class="c1"># print(f&#39;memory: {self._memory}&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dx</span> <span class="o">=</span> <span class="n">dX</span>
        <span class="k">return</span> <span class="n">dX</span></div>


<div class="viewcode-block" id="BrownianMotionWithMeanMemory.memory_update">
<a class="viewcode-back" href="../../../ergodicity.process.html#ergodicity.process.with_memory.BrownianMotionWithMeanMemory.memory_update">[docs]</a>
    <span class="k">def</span> <span class="nf">memory_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the memory based on the most recent increment.</span>

<span class="sd">        :param step: The current step number</span>
<span class="sd">        :type step: int</span>
<span class="sd">        :return: The updated memory value</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">delta1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">step</span>
        <span class="n">delta2</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span>
        <span class="n">new_memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory</span> <span class="o">*</span> <span class="n">delta2</span> <span class="o">+</span> <span class="n">delta1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx</span>
        <span class="k">return</span> <span class="n">new_memory</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Ergodicity Library</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Ihor Kendiukhov.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>