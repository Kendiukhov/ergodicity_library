<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ergodicity.agents.evolutionary_nn &#8212; Ergodicity Library 0.3.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../_static/documentation_options.js?v=e259d695"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ergodicity.agents.evolutionary_nn</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">evolutionary_nn Submodule Overview</span>

<span class="sd">The **`evolutionary_nn`** submodule combines neural networks with evolutionary strategies to solve problems involving stochastic processes, ergodicity, and time-optimal behaviour. This submodule allows users to create neural network-based agents that evolve over time, optimize their behavior, and select processes to maximize their wealth or other objectives. The agents can be trained using evolutionary algorithms, with or without reinforcement learning techniques.</span>

<span class="sd">Key Features:</span>

<span class="sd">1. **Neural Network Creation**:</span>

<span class="sd">   - Easily create customizable feedforward neural networks with various configurations.</span>

<span class="sd">   - Features include batch normalization, dropout, and several activation functions (ReLU, Leaky ReLU, Tanh, etc.).</span>

<span class="sd">   - Supports multiple weight initialization methods (Xavier, He, etc.) and optimizers (Adam, SGD, RMSprop).</span>

<span class="sd">2. **Agent-Based Evolution**:</span>

<span class="sd">   - The `NeuralNetworkAgent` class represents agents with a neural network-based decision-making process.</span>

<span class="sd">   - Agents accumulate wealth based on their decisions, and their performance (fitness) is measured by their accumulated wealth.</span>

<span class="sd">   - Agents can mutate, reproduce, and be cloned, allowing for evolutionary strategies.</span>

<span class="sd">3. **Evolutionary Neural Network Training**:</span>

<span class="sd">   - The `EvolutionaryNeuralNetworkTrainer` class enables training a population of agents using evolutionary algorithms.</span>

<span class="sd">   - Agents are evaluated based on their wealth, and top-performing agents are selected to produce offspring for the next generation.</span>

<span class="sd">   - The training process supports wealth sharing and mutation of agents to explore new strategies.</span>

<span class="sd">4. **Reinforcement Learning with Evolution**:</span>

<span class="sd">   - The `ReinforcementEvolutionaryTrainer` class combines evolutionary strategies with reinforcement learning.</span>

<span class="sd">   - Agents are trained to select processes that maximize their wealth using reinforcement learning principles.</span>

<span class="sd">   - Crossover and mutation are applied to create new agents based on elite performers.</span>

<span class="sd">5. **Process Encoding**:</span>

<span class="sd">   - The `ProcessEncoder` class encodes stochastic processes (e.g., Brownian motion, Geometric Brownian motion) into a numeric format for input into neural networks.</span>

<span class="sd">   - This allows agents to process different types of stochastic processes and make decisions based on encoded data.</span>

<span class="sd">6. **Visualization**:</span>

<span class="sd">   - Visualize the performance of agents, including wealth evolution over time, using Matplotlib and animations.</span>

<span class="sd">   - Generate visualizations of neural network evolution and save the parameters of the best-performing agents to files.</span>

<span class="sd">Example Usage:</span>

<span class="sd">### Creating and Training Neural Network Agents:</span>

<span class="sd">from ergodicity.process.multiplicative import GeometricBrownianMotion, BrownianMotion</span>

<span class="sd">from ergodicity.evolutionary_nn import NeuralNetwork, NeuralNetworkAgent, EvolutionaryNeuralNetworkTrainer</span>

<span class="sd"># Define stochastic processes</span>

<span class="sd">process_types = [GeometricBrownianMotion, BrownianMotion]</span>

<span class="sd">processes = generate_processes(100, process_types, param_ranges)</span>

<span class="sd"># Initialize the ProcessEncoder</span>

<span class="sd">encoder = ProcessEncoder()</span>

<span class="sd"># Create a neural network for an agent</span>

<span class="sd">net = NeuralNetwork(input_size=11, hidden_sizes=[20, 10], output_size=1)</span>

<span class="sd"># Create an agent with the neural network</span>

<span class="sd">agent = NeuralNetworkAgent(net)</span>

<span class="sd"># Train a population of agents using evolutionary strategies</span>

<span class="sd">trainer = EvolutionaryNeuralNetworkTrainer(</span>
<span class="sd">    population_size=10,</span>
<span class="sd">    input_size=11,</span>
<span class="sd">    hidden_sizes=[20, 10],</span>
<span class="sd">    output_size=1,</span>
<span class="sd">    processes=processes,</span>
<span class="sd">    process_encoder=encoder,</span>
<span class="sd">    process_times=[1.0, 5.0, 10.0],</span>
<span class="sd">)</span>

<span class="sd">population, history = trainer.train(n_steps=100, save_interval=10)</span>

<span class="sd"># Get the best agent</span>

<span class="sd">best_agent = max(population, key=lambda agent: agent.accumulated_wealth)</span>

<span class="sd">print(f&quot;Best agent accumulated wealth: {best_agent.accumulated_wealth}&quot;)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Type</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.animation</span> <span class="k">as</span> <span class="nn">animation</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">ergodicity.tools.helper</span> <span class="kn">import</span> <span class="n">ProcessEncoder</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.optim</span> <span class="k">as</span> <span class="nn">optim</span>

<span class="c1"># class ProcessEncoder:</span>
<span class="c1">#     def __init__(self):</span>
<span class="c1">#         self.process_types = {&#39;BrownianMotion&#39;: 1, &#39;GeometricBrownianMotion&#39;: 2}</span>
<span class="c1">#         self.reverse_mapping = {}</span>
<span class="c1">#         self.next_id = 3</span>
<span class="c1">#</span>
<span class="c1">#     def encode(self, process_type: str) -&gt; int:</span>
<span class="c1">#         if process_type not in self.process_types:</span>
<span class="c1">#             self.process_types[process_type] = self.next_id</span>
<span class="c1">#             self.reverse_mapping[self.next_id] = process_type</span>
<span class="c1">#             self.next_id += 1</span>
<span class="c1">#         return self.process_types[process_type]</span>
<span class="c1">#</span>
<span class="c1">#     def decode(self, process_id: int) -&gt; str:</span>
<span class="c1">#         return self.reverse_mapping.get(process_id, &quot;Unknown&quot;)</span>
<span class="c1">#</span>
<span class="c1">#     def get_encoding(self) -&gt; Dict[str, int]:</span>
<span class="c1">#         return self.process_types</span>
<span class="c1">#</span>
<span class="c1">#     def get_decoding(self) -&gt; Dict[int, str]:</span>
<span class="c1">#         return self.reverse_mapping</span>
<span class="c1">#</span>
<span class="c1">#     def encode_process(self, process: object) -&gt; List[float]:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Encode a process instance into a list of floats.</span>
<span class="c1">#</span>
<span class="c1">#         :param process: A process instance</span>
<span class="c1">#         :return: A list of floats representing the encoded process</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         process_type = type(process).__name__</span>
<span class="c1">#         encoded = [float(self.encode(process_type))]</span>
<span class="c1">#</span>
<span class="c1">#         # Use the get_params method to retrieve process parameters</span>
<span class="c1">#         params = process.get_params()</span>
<span class="c1">#         print(f&quot;Process parameters from the ProcessEncoder: {params}&quot;)</span>
<span class="c1">#         for param_value in params.values():</span>
<span class="c1">#             try:</span>
<span class="c1">#                 encoded.append(float(param_value))</span>
<span class="c1">#             except (ValueError, TypeError):</span>
<span class="c1">#                 print(f&quot;Warning: Skipping non-numeric parameter with value {param_value}&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         return encoded</span>
<span class="c1">#</span>
<span class="c1">#     def pad_encoded_process(self, encoded_process: List[float], max_params: int = 10) -&gt; List[float]:</span>
<span class="c1">#         padded = encoded_process[:1]  # Keep the process type</span>
<span class="c1">#         padded.extend(encoded_process[1:max_params + 1])  # Take up to max_params</span>
<span class="c1">#         padded.extend([0.0] * (max_params - len(encoded_process[1:])))  # Pad with zeros if needed</span>
<span class="c1">#         return padded</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#     def encode_process_with_time(self, process: Union[Dict, object], time: float) -&gt; List[float]:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Encode a process with its time value, maintaining the original total length.</span>
<span class="c1">#</span>
<span class="c1">#         :param process: The process to encode (either a dictionary or an object)</span>
<span class="c1">#         :param time: The time value to include in the encoding</span>
<span class="c1">#         :return: A list of floats representing the encoded process with time</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         encoded_process = self.pad_encoded_process(self.encode_process(process))</span>
<span class="c1">#         return [encoded_process[0]] + [time] + encoded_process[1:-1]</span>


<div class="viewcode-block" id="DynamicBatchNorm1d">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.DynamicBatchNorm1d">[docs]</a>
<span class="k">class</span> <span class="nc">DynamicBatchNorm1d</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DynamicBatchNorm1d Class</span>

<span class="sd">    This class implements a dynamic version of 1D Batch Normalization, designed to handle both</span>
<span class="sd">    batch and single-sample inputs. It extends PyTorch&#39;s nn.Module.</span>

<span class="sd">    Attributes:</span>

<span class="sd">        bn (nn.BatchNorm1d): Standard PyTorch 1D Batch Normalization layer.</span>

<span class="sd">        running_mean (nn.Parameter): Running mean of the features, not updated during training.</span>

<span class="sd">        running_var (nn.Parameter): Running variance of the features, not updated during training.</span>

<span class="sd">    The DynamicBatchNorm1d class addresses a common issue in batch normalization where</span>
<span class="sd">    single-sample inputs (batch size of 1) can cause problems due to the lack of batch statistics.</span>
<span class="sd">    This implementation provides a solution by using running statistics for single samples,</span>
<span class="sd">    ensuring stable behavior regardless of batch size.</span>

<span class="sd">    Key Features:</span>

<span class="sd">    1. Seamless handling of both batch and single-sample inputs.</span>

<span class="sd">    2. Uses standard BatchNorm1d for batches to leverage its optimizations.</span>

<span class="sd">    3. Fallback to running statistics for single samples to avoid statistical instability.</span>

<span class="sd">    Usage:</span>

<span class="sd">        layer = DynamicBatchNorm1d(num_features=64)</span>

<span class="sd">        output = layer(input_tensor)</span>

<span class="sd">    This class is particularly useful in scenarios where the model might receive inputs of</span>
<span class="sd">    varying batch sizes, including single samples, such as in online learning or</span>
<span class="sd">    when processing sequential data of varying lengths.</span>

<span class="sd">    Note: The running mean and variance are not updated during training in this implementation.</span>
<span class="sd">    For applications requiring adaptive statistics, additional logic for updating these values</span>
<span class="sd">    may be necessary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_features</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization of a custom Batch Normalization layer that allows for batch size of 1.</span>

<span class="sd">        :param num_features: Number of features in the input tensor</span>
<span class="sd">        :type num_features: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DynamicBatchNorm1d</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm1d</span><span class="p">(</span><span class="n">num_features</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_mean</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_features</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_var</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_features</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="DynamicBatchNorm1d.forward">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.DynamicBatchNorm1d.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the dynamic Batch Normalization layer.</span>

<span class="sd">        :param x: Input tensor of shape (batch_size, num_features)</span>
<span class="sd">        :type x: torch.Tensor</span>
<span class="sd">        :return: Normalized tensor</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">running_var</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="NeuralNetwork">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetwork">[docs]</a>
<span class="k">class</span> <span class="nc">NeuralNetwork</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NeuralNetwork Class</span>

<span class="sd">    This class implements a flexible and customizable neural network using PyTorch. It provides a</span>
<span class="sd">    wide range of options for network architecture, activation functions, regularization, and</span>
<span class="sd">    optimization.</span>

<span class="sd">    Attributes:</span>

<span class="sd">        input_size (int): Size of the input layer.</span>

<span class="sd">        hidden_sizes (List[int]): Sizes of the hidden layers.</span>

<span class="sd">        output_size (int): Size of the output layer.</span>

<span class="sd">        dropout_rate (float): Dropout rate for regularization.</span>

<span class="sd">        batch_norm (bool): Whether to use batch normalization.</span>

<span class="sd">        weight_init (str): Weight initialization method.</span>

<span class="sd">        learning_rate (float): Learning rate for the optimizer.</span>

<span class="sd">        optimizer_name (str): Name of the optimizer to use.</span>

<span class="sd">        model (nn.Sequential): The PyTorch sequential model containing all layers.</span>

<span class="sd">        optimizer (torch.optim.Optimizer): The optimizer for training the network.</span>

<span class="sd">    This NeuralNetwork class offers a high degree of flexibility and customization:</span>

<span class="sd">    1. Supports arbitrary numbers and sizes of hidden layers.</span>

<span class="sd">    2. Offers multiple activation functions (ReLU, LeakyReLU, Tanh, Sigmoid, ELU).</span>

<span class="sd">    3. Includes options for dropout and batch normalization for regularization.</span>

<span class="sd">    4. Provides various weight initialization methods (Xavier, He initialization).</span>

<span class="sd">    5. Supports different optimizers (Adam, SGD, RMSprop).</span>

<span class="sd">    6. Includes methods for genetic algorithm-style operations (mutation, cloning).</span>

<span class="sd">    7. Implements save and load functionality for model persistence.</span>

<span class="sd">    Usage:</span>

<span class="sd">        model = NeuralNetwork(</span>
<span class="sd">            input_size=10,</span>
<span class="sd">            hidden_sizes=[64, 32],</span>
<span class="sd">            output_size=1,</span>
<span class="sd">            activation=&#39;relu&#39;,</span>
<span class="sd">            dropout_rate=0.1,</span>
<span class="sd">            batch_norm=True,</span>
<span class="sd">            weight_init=&#39;he_uniform&#39;,</span>
<span class="sd">            optimizer=&#39;adam&#39;</span>
<span class="sd">        )</span>

<span class="sd">        output = model(input_tensor)</span>

<span class="sd">        model.save(&#39;model.pth&#39;)</span>

<span class="sd">        loaded_model = NeuralNetwork.load(&#39;model.pth&#39;)</span>

<span class="sd">    This class is particularly useful for experiments involving neural architecture search,</span>
<span class="sd">    evolutionary algorithms, or any scenario requiring dynamic creation and modification of</span>
<span class="sd">    neural networks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">input_size</span><span class="p">,</span>
                 <span class="n">hidden_sizes</span><span class="p">,</span>
                 <span class="n">output_size</span><span class="p">,</span>
                 <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span>
                 <span class="n">output_activation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">dropout_rate</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">batch_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">weight_init</span><span class="o">=</span><span class="s1">&#39;xavier_uniform&#39;</span><span class="p">,</span>
                 <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
                 <span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a feedforward neural network with customizable hyperparameters.</span>

<span class="sd">        :param input_size: Number of input features</span>
<span class="sd">        :type input_size: int</span>
<span class="sd">        :param hidden_sizes: List of hidden layer sizes</span>
<span class="sd">        :type hidden_sizes: List[int]</span>
<span class="sd">        :param output_size: Number of output units</span>
<span class="sd">        :type output_size: int</span>
<span class="sd">        :param activation: Activation function for hidden layers</span>
<span class="sd">        :type activation: str</span>
<span class="sd">        :param output_activation: Activation function for the output layer</span>
<span class="sd">        :type output_activation: str</span>
<span class="sd">        :param dropout_rate: Dropout rate (0.0 to 1.0)</span>
<span class="sd">        :type dropout_rate: float</span>
<span class="sd">        :param batch_norm: Whether to use batch normalization</span>
<span class="sd">        :type batch_norm: bool</span>
<span class="sd">        :param weight_init: Weight initialization method</span>
<span class="sd">        :type weight_init: str</span>
<span class="sd">        :param learning_rate: Learning rate for the optimizer</span>
<span class="sd">        :type learning_rate: float</span>
<span class="sd">        :param optimizer: Optimizer name (&#39;adam&#39;, &#39;sgd&#39;, &#39;rmsprop&#39;)</span>
<span class="sd">        :type optimizer: str</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">NeuralNetwork</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_size</span> <span class="o">=</span> <span class="n">input_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_sizes</span> <span class="o">=</span> <span class="n">hidden_sizes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span> <span class="o">=</span> <span class="n">output_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dropout_rate</span> <span class="o">=</span> <span class="n">dropout_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_norm</span> <span class="o">=</span> <span class="n">batch_norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_init</span> <span class="o">=</span> <span class="n">weight_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="n">learning_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizer_name</span> <span class="o">=</span> <span class="n">optimizer</span>

        <span class="c1"># Define activation functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation_functions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;relu&#39;</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(),</span>
            <span class="s1">&#39;leaky_relu&#39;</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">LeakyReLU</span><span class="p">(),</span>
            <span class="s1">&#39;tanh&#39;</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">Tanh</span><span class="p">(),</span>
            <span class="s1">&#39;sigmoid&#39;</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">(),</span>
            <span class="s1">&#39;elu&#39;</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">ELU</span><span class="p">(),</span>
            <span class="kc">None</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_functions</span><span class="p">[</span><span class="n">activation</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_activation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_functions</span><span class="p">[</span><span class="n">output_activation</span><span class="p">]</span>

        <span class="c1"># Create layers</span>
        <span class="n">layers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_size</span> <span class="o">=</span> <span class="n">input_size</span>
        <span class="k">for</span> <span class="n">hidden_size</span> <span class="ow">in</span> <span class="n">hidden_sizes</span><span class="p">:</span>
            <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">prev_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_norm</span><span class="p">:</span>
                <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DynamicBatchNorm1d</span><span class="p">(</span><span class="n">hidden_size</span><span class="p">))</span>
            <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout_rate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dropout_rate</span><span class="p">))</span>
            <span class="n">prev_size</span> <span class="o">=</span> <span class="n">hidden_size</span>
        <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">prev_size</span><span class="p">,</span> <span class="n">output_size</span><span class="p">))</span>
        <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_activation</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">layers</span><span class="p">)</span>

        <span class="c1"># Initialize weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_weights</span><span class="p">)</span>

        <span class="c1"># Set up optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_optimizer</span><span class="p">()</span>

<div class="viewcode-block" id="NeuralNetwork.forward">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetwork.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass through the neural network.</span>

<span class="sd">        :param x: Input tensor</span>
<span class="sd">        :type x: torch.Tensor</span>
<span class="sd">        :return: Output tensor</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_init_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the weights of the network based on the specified method.</span>

<span class="sd">        :param module: Neural network module</span>
<span class="sd">        :type module: nn.Module</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_init</span> <span class="o">==</span> <span class="s1">&#39;xavier_uniform&#39;</span><span class="p">:</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">xavier_uniform_</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_init</span> <span class="o">==</span> <span class="s1">&#39;xavier_normal&#39;</span><span class="p">:</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">xavier_normal_</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_init</span> <span class="o">==</span> <span class="s1">&#39;he_uniform&#39;</span><span class="p">:</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">kaiming_uniform_</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_init</span> <span class="o">==</span> <span class="s1">&#39;he_normal&#39;</span><span class="p">:</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">kaiming_normal_</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported weight initialization: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_init</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">zeros_</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">bias</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_optimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up the optimizer based on the specified name.</span>

<span class="sd">        :return: Optimizer instance</span>
<span class="sd">        :rtype: torch.optim.Optimizer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer_name</span> <span class="o">==</span> <span class="s1">&#39;adam&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer_name</span> <span class="o">==</span> <span class="s1">&#39;sgd&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer_name</span> <span class="o">==</span> <span class="s1">&#39;rmsprop&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">RMSprop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported optimizer: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="NeuralNetwork.mutate">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetwork.mutate">[docs]</a>
    <span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mutation_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">mutation_scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply random mutations to the network parameters.</span>
<span class="sd">        The mutations are applied by adding Gaussian noise to the parameters.</span>

<span class="sd">        :param mutation_rate: Probability of mutating each parameter</span>
<span class="sd">        :type mutation_rate: float</span>
<span class="sd">        :param mutation_scale: scale of the mutation (the standard deviation of the Gaussian noise)</span>
<span class="sd">        :type mutation_scale: float</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
                <span class="n">mutation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mutation_rate</span>
                <span class="n">mutation</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn_like</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="o">*</span> <span class="n">mutation_scale</span>
                <span class="n">param</span> <span class="o">+=</span> <span class="n">mutation</span> <span class="o">*</span> <span class="n">mutation_mask</span></div>


<div class="viewcode-block" id="NeuralNetwork.get_num_parameters">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetwork.get_num_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">get_num_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total number of trainable parameters in the network.</span>

<span class="sd">        :return: Number of parameters</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">)</span></div>


<div class="viewcode-block" id="NeuralNetwork.clone">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetwork.clone">[docs]</a>
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a deep copy of the network.</span>

<span class="sd">        :return: Cloned network</span>
<span class="sd">        :rtype: NeuralNetwork</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="n">NeuralNetwork</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_size</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hidden_sizes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="p">,</span>
            <span class="n">activation</span><span class="o">=</span><span class="nb">next</span><span class="p">(</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_functions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">),</span>
            <span class="n">output_activation</span><span class="o">=</span><span class="nb">next</span><span class="p">(</span>
                <span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_functions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_activation</span><span class="p">),</span>
            <span class="n">dropout_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dropout_rate</span><span class="p">,</span>
            <span class="n">batch_norm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_norm</span><span class="p">,</span>
            <span class="n">weight_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_init</span><span class="p">,</span>
            <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer_name</span>
        <span class="p">)</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_dict</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">clone</span></div>


<div class="viewcode-block" id="NeuralNetwork.save">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetwork.save">[docs]</a>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the model state and hyperparameters to a file.</span>

<span class="sd">        :param path: Path to the output file</span>
<span class="sd">        :type path: str</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">({</span>
            <span class="s1">&#39;model_state_dict&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span>
            <span class="s1">&#39;optimizer_state_dict&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span>
            <span class="s1">&#39;hyperparameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;input_size&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_size</span><span class="p">,</span>
                <span class="s1">&#39;hidden_sizes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_sizes</span><span class="p">,</span>
                <span class="s1">&#39;output_size&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="p">,</span>
                <span class="s1">&#39;activation&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_functions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">),</span>
                <span class="s1">&#39;output_activation&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span>
                    <span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_functions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_activation</span><span class="p">),</span>
                <span class="s1">&#39;dropout_rate&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout_rate</span><span class="p">,</span>
                <span class="s1">&#39;batch_norm&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_norm</span><span class="p">,</span>
                <span class="s1">&#39;weight_init&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_init</span><span class="p">,</span>
                <span class="s1">&#39;learning_rate&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
                <span class="s1">&#39;optimizer&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer_name</span>
            <span class="p">}</span>
        <span class="p">},</span> <span class="n">path</span><span class="p">)</span></div>


<div class="viewcode-block" id="NeuralNetwork.load">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetwork.load">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a model from a file.</span>

<span class="sd">        :param path: Path to the input file</span>
<span class="sd">        :type path: str</span>
<span class="sd">        :return: NeuralNetwork instance</span>
<span class="sd">        :rtype: NeuralNetwork</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">checkpoint</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">hyperparameters</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;hyperparameters&#39;</span><span class="p">]</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">hyperparameters</span><span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;model_state_dict&#39;</span><span class="p">])</span>
        <span class="n">model</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;optimizer_state_dict&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">model</span></div>
</div>


<div class="viewcode-block" id="NeuralNetworkAgent">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetworkAgent">[docs]</a>
<span class="k">class</span> <span class="nc">NeuralNetworkAgent</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NeuralNetworkAgent Class</span>

<span class="sd">    This class represents an agent that uses a neural network to make decisions in a stochastic</span>
<span class="sd">    process environment. It encapsulates the neural network along with methods for process</span>
<span class="sd">    selection, wealth management, and evolutionary operations.</span>

<span class="sd">    Attributes:</span>

<span class="sd">        network (NeuralNetwork): The neural network used for decision making.</span>

<span class="sd">        wealth (float): The current wealth of the agent.</span>

<span class="sd">        accumulated_wealth (float): The total accumulated wealth over time.</span>

<span class="sd">        fitness (float): The fitness score of the agent, based on accumulated wealth.</span>

<span class="sd">    The NeuralNetworkAgent class is designed to work in environments where decisions are made</span>
<span class="sd">    based on encoded representations of stochastic processes. It&#39;s particularly suited for</span>
<span class="sd">    evolutionary algorithms and reinforcement learning scenarios in financial or economic</span>
<span class="sd">    simulations.</span>

<span class="sd">    Key features:</span>

<span class="sd">    1. Decision making using a neural network on encoded process representations.</span>

<span class="sd">    2. Wealth tracking and accumulation based on process returns.</span>

<span class="sd">    3. Fitness calculation for use in evolutionary algorithms.</span>

<span class="sd">    4. Support for genetic operations like mutation and cloning.</span>

<span class="sd">    5. Persistence through save and load functionality.</span>

<span class="sd">    Usage:</span>

<span class="sd">        network = NeuralNetwork(input_size=10, hidden_sizes=[64, 32], output_size=1)</span>

<span class="sd">        agent = NeuralNetworkAgent(network)</span>

<span class="sd">        selected_process = agent.select_process(encoded_processes)</span>

<span class="sd">        agent.update_wealth(process_return)</span>

<span class="sd">        agent.calculate_fitness()</span>

<span class="sd">        mutated_agent = agent.clone()</span>

<span class="sd">        mutated_agent.mutate()</span>

<span class="sd">        agent.save(&#39;agent.pth&#39;)</span>

<span class="sd">        loaded_agent = NeuralNetworkAgent.load(&#39;agent.pth&#39;)</span>

<span class="sd">    This class is ideal for simulations where agents need to learn and adapt to complex,</span>
<span class="sd">    stochastic environments, particularly in financial modeling or economic simulations</span>
<span class="sd">    involving decision-making under uncertainty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neural_network</span><span class="p">:</span> <span class="n">NeuralNetwork</span><span class="p">,</span> <span class="n">initial_wealth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a neural network-based agent with an initial wealth value.</span>

<span class="sd">        :param neural_network: Neural network model for decision-making</span>
<span class="sd">        :type neural_network: NeuralNetwork</span>
<span class="sd">        :param initial_wealth: Initial wealth value</span>
<span class="sd">        :type initial_wealth: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">neural_network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wealth</span> <span class="o">=</span> <span class="n">initial_wealth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accumulated_wealth</span> <span class="o">=</span> <span class="n">initial_wealth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitness</span> <span class="o">=</span> <span class="mf">0.0</span>

<div class="viewcode-block" id="NeuralNetworkAgent.select_process">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetworkAgent.select_process">[docs]</a>
    <span class="k">def</span> <span class="nf">select_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoded_processes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select a process based on the neural network&#39;s output.</span>

<span class="sd">        :param encoded_processes: List of encoded processes</span>
<span class="sd">        :type encoded_processes: List[List[float]]</span>
<span class="sd">        :return: Index of the selected process</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">encoded_processes</span><span class="p">:</span>
                <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span>
                <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

            <span class="c1"># Select the process with the highest output</span>
            <span class="n">selected_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">selected_index</span></div>


<div class="viewcode-block" id="NeuralNetworkAgent.update_wealth">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetworkAgent.update_wealth">[docs]</a>
    <span class="k">def</span> <span class="nf">update_wealth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process_return</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the agent&#39;s wealth based on the process return.</span>

<span class="sd">        :param process_return: The return from the selected process</span>
<span class="sd">        :type process_return: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wealth</span> <span class="o">*=</span> <span class="n">process_return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accumulated_wealth</span> <span class="o">*=</span> <span class="n">process_return</span></div>


<div class="viewcode-block" id="NeuralNetworkAgent.reset_wealth">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetworkAgent.reset_wealth">[docs]</a>
    <span class="k">def</span> <span class="nf">reset_wealth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset the agent&#39;s wealth to the initial value.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wealth</span> <span class="o">=</span> <span class="mf">1.0</span></div>


<div class="viewcode-block" id="NeuralNetworkAgent.calculate_fitness">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetworkAgent.calculate_fitness">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the fitness of the agent based on accumulated wealth.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">accumulated_wealth</span><span class="p">)</span></div>


<div class="viewcode-block" id="NeuralNetworkAgent.mutate">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetworkAgent.mutate">[docs]</a>
    <span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mutation_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">mutation_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mutate the agent&#39;s neural network.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">mutation_rate</span><span class="p">,</span> <span class="n">mutation_scale</span><span class="p">)</span></div>


<div class="viewcode-block" id="NeuralNetworkAgent.clone">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetworkAgent.clone">[docs]</a>
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a clone of the agent with the same network structure but newly initialized weights.&quot;&quot;&quot;</span>
        <span class="n">cloned_network</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">NeuralNetworkAgent</span><span class="p">(</span><span class="n">cloned_network</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wealth</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representation of the agent.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;NeuralNetworkAgent(wealth=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wealth</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, accumulated_wealth=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">accumulated_wealth</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, fitness=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fitness</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">)&quot;</span>

<div class="viewcode-block" id="NeuralNetworkAgent.save">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetworkAgent.save">[docs]</a>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the agent&#39;s state to a file.</span>

<span class="sd">        :param path: Path to the output file</span>
<span class="sd">        :type path: str</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">({</span>
            <span class="s1">&#39;network_state_dict&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span>
            <span class="s1">&#39;network_class&#39;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">),</span>
            <span class="s1">&#39;network_params&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;input_size&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">input_size</span><span class="p">,</span>
                <span class="s1">&#39;hidden_sizes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">hidden_sizes</span><span class="p">,</span>
                <span class="s1">&#39;output_size&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">output_size</span><span class="p">,</span>
                <span class="s1">&#39;activation&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">activation_functions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span>
                                   <span class="n">func</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">activation</span><span class="p">),</span>
                <span class="s1">&#39;output_activation&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">activation_functions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span>
                                          <span class="n">func</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">output_activation</span><span class="p">),</span>
                <span class="s1">&#39;dropout_rate&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">dropout_rate</span><span class="p">,</span>
                <span class="s1">&#39;batch_norm&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">batch_norm</span><span class="p">,</span>
                <span class="s1">&#39;weight_init&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">weight_init</span><span class="p">,</span>
                <span class="s1">&#39;learning_rate&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
                <span class="s1">&#39;optimizer&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">optimizer_name</span>
            <span class="p">},</span>
            <span class="s1">&#39;wealth&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wealth</span><span class="p">,</span>
            <span class="s1">&#39;accumulated_wealth&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">accumulated_wealth</span><span class="p">,</span>
            <span class="s1">&#39;fitness&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitness</span>
        <span class="p">},</span> <span class="n">path</span><span class="p">)</span></div>


<div class="viewcode-block" id="NeuralNetworkAgent.load">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.NeuralNetworkAgent.load">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load an agent from a file.</span>

<span class="sd">        :param path: Path to the input file</span>
<span class="sd">        :type path: str</span>
<span class="sd">        :return: NeuralNetworkAgent instance</span>
<span class="sd">        :rtype: NeuralNetworkAgent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">network_class</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;network_class&#39;</span><span class="p">]</span>
        <span class="n">network_params</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;network_params&#39;</span><span class="p">]</span>

        <span class="c1"># Recreate the network</span>
        <span class="n">network</span> <span class="o">=</span> <span class="n">network_class</span><span class="p">(</span><span class="o">**</span><span class="n">network_params</span><span class="p">)</span>

        <span class="c1"># Load the state dict</span>
        <span class="n">network</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;network_state_dict&#39;</span><span class="p">])</span>

        <span class="c1"># Create the agent</span>
        <span class="n">agent</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">network</span><span class="p">)</span>
        <span class="n">agent</span><span class="o">.</span><span class="n">wealth</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;wealth&#39;</span><span class="p">]</span>
        <span class="n">agent</span><span class="o">.</span><span class="n">accumulated_wealth</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;accumulated_wealth&#39;</span><span class="p">]</span>
        <span class="n">agent</span><span class="o">.</span><span class="n">fitness</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;fitness&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">agent</span></div>
</div>


<div class="viewcode-block" id="EvolutionaryNeuralNetworkTrainer">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.EvolutionaryNeuralNetworkTrainer">[docs]</a>
<span class="k">class</span> <span class="nc">EvolutionaryNeuralNetworkTrainer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    EvolutionaryNeuralNetworkTrainer Class</span>

<span class="sd">    This class implements an evolutionary algorithm for training neural networks to make decisions</span>
<span class="sd">    in stochastic process environments. It manages a population of neural network agents, evolves</span>
<span class="sd">    them over time, and provides comprehensive logging and visualization capabilities.</span>

<span class="sd">    Attributes:</span>

<span class="sd">        population_size (int): The number of agents in the population.</span>

<span class="sd">        input_size (int): The size of the input layer for the neural networks.</span>

<span class="sd">        hidden_sizes (List[int]): The sizes of the hidden layers.</span>

<span class="sd">        output_size (int): The size of the output layer.</span>

<span class="sd">        processes (List[Union[dict, object]]): The stochastic processes used for training.</span>

<span class="sd">        process_encoder (ProcessEncoder): Encoder for the stochastic processes.</span>

<span class="sd">        process_times (List[float]): Time horizons for process simulations.</span>

<span class="sd">        mutation_rate (float): Rate of mutation for genetic operations.</span>

<span class="sd">        mutation_scale (float): Scale of mutations.</span>

<span class="sd">        with_exchange (bool): Whether to use population-wide information exchange.</span>

<span class="sd">        top_k (int): Number of top agents to consider in exchange.</span>

<span class="sd">        exchange_interval (int): Interval for population-wide information exchange.</span>

<span class="sd">        initial_wealth (float): Initial wealth of agents.</span>

<span class="sd">        keep_top_n (int): Number of top agents to keep after each removal interval.</span>

<span class="sd">        removal_interval (int): Interval for removing underperforming agents.</span>

<span class="sd">        process_selection_share (float): Proportion of processes to select in each step.</span>

<span class="sd">        output_dir (str): Directory for saving outputs.</span>

<span class="sd">    This class combines evolutionary algorithms with neural networks to tackle decision-making</span>
<span class="sd">    in stochastic environments. It&#39;s particularly suited for financial modeling, economic</span>
<span class="sd">    simulations, and other domains with complex, uncertain dynamics.</span>

<span class="sd">    Key Features:</span>

<span class="sd">    1. Flexible neural network architecture for agents.</span>

<span class="sd">    2. Support for various stochastic processes as the environment.</span>

<span class="sd">    3. Evolutionary mechanisms including mutation and reproduction.</span>

<span class="sd">    4. Option for population-wide information exchange.</span>

<span class="sd">    5. Comprehensive logging and visualization of training progress.</span>

<span class="sd">    6. Persistence of best models and training statistics.</span>

<span class="sd">    Usage:</span>

<span class="sd">        trainer = EvolutionaryNeuralNetworkTrainer(</span>
<span class="sd">            population_size=100,</span>
<span class="sd">            input_size=10,</span>
<span class="sd">            hidden_sizes=[64, 32],</span>
<span class="sd">            output_size=1,</span>
<span class="sd">            processes=stochastic_processes,</span>
<span class="sd">            process_encoder=encoder,</span>
<span class="sd">            process_times=[1.0, 2.0, 5.0],</span>
<span class="sd">            with_exchange=True</span>
<span class="sd">        )</span>

<span class="sd">        final_population, history = trainer.train(n_steps=1000, save_interval=50)</span>

<span class="sd">    This class is ideal for researchers and practitioners in fields such as quantitative finance,</span>
<span class="sd">    economics, and artificial intelligence who are interested in evolving adaptive agents for</span>
<span class="sd">    decision-making in complex, stochastic environments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">hidden_sizes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                 <span class="n">processes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">object</span><span class="p">]],</span>
                 <span class="n">process_encoder</span><span class="p">:</span> <span class="n">ProcessEncoder</span><span class="p">,</span>
                 <span class="n">process_times</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                 <span class="n">input_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
                 <span class="n">output_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">mutation_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                 <span class="n">mutation_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                 <span class="n">with_exchange</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">top_k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                 <span class="n">exchange_interval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                 <span class="n">initial_wealth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">keep_top_n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                 <span class="n">removal_interval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                 <span class="n">process_selection_share</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">output_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;output_nn&#39;</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the EvolutionaryNeuralNetworkTrainer.</span>

<span class="sd">        :param population_size: Number of agents in the population</span>
<span class="sd">        :type population_size: int</span>
<span class="sd">        :param input_size: Size of the input layer</span>
<span class="sd">        :type input_size: int</span>
<span class="sd">        :param hidden_sizes: List of hidden layer sizes</span>
<span class="sd">        :type hidden_sizes: List[int]</span>
<span class="sd">        :param output_size: Size of the output layer</span>
<span class="sd">        :type output_size: int</span>
<span class="sd">        :param processes: List of stochastic processes</span>
<span class="sd">        :type processes: List[Union[dict, object]]</span>
<span class="sd">        :param process_encoder: ProcessEncoder instance</span>
<span class="sd">        :type process_encoder: ProcessEncoder</span>
<span class="sd">        :param process_times: List of time values for process encoding</span>
<span class="sd">        :type process_times: List[float]</span>
<span class="sd">        :param mutation_rate: Probability of mutating each parameter</span>
<span class="sd">        :type mutation_rate: float</span>
<span class="sd">        :param mutation_scale: Scale of the mutation (standard deviation of the Gaussian noise)</span>
<span class="sd">        :type mutation_scale: float</span>
<span class="sd">        :param with_exchange: Whether to perform exchange of top agents</span>
<span class="sd">        :type with_exchange: bool</span>
<span class="sd">        :param top_k: Number of top agents to select for reproduction</span>
<span class="sd">        :type top_k: int</span>
<span class="sd">        :param exchange_interval: Interval for exchanging top agents</span>
<span class="sd">        :type exchange_interval: int</span>
<span class="sd">        :param initial_wealth: Initial wealth value for agents</span>
<span class="sd">        :type initial_wealth: float</span>
<span class="sd">        :param keep_top_n: Number of top agents to keep in the population</span>
<span class="sd">        :type keep_top_n: int</span>
<span class="sd">        :param removal_interval: Interval for removing low-performing agents</span>
<span class="sd">        :type removal_interval: int</span>
<span class="sd">        :param process_selection_share: Share of processes to select for each agent</span>
<span class="sd">        :type process_selection_share: float</span>
<span class="sd">        :param output_dir: Directory for saving output files</span>
<span class="sd">        :type output_dir: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">population_size</span> <span class="o">=</span> <span class="n">population_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_size</span> <span class="o">=</span> <span class="n">input_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_sizes</span> <span class="o">=</span> <span class="n">hidden_sizes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span> <span class="o">=</span> <span class="n">output_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processes</span> <span class="o">=</span> <span class="n">processes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_encoder</span> <span class="o">=</span> <span class="n">process_encoder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_times</span> <span class="o">=</span> <span class="n">process_times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutation_rate</span> <span class="o">=</span> <span class="n">mutation_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutation_scale</span> <span class="o">=</span> <span class="n">mutation_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">with_exchange</span> <span class="o">=</span> <span class="n">with_exchange</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_k</span> <span class="o">=</span> <span class="n">top_k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exchange_interval</span> <span class="o">=</span> <span class="n">exchange_interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_wealth</span> <span class="o">=</span> <span class="n">initial_wealth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_top_n</span> <span class="o">=</span> <span class="n">keep_top_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">removal_interval</span> <span class="o">=</span> <span class="n">removal_interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_selection_share</span> <span class="o">=</span> <span class="n">process_selection_share</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_population</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;training_log.txt&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">performance_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;performance_metrics.csv&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_weights_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;best_weights.pth&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="EvolutionaryNeuralNetworkTrainer.log">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.EvolutionaryNeuralNetworkTrainer.log">[docs]</a>
    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log a message to the log file.</span>

<span class="sd">        :param message: Message to log</span>
<span class="sd">        :type message: str</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">timestamp</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EvolutionaryNeuralNetworkTrainer.save_performance_metrics">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.EvolutionaryNeuralNetworkTrainer.save_performance_metrics">[docs]</a>
    <span class="k">def</span> <span class="nf">save_performance_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save performance metrics to a CSV file.</span>

<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">performance_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">DictWriter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">fieldnames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writeheader</span><span class="p">()</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span><span class="p">)</span></div>


<div class="viewcode-block" id="EvolutionaryNeuralNetworkTrainer.save_best_weights">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.EvolutionaryNeuralNetworkTrainer.save_best_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">save_best_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">best_agent</span><span class="p">:</span> <span class="n">NeuralNetworkAgent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the weights of the best performing agent.</span>

<span class="sd">        :param best_agent: Best performing agent</span>
<span class="sd">        :type best_agent: NeuralNetworkAgent</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">best_agent</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_weights_file</span><span class="p">)</span></div>


<div class="viewcode-block" id="EvolutionaryNeuralNetworkTrainer.visualize_performance">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.EvolutionaryNeuralNetworkTrainer.visualize_performance">[docs]</a>
    <span class="k">def</span> <span class="nf">visualize_performance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create separate visualizations for average and max wealth during training.</span>

<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span><span class="p">]</span>
        <span class="n">avg_wealth</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">[</span><span class="s1">&#39;avg_wealth&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span><span class="p">]</span>
        <span class="n">max_wealth</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">[</span><span class="s1">&#39;max_wealth&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span><span class="p">]</span>

        <span class="c1"># Function to create and save a single graph</span>
        <span class="k">def</span> <span class="nf">create_wealth_graph</span><span class="p">(</span><span class="n">wealth_data</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">wealth_data</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Step&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Create and save average wealth graph</span>
        <span class="n">create_wealth_graph</span><span class="p">(</span>
            <span class="n">avg_wealth</span><span class="p">,</span>
            <span class="s1">&#39;Average Wealth&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Average Wealth Evolution During Training&#39;</span><span class="p">,</span>
            <span class="s1">&#39;average_wealth_evolution.png&#39;</span>
        <span class="p">)</span>

        <span class="c1"># Create and save max wealth graph</span>
        <span class="n">create_wealth_graph</span><span class="p">(</span>
            <span class="n">max_wealth</span><span class="p">,</span>
            <span class="s1">&#39;Maximum Wealth&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Maximum Wealth Evolution During Training&#39;</span><span class="p">,</span>
            <span class="s1">&#39;max_wealth_evolution.png&#39;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Performance visualization graphs have been created and saved.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EvolutionaryNeuralNetworkTrainer.visualize_neural_network_evolution">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.EvolutionaryNeuralNetworkTrainer.visualize_neural_network_evolution">[docs]</a>
    <span class="k">def</span> <span class="nf">visualize_neural_network_evolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_video_path</span><span class="o">=</span><span class="s1">&#39;neural_network_evolution.mp4&#39;</span><span class="p">,</span> <span class="n">output_csv_path</span><span class="o">=</span><span class="s1">&#39;best_agent_params.csv&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a video visualization of the neural network evolution and save best agent parameters to CSV.</span>

<span class="sd">        :param output_video_path: Path to save the output video</span>
<span class="sd">        :type output_video_path: str</span>
<span class="sd">        :param output_csv_path: Path to save the CSV file with best agent parameters</span>
<span class="sd">        :type output_csv_path: str</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract data from history</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">]</span>
        <span class="n">best_params_history</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry</span><span class="p">[</span><span class="s1">&#39;best_params&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">]</span>

        <span class="c1"># Prepare data for visualization</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">best_params_history</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">param_values</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">params</span> <span class="ow">in</span> <span class="n">best_params_history</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span>
                        <span class="n">param_names</span><span class="p">}</span>

        <span class="c1"># Create figure and axes for animation</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param_names</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_names</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes</span><span class="p">]</span>

        <span class="c1"># Initialize plots</span>
        <span class="n">plots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
            <span class="n">plot</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="s1">&#39;b-&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_values</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">param_values</span><span class="p">[</span><span class="n">name</span><span class="p">]),</span>
                        <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">param_values</span><span class="p">[</span><span class="n">name</span><span class="p">]))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Evolution of </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Parameter Index&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Parameter Value&#39;</span><span class="p">)</span>
            <span class="n">plots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span>

        <span class="c1"># Animation update function</span>
        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">plot</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">plots</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
                <span class="n">plot</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param_values</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">frame</span><span class="p">])),</span> <span class="n">param_values</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">frame</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">plots</span>

        <span class="c1"># Create animation</span>
        <span class="n">anim</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">steps</span><span class="p">),</span> <span class="n">interval</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Save animation as video</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FFMpegWriter</span><span class="p">(</span><span class="n">fps</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">artist</span><span class="o">=</span><span class="s1">&#39;Me&#39;</span><span class="p">),</span> <span class="n">bitrate</span><span class="o">=</span><span class="mi">1800</span><span class="p">)</span>
        <span class="n">anim</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">output_video_path</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="n">writer</span><span class="p">)</span>

        <span class="c1"># Save best agent parameters to CSV</span>
        <span class="n">best_agent_params</span> <span class="o">=</span> <span class="n">best_params_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">param_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">best_agent_params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">}</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">param_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_length</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)),</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">param_dict</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_csv_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Neural network evolution video saved to </span><span class="si">{</span><span class="n">output_video_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Best agent parameters saved to </span><span class="si">{</span><span class="n">output_csv_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EvolutionaryNeuralNetworkTrainer.initialize_population">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.EvolutionaryNeuralNetworkTrainer.initialize_population">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_population</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NeuralNetworkAgent</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the population of neural network agents.</span>

<span class="sd">        :return: List of NeuralNetworkAgent instances</span>
<span class="sd">        :rtype: List[NeuralNetworkAgent]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">NeuralNetworkAgent</span><span class="p">(</span><span class="n">NeuralNetwork</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_sizes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="p">),</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">initial_wealth</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population_size</span><span class="p">)]</span></div>


    <span class="c1"># def encode_process_with_time(self, process, time):</span>
    <span class="c1">#     encoded_process = self.process_encoder.pad_encoded_process(self.process_encoder.encode_process(process))</span>
    <span class="c1">#     return [encoded_process[0]] + [time] + encoded_process[1:]</span>

<div class="viewcode-block" id="EvolutionaryNeuralNetworkTrainer.select_top_agents">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.EvolutionaryNeuralNetworkTrainer.select_top_agents">[docs]</a>
    <span class="k">def</span> <span class="nf">select_top_agents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NeuralNetworkAgent</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the top k agents based on accumulated wealth.</span>

<span class="sd">        :param k: Number of top agents to select</span>
<span class="sd">        :type k: int</span>
<span class="sd">        :return: List of top agents</span>
<span class="sd">        :rtype: List[NeuralNetworkAgent]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sorted_agents</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">agent</span><span class="p">:</span> <span class="n">agent</span><span class="o">.</span><span class="n">accumulated_wealth</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sorted_agents</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_agents</span><span class="p">))]</span></div>


<div class="viewcode-block" id="EvolutionaryNeuralNetworkTrainer.reproduce_with_exchange">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.EvolutionaryNeuralNetworkTrainer.reproduce_with_exchange">[docs]</a>
    <span class="k">def</span> <span class="nf">reproduce_with_exchange</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reproduce agents with population-wide information exchange.</span>

<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">top_agents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_top_agents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_k</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">top_agents</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: No top agents to reproduce. Reinitializing population.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_population</span><span class="p">()</span>
            <span class="k">return</span>

        <span class="c1"># Calculate average parameters</span>
        <span class="n">avg_params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">top_agents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">():</span>
            <span class="n">avg_params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">agent</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">agent</span> <span class="ow">in</span> <span class="n">top_agents</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_agents</span><span class="p">)</span>

        <span class="c1"># Create new population with noise added to averaged parameters</span>
        <span class="n">new_population</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population_size</span><span class="p">):</span>
            <span class="n">new_network</span> <span class="o">=</span> <span class="n">NeuralNetwork</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_sizes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">new_network</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">():</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">avg_params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn_like</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutation_scale</span><span class="p">)</span>
            <span class="n">new_population</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NeuralNetworkAgent</span><span class="p">(</span><span class="n">new_network</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_wealth</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="n">new_population</span></div>


<div class="viewcode-block" id="EvolutionaryNeuralNetworkTrainer.reproduce_without_exchange">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.EvolutionaryNeuralNetworkTrainer.reproduce_without_exchange">[docs]</a>
    <span class="k">def</span> <span class="nf">reproduce_without_exchange</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">new_agents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">agent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">agent</span><span class="o">.</span><span class="n">wealth</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">rounded_wealth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">agent</span><span class="o">.</span><span class="n">wealth</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rounded_wealth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">new_agent</span> <span class="o">=</span> <span class="n">agent</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                    <span class="n">new_agent</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mutation_rate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutation_scale</span><span class="p">)</span>
                    <span class="n">new_agent</span><span class="o">.</span><span class="n">wealth</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">new_agents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_agent</span><span class="p">)</span>
                <span class="n">agent</span><span class="o">.</span><span class="n">wealth</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_agents</span><span class="p">)</span></div>


<div class="viewcode-block" id="EvolutionaryNeuralNetworkTrainer.train">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.EvolutionaryNeuralNetworkTrainer.train">[docs]</a>
    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">save_interval</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the main training loop for the specified number of steps to train the evolutionary neural network.</span>

<span class="sd">        :param n_steps: Number of training steps</span>
<span class="sd">        :type n_steps: int</span>
<span class="sd">        :param save_interval: Interval for saving metrics and weights</span>
<span class="sd">        :type save_interval: int</span>
<span class="sd">        :return: Tuple of final population and training history</span>
<span class="sd">        :rtype: Tuple[List[NeuralNetworkAgent], List[Dict]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">intermediate_results_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;intermediate_results.csv&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">intermediate_results_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">csvfile</span><span class="p">:</span>
            <span class="n">csv_writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">csvfile</span><span class="p">)</span>
            <span class="n">csv_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;Step&#39;</span><span class="p">,</span> <span class="s1">&#39;Agent_Rank&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;Param_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_size</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;Total_Wealth&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting training with </span><span class="si">{</span><span class="n">n_steps</span><span class="si">}</span><span class="s2"> steps&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">n_steps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">n_steps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Warning: Population is empty. Reinitializing.&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_population</span><span class="p">()</span>

            <span class="n">num_processes_to_select</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_selection_share</span><span class="p">))</span>
            <span class="n">selected_indices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">)),</span> <span class="n">num_processes_to_select</span><span class="p">)</span>
            <span class="n">selected_processes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">selected_indices</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">agent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">:</span>
                <span class="n">agent_utilities</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">selected_processes</span><span class="p">:</span>
                    <span class="n">process_time</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_times</span><span class="p">)</span>
                    <span class="n">encoded_process_with_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_encoder</span><span class="o">.</span><span class="n">encode_process_with_time</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">process_time</span><span class="p">)</span>
                    <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">encoded_process_with_time</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">utility</span> <span class="o">=</span> <span class="n">agent</span><span class="o">.</span><span class="n">network</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                    <span class="n">agent_utilities</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">utility</span><span class="p">,</span> <span class="n">process</span><span class="p">,</span> <span class="n">process_time</span><span class="p">))</span>

                <span class="n">best_utility</span><span class="p">,</span> <span class="n">best_process</span><span class="p">,</span> <span class="n">best_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">agent_utilities</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">best_process</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">process_params</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">best_process</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;symbolic&#39;</span><span class="p">}</span>
                    <span class="n">process_instance</span> <span class="o">=</span> <span class="n">best_process</span><span class="p">[</span><span class="s1">&#39;symbolic&#39;</span><span class="p">](</span><span class="o">**</span><span class="n">process_params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">process_instance</span> <span class="o">=</span> <span class="n">best_process</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">process_instance</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">best_time</span><span class="p">,</span> <span class="n">timestep</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">num_instances</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">process_value</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">agent</span><span class="o">.</span><span class="n">update_wealth</span><span class="p">(</span><span class="n">process_value</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="n">agent</span> <span class="k">for</span> <span class="n">agent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="k">if</span> <span class="n">agent</span><span class="o">.</span><span class="n">wealth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Warning: All agents have been removed. Reinitializing population.&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_population</span><span class="p">()</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">removal_interval</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">)</span><span class="si">}</span><span class="s1"> agents.&#39;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">accumulated_wealth</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_top_n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">))]</span>
                <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Kept top </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">)</span><span class="si">}</span><span class="s2"> agents.&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_exchange</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">exchange_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reproduce_with_exchange</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reproduce_without_exchange</span><span class="p">()</span>

            <span class="c1"># Calculate and log performance metrics</span>
            <span class="n">avg_wealth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">agent</span><span class="o">.</span><span class="n">wealth</span> <span class="k">for</span> <span class="n">agent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">])</span>
            <span class="n">max_wealth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">agent</span><span class="o">.</span><span class="n">accumulated_wealth</span> <span class="k">for</span> <span class="n">agent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">])</span>
            <span class="n">best_agent</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">accumulated_wealth</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="n">step</span><span class="p">,</span>
                <span class="s1">&#39;avg_wealth&#39;</span><span class="p">:</span> <span class="n">avg_wealth</span><span class="p">,</span>
                <span class="s1">&#39;max_wealth&#39;</span><span class="p">:</span> <span class="n">max_wealth</span><span class="p">,</span>
                <span class="s1">&#39;population_size&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">)</span>
            <span class="p">})</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2"> metrics - Avg Wealth: </span><span class="si">{</span><span class="n">avg_wealth</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, Max Wealth: </span><span class="si">{</span><span class="n">max_wealth</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">%</span> <span class="n">save_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="n">step</span><span class="p">,</span>
                    <span class="s1">&#39;n_agents&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">),</span>
                    <span class="s1">&#39;avg_wealth&#39;</span><span class="p">:</span> <span class="n">avg_wealth</span><span class="p">,</span>
                    <span class="s1">&#39;best_params&#39;</span><span class="p">:</span> <span class="n">best_agent</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()</span>
                <span class="p">})</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save_performance_metrics</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save_best_weights</span><span class="p">(</span><span class="n">best_agent</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visualize_performance</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved metrics, weights, and visualization at step </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">accumulated_wealth</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">intermediate_results_path</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">csvfile</span><span class="p">:</span>
                    <span class="n">csv_writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">csvfile</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">rank</span><span class="p">,</span> <span class="n">agent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_top_n</span><span class="p">]):</span>
                        <span class="n">csv_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">step</span><span class="p">,</span> <span class="n">rank</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">agent</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span>
                            <span class="n">agent</span><span class="o">.</span><span class="n">accumulated_wealth</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">best_agent</span><span class="o">.</span><span class="n">accumulated_wealth</span> <span class="o">&gt;</span> <span class="mi">1000000</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">agent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">:</span>
                    <span class="n">agent</span><span class="o">.</span><span class="n">accumulated_wealth</span> <span class="o">/=</span> <span class="mi">1000000</span>

        <span class="n">output_video_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;neural_network_evolution.mp4&#39;</span><span class="p">)</span>
        <span class="n">output_csv_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;best_agent_parameters.csv&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visualize_neural_network_evolution</span><span class="p">(</span><span class="n">output_video_path</span><span class="p">,</span> <span class="n">output_csv_path</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Training completed&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span></div>


<div class="viewcode-block" id="EvolutionaryNeuralNetworkTrainer.load_best_weights">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.EvolutionaryNeuralNetworkTrainer.load_best_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">load_best_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent</span><span class="p">:</span> <span class="n">NeuralNetworkAgent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the best weights into an agent&#39;s network.</span>

<span class="sd">        :param agent: Agent instance</span>
<span class="sd">        :type agent: NeuralNetworkAgent</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">agent</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_weights_file</span><span class="p">))</span></div>
</div>


<span class="c1"># example usage with if main</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="c1"># Define process types</span>
    <span class="n">process_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">GeometricBrownianMotion</span><span class="p">,</span> <span class="n">BrownianMotion</span><span class="p">]</span>

    <span class="c1"># Define parameter ranges for each process type</span>
    <span class="n">param_ranges</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;GeometricBrownianMotion&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;drift&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">),</span>
            <span class="s1">&#39;volatility&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="p">},</span>
        <span class="s1">&#39;BrownianMotion&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;drift&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
            <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1"># Generate processes</span>
    <span class="n">processes</span> <span class="o">=</span> <span class="n">generate_processes</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">process_types</span><span class="p">,</span> <span class="n">param_ranges</span><span class="p">)</span>

    <span class="c1"># print(processes)</span>

    <span class="c1"># Create a ProcessEncoder instance</span>
    <span class="n">encoder</span> <span class="o">=</span> <span class="n">ProcessEncoder</span><span class="p">()</span>

    <span class="c1"># Encode and pad all processes</span>
    <span class="n">encoded_processes</span> <span class="o">=</span> <span class="p">[</span><span class="n">encoder</span><span class="o">.</span><span class="n">pad_encoded_process</span><span class="p">(</span><span class="n">encoder</span><span class="o">.</span><span class="n">encode_process</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">]</span>

    <span class="c1"># print(encoded_processes)</span>

    <span class="c1"># Create a network with custom hyperparameters</span>
    <span class="n">net</span> <span class="o">=</span> <span class="n">NeuralNetwork</span><span class="p">(</span>
        <span class="n">input_size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span>
        <span class="n">hidden_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
        <span class="n">output_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;leaky_relu&#39;</span><span class="p">,</span>
        <span class="n">output_activation</span><span class="o">=</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">,</span>
        <span class="n">dropout_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">batch_norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">weight_init</span><span class="o">=</span><span class="s1">&#39;he_uniform&#39;</span><span class="p">,</span>
        <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span>
    <span class="p">)</span>

    <span class="c1"># Create some dummy input</span>
    <span class="n">input_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>

    <span class="c1"># Forward pass</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Network output: </span><span class="si">{</span><span class="n">output</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of parameters: </span><span class="si">{</span><span class="n">net</span><span class="o">.</span><span class="n">get_num_parameters</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Mutate the network</span>
    <span class="n">net</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">mutation_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">mutation_scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="c1"># Clone the network</span>
    <span class="n">net_clone</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

    <span class="c1"># Save the network</span>
    <span class="n">net</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;my_network.pth&#39;</span><span class="p">)</span>

    <span class="c1"># Load the network</span>
    <span class="n">loaded_net</span> <span class="o">=</span> <span class="n">NeuralNetwork</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;my_network.pth&#39;</span><span class="p">)</span>

    <span class="c1"># Create an agent</span>
    <span class="n">agent</span> <span class="o">=</span> <span class="n">NeuralNetworkAgent</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>

    <span class="c1"># Example list of encoded processes</span>
    <span class="n">encoded_processes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
    <span class="p">]</span>

    <span class="c1"># Select a process</span>
    <span class="n">selected_index</span> <span class="o">=</span> <span class="n">agent</span><span class="o">.</span><span class="n">select_process</span><span class="p">(</span><span class="n">encoded_processes</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Selected process index: </span><span class="si">{</span><span class="n">selected_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Update wealth (assuming we&#39;ve simulated the selected process and got a return)</span>
    <span class="n">agent</span><span class="o">.</span><span class="n">update_wealth</span><span class="p">(</span><span class="mf">1.05</span><span class="p">)</span>  <span class="c1"># 5% return</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Updated wealth: </span><span class="si">{</span><span class="n">agent</span><span class="o">.</span><span class="n">wealth</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate fitness</span>
    <span class="n">agent</span><span class="o">.</span><span class="n">calculate_fitness</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Agent fitness: </span><span class="si">{</span><span class="n">agent</span><span class="o">.</span><span class="n">fitness</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Mutate the agent</span>
    <span class="n">agent</span><span class="o">.</span><span class="n">mutate</span><span class="p">()</span>

    <span class="c1"># Clone the agent</span>
    <span class="n">cloned_agent</span> <span class="o">=</span> <span class="n">agent</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

    <span class="c1"># Save and load the agent</span>
    <span class="n">agent</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;agent_state.pth&quot;</span><span class="p">)</span>
    <span class="n">loaded_agent</span> <span class="o">=</span> <span class="n">NeuralNetworkAgent</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;agent_state.pth&quot;</span><span class="p">)</span>

    <span class="n">process_encoder</span> <span class="o">=</span> <span class="n">ProcessEncoder</span><span class="p">()</span>

    <span class="n">process_times</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]</span>

    <span class="n">trainer</span> <span class="o">=</span> <span class="n">EvolutionaryNeuralNetworkTrainer</span><span class="p">(</span>
        <span class="n">population_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">input_size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span>  <span class="c1"># Assuming 11 input features for the encoded process</span>
        <span class="n">hidden_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
        <span class="n">output_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">processes</span><span class="o">=</span><span class="n">processes</span><span class="p">,</span>
        <span class="n">process_encoder</span><span class="o">=</span><span class="n">process_encoder</span><span class="p">,</span>
        <span class="n">with_exchange</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># Set to False for the algorithm without exchange</span>
        <span class="n">top_k</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">exchange_interval</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">keep_top_n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">removal_interval</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">process_selection_share</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">process_times</span><span class="o">=</span><span class="n">process_times</span><span class="p">,</span>
        <span class="n">output_dir</span><span class="o">=</span><span class="s1">&#39;output_nn/2&#39;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">population</span><span class="p">,</span> <span class="n">history</span> <span class="o">=</span> <span class="n">trainer</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">n_steps</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">save_interval</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">best_agent</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">agent</span><span class="p">:</span> <span class="n">agent</span><span class="o">.</span><span class="n">accumulated_wealth</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Best agent accumulated wealth: </span><span class="si">{</span><span class="n">best_agent</span><span class="o">.</span><span class="n">accumulated_wealth</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer">[docs]</a>
<span class="k">class</span> <span class="nc">ReinforcementEvolutionaryTrainer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ReinforcementEvolutionaryTrainer Class</span>
<span class="sd">    This class implements a hybrid approach combining reinforcement learning and evolutionary algorithms</span>
<span class="sd">    for training neural network agents in stochastic process environments. It manages a population of</span>
<span class="sd">    agents, evolves them over time, and applies reinforcement learning techniques to improve their</span>
<span class="sd">    decision-making capabilities.</span>

<span class="sd">    Attributes:</span>

<span class="sd">        population_size (int): The number of agents in the population.</span>

<span class="sd">        input_size (int): The size of the input layer for the neural networks.</span>

<span class="sd">        hidden_sizes (List[int]): The sizes of the hidden layers.</span>

<span class="sd">        output_size (int): The size of the output layer.</span>

<span class="sd">        processes (List[Union[dict, object]]): The stochastic processes used for training.</span>

<span class="sd">        process_encoder (ProcessEncoder): Encoder for the stochastic processes.</span>

<span class="sd">        process_times (List[float]): Time horizons for process simulations.</span>

<span class="sd">        learning_rate (float): Learning rate for the reinforcement learning updates.</span>

<span class="sd">        mutation_rate (float): Rate of mutation for genetic operations.</span>

<span class="sd">        mutation_scale (float): Scale of mutations.</span>

<span class="sd">        rl_interval (int): Interval for applying reinforcement learning updates.</span>

<span class="sd">        elite_percentage (float): Percentage of top-performing agents to consider as elite.</span>


<span class="sd">    This class combines evolutionary algorithms with reinforcement learning to create a powerful</span>
<span class="sd">    hybrid approach for training agents in complex, stochastic environments. It&#39;s particularly</span>
<span class="sd">    well-suited for financial modeling, economic simulations, and other domains with intricate,</span>
<span class="sd">    uncertain dynamics where both long-term evolution and short-term learning are beneficial.</span>

<span class="sd">    Key Features:</span>

<span class="sd">    Flexible neural network architecture for agents.</span>

<span class="sd">    Support for various stochastic processes as the environment.</span>

<span class="sd">    Reinforcement learning updates to improve agent performance.</span>

<span class="sd">    Evolutionary mechanisms including mutation, crossover, and elite selection.</span>

<span class="sd">    Periodic population renewal based on fitness.</span>

<span class="sd">    Adaptive learning through a combination of exploration and exploitation.</span>

<span class="sd">    Usage:</span>

<span class="sd">    trainer = ReinforcementEvolutionaryTrainer(</span>
<span class="sd">    population_size=100,</span>
<span class="sd">    input_size=10,</span>
<span class="sd">    hidden_sizes=[64, 32],</span>
<span class="sd">    output_size=1,</span>
<span class="sd">    processes=stochastic_processes,</span>
<span class="sd">    process_encoder=encoder,</span>
<span class="sd">    process_times=[1.0, 2.0, 5.0],</span>
<span class="sd">    learning_rate=0.001,</span>
<span class="sd">    mutation_rate=0.1,</span>
<span class="sd">    rl_interval=10</span>
<span class="sd">    )</span>

<span class="sd">    final_population = trainer.train(n_steps=1000)</span>

<span class="sd">    This class is ideal for researchers and practitioners in fields such as quantitative finance,</span>
<span class="sd">    economics, and artificial intelligence who are interested in developing sophisticated,</span>
<span class="sd">    adaptive agents capable of making informed decisions in complex, stochastic environments.</span>
<span class="sd">    The combination of evolutionary algorithms and reinforcement learning provides a robust</span>
<span class="sd">    framework for discovering and refining effective strategies in these challenging domains.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">input_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">hidden_sizes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">output_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">processes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">object</span><span class="p">]],</span>
        <span class="n">process_encoder</span><span class="p">:</span> <span class="n">ProcessEncoder</span><span class="p">,</span>
        <span class="n">process_times</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">learning_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
        <span class="n">mutation_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">mutation_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">rl_interval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">elite_percentage</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">output_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;output_nn&#39;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the ReinforcementEvolutionaryTrainer.</span>

<span class="sd">        :param population_size: Number of agents in the population</span>
<span class="sd">        :type population_size: int</span>
<span class="sd">        :param input_size: Size of the input layer</span>
<span class="sd">        :type input_size: int</span>
<span class="sd">        :param hidden_sizes: List of hidden layer sizes</span>
<span class="sd">        :type hidden_sizes: List[int]</span>
<span class="sd">        :param output_size: Size of the output layer</span>
<span class="sd">        :type output_size: int</span>
<span class="sd">        :param processes: List of stochastic processes</span>
<span class="sd">        :type processes: List[Union[dict, object]]</span>
<span class="sd">        :param process_encoder: ProcessEncoder instance</span>
<span class="sd">        :type process_encoder: ProcessEncoder</span>
<span class="sd">        :param process_times: List of time values for process encoding</span>
<span class="sd">        :type process_times: List[float]</span>
<span class="sd">        :param learning_rate: Learning rate for the neural networks</span>
<span class="sd">        :type learning_rate: float</span>
<span class="sd">        :param mutation_rate: Probability of mutating each parameter</span>
<span class="sd">        :type mutation_rate: float</span>
<span class="sd">        :param mutation_scale: Scale of the mutation (standard deviation of the Gaussian noise)</span>
<span class="sd">        :type mutation_scale: float</span>
<span class="sd">        :param rl_interval: Interval for reinforcement learning updates</span>
<span class="sd">        :type rl_interval: int</span>
<span class="sd">        :param elite_percentage: Percentage of elite agents to keep in each generation</span>
<span class="sd">        :type elite_percentage: float</span>
<span class="sd">        :param output_dir: Directory for saving output files</span>
<span class="sd">        :type output_dir: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">population_size</span> <span class="o">=</span> <span class="n">population_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_size</span> <span class="o">=</span> <span class="n">input_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_sizes</span> <span class="o">=</span> <span class="n">hidden_sizes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span> <span class="o">=</span> <span class="n">output_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processes</span> <span class="o">=</span> <span class="n">processes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_encoder</span> <span class="o">=</span> <span class="n">process_encoder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_times</span> <span class="o">=</span> <span class="n">process_times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="n">learning_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutation_rate</span> <span class="o">=</span> <span class="n">mutation_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutation_scale</span> <span class="o">=</span> <span class="n">mutation_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rl_interval</span> <span class="o">=</span> <span class="n">rl_interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elite_percentage</span> <span class="o">=</span> <span class="n">elite_percentage</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_population</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span> <span class="o">=</span> <span class="p">[</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">agent</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span> <span class="k">for</span> <span class="n">agent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;training_log.txt&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">performance_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;performance_metrics.csv&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_weights_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;best_weights.pth&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.log">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.log">[docs]</a>
    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log a message to the log file.</span>

<span class="sd">        :param message: Message to log</span>
<span class="sd">        :type message: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">timestamp</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.save_performance_metrics">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.save_performance_metrics">[docs]</a>
    <span class="k">def</span> <span class="nf">save_performance_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save performance metrics to a CSV file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">performance_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">DictWriter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">fieldnames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writeheader</span><span class="p">()</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.save_best_weights">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.save_best_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">save_best_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">best_agent</span><span class="p">:</span> <span class="n">NeuralNetworkAgent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the weights of the best-performing agent.</span>

<span class="sd">        :param best_agent: Best-performing agent</span>
<span class="sd">        :type best_agent: NeuralNetworkAgent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">best_agent</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_weights_file</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.visualize_performance">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.visualize_performance">[docs]</a>
    <span class="k">def</span> <span class="nf">visualize_performance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create visualizations for average and maximum fitness during training.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span><span class="p">]</span>
        <span class="n">avg_fitness</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">[</span><span class="s1">&#39;avg_fitness&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span><span class="p">]</span>
        <span class="n">max_fitness</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">[</span><span class="s1">&#39;max_fitness&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">performance_history</span><span class="p">]</span>

        <span class="c1"># Function to create and save a single graph</span>
        <span class="k">def</span> <span class="nf">create_fitness_graph</span><span class="p">(</span><span class="n">fitness_data</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">fitness_data</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Step&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Create and save average fitness graph</span>
        <span class="n">create_fitness_graph</span><span class="p">(</span>
            <span class="n">avg_fitness</span><span class="p">,</span>
            <span class="s1">&#39;Average Fitness&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Average Fitness Evolution During Training&#39;</span><span class="p">,</span>
            <span class="s1">&#39;average_fitness_evolution.png&#39;</span>
        <span class="p">)</span>

        <span class="c1"># Create and save maximum fitness graph</span>
        <span class="n">create_fitness_graph</span><span class="p">(</span>
            <span class="n">max_fitness</span><span class="p">,</span>
            <span class="s1">&#39;Maximum Fitness&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Maximum Fitness Evolution During Training&#39;</span><span class="p">,</span>
            <span class="s1">&#39;max_fitness_evolution.png&#39;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Performance visualization graphs have been created and saved.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.visualize_neural_network_evolution">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.visualize_neural_network_evolution">[docs]</a>
    <span class="k">def</span> <span class="nf">visualize_neural_network_evolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_video_path</span><span class="o">=</span><span class="s1">&#39;neural_network_evolution.mp4&#39;</span><span class="p">,</span>
                                           <span class="n">output_csv_path</span><span class="o">=</span><span class="s1">&#39;best_agent_params.csv&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a video visualization of the neural network evolution and save best agent parameters to CSV.</span>

<span class="sd">        :param output_video_path: Path to save the output video</span>
<span class="sd">        :type output_video_path: str</span>
<span class="sd">        :param output_csv_path: Path to save the CSV file with best agent parameters</span>
<span class="sd">        :type output_csv_path: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract data from history</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">]</span>
        <span class="n">best_params_history</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry</span><span class="p">[</span><span class="s1">&#39;best_params&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">best_params_history</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;No history data available for visualization.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Prepare data for visualization</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">best_params_history</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">param_values</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">params</span> <span class="ow">in</span> <span class="n">best_params_history</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span>
                        <span class="n">param_names</span><span class="p">}</span>

        <span class="c1"># Create figure and axes for animation</span>
        <span class="n">num_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">num_params</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">num_params</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">num_params</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes</span><span class="p">]</span>

        <span class="c1"># Initialize plots</span>
        <span class="n">plots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
            <span class="n">plot</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="s1">&#39;b-&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_values</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">all_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">param_values</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">all_values</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">all_values</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Evolution of </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Parameter Index&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Parameter Value&#39;</span><span class="p">)</span>
            <span class="n">plots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span>

        <span class="c1"># Animation update function</span>
        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">plot</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">plots</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
                <span class="n">plot</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param_values</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">frame</span><span class="p">])),</span> <span class="n">param_values</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">frame</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">plots</span>

        <span class="c1"># Create animation</span>
        <span class="n">anim</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">steps</span><span class="p">),</span> <span class="n">interval</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Save animation as video</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FFMpegWriter</span><span class="p">(</span><span class="n">fps</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">artist</span><span class="o">=</span><span class="s1">&#39;ReinforcementEvolutionaryTrainer&#39;</span><span class="p">),</span> <span class="n">bitrate</span><span class="o">=</span><span class="mi">1800</span><span class="p">)</span>
        <span class="n">anim</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">output_video_path</span><span class="p">),</span> <span class="n">writer</span><span class="o">=</span><span class="n">writer</span><span class="p">)</span>

        <span class="c1"># Save best agent parameters to CSV</span>
        <span class="n">best_agent_params</span> <span class="o">=</span> <span class="n">best_params_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">param_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">best_agent_params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">}</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">param_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_length</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)),</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">param_dict</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">output_csv_path</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Neural network evolution video saved to </span><span class="si">{</span><span class="n">output_video_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Best agent parameters saved to </span><span class="si">{</span><span class="n">output_csv_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.initialize_population">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.initialize_population">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_population</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NeuralNetworkAgent</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the population of neural network agents.</span>

<span class="sd">        :return: List of NeuralNetworkAgent instances</span>
<span class="sd">        :rtype: List[NeuralNetworkAgent]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">NeuralNetworkAgent</span><span class="p">(</span><span class="n">NeuralNetwork</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_sizes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population_size</span><span class="p">)]</span></div>


<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.select_process">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.select_process">[docs]</a>
    <span class="k">def</span> <span class="nf">select_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent</span><span class="p">:</span> <span class="n">NeuralNetworkAgent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">object</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select a process and time horizon for an agent to interact with.</span>

<span class="sd">        :param agent: NeuralNetworkAgent instance</span>
<span class="sd">        :type agent: NeuralNetworkAgent</span>
<span class="sd">        :return: Tuple of process and time</span>
<span class="sd">        :rtype: Tuple[object, float]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">encoded_processes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">process_encoder</span><span class="o">.</span><span class="n">encode_process_with_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_times</span><span class="p">))</span>
                             <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">)))]</span>
        <span class="n">process_index</span> <span class="o">=</span> <span class="n">agent</span><span class="o">.</span><span class="n">select_process</span><span class="p">(</span><span class="n">encoded_processes</span><span class="p">)</span>
        <span class="n">selected_process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">[</span><span class="n">process_index</span><span class="p">]</span>
        <span class="n">selected_time</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_times</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">selected_process</span><span class="p">,</span> <span class="n">selected_time</span></div>


<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.simulate_process">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.simulate_process">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the selected process for the given time horizon.</span>

<span class="sd">        :param process: Stochastic process instance</span>
<span class="sd">        :type process: object</span>
<span class="sd">        :param time: Time horizon for simulation</span>
<span class="sd">        :type time: float</span>
<span class="sd">        :return: Final value of the process</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">process_params</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">process</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;symbolic&#39;</span><span class="p">}</span>
            <span class="n">process_instance</span> <span class="o">=</span> <span class="n">process</span><span class="p">[</span><span class="s1">&#39;symbolic&#39;</span><span class="p">](</span><span class="o">**</span><span class="n">process_params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">process_instance</span> <span class="o">=</span> <span class="n">process</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">process_instance</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">timestep</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">num_instances</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.calculate_reward">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.calculate_reward">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_reward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_wealth</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">final_wealth</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the reward based on the change in wealth.</span>

<span class="sd">        :param initial_wealth: Initial wealth value</span>
<span class="sd">        :type initial_wealth: float</span>
<span class="sd">        :param final_wealth: Final wealth value</span>
<span class="sd">        :type final_wealth: float</span>
<span class="sd">        :return: Reward value</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">final_wealth</span> <span class="o">/</span> <span class="n">initial_wealth</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.reinforce">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.reinforce">[docs]</a>
    <span class="k">def</span> <span class="nf">reinforce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent</span><span class="p">:</span> <span class="n">NeuralNetworkAgent</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">:</span> <span class="n">optim</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">,</span> <span class="n">reward</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply reinforcement learning update to an agent.</span>
<span class="sd">        This is done by performing a gradient ascent step on the agent&#39;s neural network.</span>

<span class="sd">        :param agent: NeuralNetworkAgent instance</span>
<span class="sd">        :type agent: NeuralNetworkAgent</span>
<span class="sd">        :param optimizer: Optimizer for the neural network</span>
<span class="sd">        :type optimizer: optim.Optimizer</span>
<span class="sd">        :param reward: Reward value</span>
<span class="sd">        :type reward: float</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">agent</span><span class="o">.</span><span class="n">network</span><span class="p">(</span><span class="n">agent</span><span class="o">.</span><span class="n">last_input</span><span class="p">)</span> <span class="o">*</span> <span class="n">reward</span>  <span class="c1"># Negative because we want to maximize reward</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span></div>


<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.mutate">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.mutate">[docs]</a>
    <span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent</span><span class="p">:</span> <span class="n">NeuralNetworkAgent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply mutation to an agent&#39;s neural network.</span>
<span class="sd">        The mutation is applied to the parameters of the network based on the mutation rate and scale.</span>

<span class="sd">        :param agent: NeuralNetworkAgent instance</span>
<span class="sd">        :type agent: NeuralNetworkAgent</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">agent</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mutation_rate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutation_scale</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.select_elite">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.select_elite">[docs]</a>
    <span class="k">def</span> <span class="nf">select_elite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">population</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NeuralNetworkAgent</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NeuralNetworkAgent</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the elite agents from the population.</span>

<span class="sd">        :param population: List of NeuralNetworkAgent instances</span>
<span class="sd">        :type population: List[NeuralNetworkAgent]</span>
<span class="sd">        :return: List of elite agents</span>
<span class="sd">        :rtype: List[NeuralNetworkAgent]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sorted_population</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">elite_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">elite_percentage</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sorted_population</span><span class="p">[:</span><span class="n">elite_count</span><span class="p">]</span></div>


<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.crossover">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.crossover">[docs]</a>
    <span class="k">def</span> <span class="nf">crossover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent1</span><span class="p">:</span> <span class="n">NeuralNetworkAgent</span><span class="p">,</span> <span class="n">parent2</span><span class="p">:</span> <span class="n">NeuralNetworkAgent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NeuralNetworkAgent</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform crossover between two parent agents to create a child agent.</span>
<span class="sd">        It means that the child agent inherits some parameters from each parent.</span>

<span class="sd">        :param parent1: First parent agent</span>
<span class="sd">        :type parent1: NeuralNetworkAgent</span>
<span class="sd">        :param parent2: Second parent agent</span>
<span class="sd">        :type parent2: NeuralNetworkAgent</span>
<span class="sd">        :return: Child agent</span>
<span class="sd">        :rtype: NeuralNetworkAgent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">parent1</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">child_param</span><span class="p">,</span> <span class="n">parent2_param</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">parent2</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">parameters</span><span class="p">()):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="n">child_param</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span>
            <span class="n">child_param</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent2_param</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">child</span></div>


<div class="viewcode-block" id="ReinforcementEvolutionaryTrainer.train">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evolutionary_nn.ReinforcementEvolutionaryTrainer.train">[docs]</a>
    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the main training loop for the specified number of steps.</span>

<span class="sd">        :param n_steps: Number of training steps</span>
<span class="sd">        :type n_steps: int</span>
<span class="sd">        :return: List of final agents in the population</span>
<span class="sd">        :rtype: List[NeuralNetworkAgent]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">agent</span><span class="p">,</span> <span class="n">optimizer</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span><span class="p">):</span>
                <span class="n">process</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_process</span><span class="p">(</span><span class="n">agent</span><span class="p">)</span>
                <span class="n">encoded_process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_encoder</span><span class="o">.</span><span class="n">encode_process_with_time</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
                <span class="n">agent</span><span class="o">.</span><span class="n">last_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">encoded_process</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">initial_wealth</span> <span class="o">=</span> <span class="n">agent</span><span class="o">.</span><span class="n">wealth</span>
                <span class="n">process_return</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_process</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
                <span class="n">agent</span><span class="o">.</span><span class="n">update_wealth</span><span class="p">(</span><span class="n">process_return</span><span class="p">)</span>
                <span class="n">reward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_reward</span><span class="p">(</span><span class="n">initial_wealth</span><span class="p">,</span> <span class="n">agent</span><span class="o">.</span><span class="n">wealth</span><span class="p">)</span>
                <span class="n">agent</span><span class="o">.</span><span class="n">fitness</span> <span class="o">=</span> <span class="n">reward</span>

                <span class="k">if</span> <span class="n">step</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">rl_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reinforce</span><span class="p">(</span><span class="n">agent</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">reward</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">rl_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">elite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_elite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">)</span>
                <span class="n">new_population</span> <span class="o">=</span> <span class="n">elite</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_population</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">population_size</span><span class="p">:</span>
                    <span class="n">parent1</span><span class="p">,</span> <span class="n">parent2</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">elite</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossover</span><span class="p">(</span><span class="n">parent1</span><span class="p">,</span> <span class="n">parent2</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="n">new_population</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="n">new_population</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span> <span class="o">=</span> <span class="p">[</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">agent</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">agent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">best_agent</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">, Best Fitness: </span><span class="si">{</span><span class="n">best_agent</span><span class="o">.</span><span class="n">fitness</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, Best Wealth: </span><span class="si">{</span><span class="n">best_agent</span><span class="o">.</span><span class="n">wealth</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span></div>
</div>


<span class="c1"># Example usage</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Assuming you have defined processes, process_encoder, and process_times as before</span>
    <span class="n">trainer</span> <span class="o">=</span> <span class="n">ReinforcementEvolutionaryTrainer</span><span class="p">(</span>
        <span class="n">population_size</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
        <span class="n">input_size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span>
        <span class="n">hidden_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
        <span class="n">output_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">processes</span><span class="o">=</span><span class="n">processes</span><span class="p">,</span>
        <span class="n">process_encoder</span><span class="o">=</span><span class="n">process_encoder</span><span class="p">,</span>
        <span class="n">process_times</span><span class="o">=</span><span class="n">process_times</span><span class="p">,</span>
        <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
        <span class="n">mutation_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">mutation_scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">rl_interval</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">elite_percentage</span><span class="o">=</span><span class="mf">0.2</span>
    <span class="p">)</span>

    <span class="n">final_population</span> <span class="o">=</span> <span class="n">trainer</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">n_steps</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
    <span class="n">best_agent</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">final_population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Training completed. Best agent fitness: </span><span class="si">{</span><span class="n">best_agent</span><span class="o">.</span><span class="n">fitness</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, Best agent wealth: </span><span class="si">{</span><span class="n">best_agent</span><span class="o">.</span><span class="n">wealth</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Ergodicity Library</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Ihor Kendiukhov.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>