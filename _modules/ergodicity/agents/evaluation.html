<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ergodicity.agents.evaluation &#8212; Ergodicity Library 0.3.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../_static/documentation_options.js?v=e259d695"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ergodicity.agents.evaluation</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">evaluation Submodule Overview</span>

<span class="sd">The **`evaluation`** submodule provides tools for analyzing, comparing, and optimizing utility functions in decision-making environments. It allows users to evaluate how agents which learnt their behaviour using different optimization algorithms interact with stochastic processes and fit utility functions to observed behaviors using various optimization techniques.</span>

<span class="sd">Key Features:</span>

<span class="sd">1. **Utility Function Definition and Evaluation**:</span>

<span class="sd">   - The submodule allows users to define custom utility functions and optimize them based on stochastic process trajectories.</span>

<span class="sd">   - The **`UtilityFunction`** class is used to define utility functions with initial parameters, and it supports fitting parameters to minimize negative log-likelihood.</span>

<span class="sd">2. **Utility Function Inference**:</span>

<span class="sd">   - The **`UtilityFunctionInference`** class facilitates the fitting of utility functions to agent decisions.</span>

<span class="sd">   - Users can use both maximum likelihood estimation (MLE) and Bayesian inference (using Metropolis-Hastings sampling) to fit utility functions.</span>

<span class="sd">   - This class also includes methods for generating datasets, fitting models, and visualizing results such as utility functions and parameter distributions.</span>

<span class="sd">3. **Regression Analysis**:</span>

<span class="sd">   - A neural network-based regression model can be trained to predict agent preferences based on process parameters.</span>

<span class="sd">   - The **`regression_fit()`** method fits a neural network to the dataset, while **`plot_regression_results()`** provides visualizations of training results.</span>

<span class="sd">4. **Utility Function Tester**:</span>

<span class="sd">   - The **`UtilityFunctionTester`** class allows users to test and compare multiple utility functions by simulating processes and calculating optimal utility values for each function.</span>

<span class="sd">   - Includes methods for generating process parameters, simulating process trajectories, and optimizing utility functions for given trajectories.</span>

<span class="sd">5. **Inverse Reinforcement Learning (IRL)**:</span>

<span class="sd">   - The **`MaxEntIRL`** (Maximum Entropy Inverse Reinforcement Learning) class infers reward weights from agent behavior using observed trajectories.</span>

<span class="sd">   - The IRL approach fits a reward model that explains observed agent decisions by maximizing the likelihood of the agent&#39;s actions.</span>

<span class="sd">Example Usage:</span>

<span class="sd">### Fitting Utility Functions to Agent&#39;s Choices:</span>

<span class="sd">from ergodicity.evaluation import UtilityFunctionInference, UtilityFunction</span>

<span class="sd">from ergodicity.process.basic import BrownianMotion, GeometricBrownianMotion</span>

<span class="sd"># Initialize UtilityFunctionInference</span>

<span class="sd">ufi = UtilityFunctionInference(&#39;path/to/your/model.h5&#39;, param_ranges={</span>
<span class="sd">    &#39;BrownianMotion&#39;: {&#39;mu&#39;: (0, 0.5), &#39;sigma&#39;: (0.1, 0.5)},</span>
<span class="sd">    &#39;GeometricBrownianMotion&#39;: {&#39;mu&#39;: (0, 0.5), &#39;sigma&#39;: (0.1, 0.5)}</span>
<span class="sd">})</span>

<span class="sd"># Add utility functions to be fitted</span>

<span class="sd">ufi.add_utility_function(UtilityFunction(&#39;Power&#39;, lambda x, beta: x ** beta, [1.0]))</span>

<span class="sd">ufi.add_utility_function(UtilityFunction(&#39;Exponential&#39;, lambda x, alpha: 1 - np.exp(-alpha * x), [1.0]))</span>

<span class="sd"># Generate dataset of stochastic processes</span>

<span class="sd">dataset = ufi.generate_dataset(100)</span>

<span class="sd"># Get agent&#39;s choices based on the dataset</span>

<span class="sd">choices = ufi.get_agent_choices(dataset)</span>

<span class="sd"># Fit utility functions based on the agent&#39;s choices</span>

<span class="sd">ufi.fit_utility_functions(dataset, choices)</span>

<span class="sd"># Plot the fitted utility functions</span>

<span class="sd">ufi.plot_utility_functions()</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.framework.ops</span> <span class="kn">import</span> <span class="n">strip_name_scope</span>
<span class="kn">from</span> <span class="nn">ergodicity.agents.sml</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">ergodicity.tools.helper</span> <span class="kn">import</span> <span class="n">ProcessEncoder</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">ergodicity.process.basic</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">ergodicity.process.multiplicative</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="nn">ergodicity.tools.compute</span> <span class="kn">import</span> <span class="o">*</span>

<div class="viewcode-block" id="UtilityFunction">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunction">[docs]</a>
<span class="k">class</span> <span class="nc">UtilityFunction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    UtilityFunction Class</span>

<span class="sd">    This class represents a utility function used in decision-making models and optimization problems.</span>

<span class="sd">    Attributes:</span>

<span class="sd">        name (str): The name of the utility function.</span>

<span class="sd">        func (Callable): The actual utility function implementation.</span>

<span class="sd">        initial_params (List[float]): Initial parameters for the utility function.</span>

<span class="sd">        fitted_params (List[float] or None): Fitted parameters after optimization, if any.</span>

<span class="sd">        nll (float or None): Negative log-likelihood of the fitted function, if calculated.</span>

<span class="sd">    The UtilityFunction class encapsulates both the definition and the behavior of a utility function.</span>
<span class="sd">    It supports initial parametrization and subsequent fitting, making it suitable for use in</span>
<span class="sd">    optimization processes where the parameters of the utility function are adjusted based on data.</span>

<span class="sd">    Usage:</span>

<span class="sd">        def power_utility(x, beta):</span>

<span class="sd">            return x ** beta</span>

<span class="sd">        util_func = UtilityFunction(&quot;Power Utility&quot;, power_utility, [1.0])</span>

<span class="sd">        # Before fitting</span>

<span class="sd">        value = util_func(2.0)  # Uses initial parameter</span>

<span class="sd">        # After fitting (assuming fitting has been done elsewhere)</span>

<span class="sd">        util_func.fitted_params = [0.8]</span>

<span class="sd">        value = util_func(2.0)  # Uses fitted parameter</span>

<span class="sd">    This class is particularly useful in contexts where multiple utility functions need to be</span>
<span class="sd">    defined, compared, and optimized, such as in economic models or decision theory applications.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">initial_params</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a utility function with a name, function, and initial parameters.</span>

<span class="sd">        :param name: Name of the utility function</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param func: The utility function as a callable</span>
<span class="sd">        :type func: Callable</span>
<span class="sd">        :param initial_params: Initial parameters for the utility function</span>
<span class="sd">        :type initial_params: List[float]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_params</span> <span class="o">=</span> <span class="n">initial_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nll</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the utility function at a given input.</span>

<span class="sd">        :param x: Input value</span>
<span class="sd">        :type x: float</span>
<span class="sd">        :return: Utility value</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_params</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fitted_params</span><span class="p">)</span></div>



<div class="viewcode-block" id="UtilityFunctionInference">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference">[docs]</a>
<span class="k">class</span> <span class="nc">UtilityFunctionInference</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    UtilityFunctionInference Class</span>

<span class="sd">    This class is designed for inferring and analyzing utility functions based on agent behavior</span>
<span class="sd">    in stochastic processes. It combines machine learning, Bayesian inference, and economic modeling</span>
<span class="sd">    to understand decision-making patterns.</span>

<span class="sd">    Attributes:</span>

<span class="sd">        model (tf.keras.Model): A neural network model loaded from a file, used for decision prediction.</span>

<span class="sd">        agent (NeuralNetworkAgent): An agent that uses the loaded model for decision-making.</span>

<span class="sd">        process_encoder (ProcessEncoder): Encoder for converting stochastic processes into a format suitable for the model.</span>

<span class="sd">        utility_functions (List[UtilityFunction]): Collection of utility functions to be analyzed.</span>

<span class="sd">        param_ranges (Dict[str, Dict[str, Tuple[float, float]]]): Ranges of parameters for different stochastic processes.</span>

<span class="sd">        mcmc_samples (Dict): Stores samples from Markov Chain Monte Carlo simulations for Bayesian inference.</span>

<span class="sd">        regression_model (tf.keras.Model or None): A regression model for preference prediction, if trained.</span>

<span class="sd">        regression_history (tf.keras.callbacks.History or None): Training history of the regression model, if available.</span>

<span class="sd">    This class provides a comprehensive toolkit for analyzing decision-making behavior in the context</span>
<span class="sd">    of stochastic processes. It supports various methods of utility function inference, including</span>
<span class="sd">    maximum likelihood estimation, Bayesian inference, and inverse reinforcement learning. The class</span>
<span class="sd">    also includes functionality for visualizing results and analyzing feature importance in the</span>
<span class="sd">    decision-making process.</span>

<span class="sd">    Usage:</span>

<span class="sd">        ufi = UtilityFunctionInference(&#39;path/to/model.h5&#39;, param_ranges)</span>

<span class="sd">        ufi.add_utility_function(UtilityFunction(&#39;Power&#39;, utility_power, [1.0]))</span>

<span class="sd">        dataset = ufi.generate_dataset(1000)</span>

<span class="sd">        choices = ufi.get_agent_choices(dataset)</span>

<span class="sd">        ufi.fit_utility_functions(dataset, choices)</span>

<span class="sd">        ufi.plot_utility_functions()</span>

<span class="sd">    This class is particularly useful for researchers and practitioners in fields such as</span>
<span class="sd">    economics, decision theory, and reinforcement learning, where understanding the underlying</span>
<span class="sd">    utility functions driving agent behavior is crucial.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">param_ranges</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]],</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the UtilityFunctionInference class with a trained model and parameter ranges.</span>

<span class="sd">        :param model_path: Path to the trained model file</span>
<span class="sd">        :type model_path: str</span>
<span class="sd">        :param param_ranges: Dictionary of process types and their parameter ranges</span>
<span class="sd">        :type param_ranges: Dict[str, Dict[str, Tuple[float, float]]]</span>
<span class="sd">        :param model: Optional Keras model instance to use instead of loading from file. If None, the model is loaded from the file.</span>
<span class="sd">        :type model: tf.keras.Model or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agent</span> <span class="o">=</span> <span class="n">NeuralNetworkAgent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_encoder</span> <span class="o">=</span> <span class="n">ProcessEncoder</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utility_functions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span> <span class="o">=</span> <span class="n">param_ranges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_samples</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regression_history</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">choices</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="UtilityFunctionInference.load_model">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.load_model">[docs]</a>
    <span class="k">def</span> <span class="nf">load_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a Keras model from a file, handling potential compatibility issues.</span>

<span class="sd">        :param model_path: Path to the model file</span>
<span class="sd">        :type model_path: str</span>
<span class="sd">        :return: Loaded Keras model</span>
<span class="sd">        :rtype: tf.keras.Model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Try to load the model normally</span>
            <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading model: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Attempting to load model with custom objects...&quot;</span><span class="p">)</span>

            <span class="c1"># Define custom objects if necessary</span>
            <span class="n">custom_objects</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;mse&#39;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">MeanSquaredError</span><span class="p">,</span>
                <span class="c1"># Add any other custom objects here if needed</span>
            <span class="p">}</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Try to load the model with custom objects</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="n">model_path</span><span class="p">,</span> <span class="n">custom_objects</span><span class="o">=</span><span class="n">custom_objects</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model loaded successfully with custom objects.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">model</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to load model even with custom objects: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Attempting to load model architecture and weights separately...&quot;</span><span class="p">)</span>

                <span class="c1"># As a last resort, try to load just the architecture and weights</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Load model architecture from json</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">model_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.h5&#39;</span><span class="p">,</span> <span class="s1">&#39;_architecture.json&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
                        <span class="n">model_json</span> <span class="o">=</span> <span class="n">json_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                    <span class="n">model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">model_from_json</span><span class="p">(</span><span class="n">model_json</span><span class="p">)</span>

                    <span class="c1"># Load weights</span>
                    <span class="n">model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>

                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model architecture and weights loaded successfully.&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">model</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to load model architecture and weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to load the model. Please check the model file and its compatibility.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.add_utility_function">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.add_utility_function">[docs]</a>
    <span class="k">def</span> <span class="nf">add_utility_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">utility_function</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a utility function to the collection for analysis.</span>

<span class="sd">        :param utility_function: UtilityFunction instance to add</span>
<span class="sd">        :type utility_function: UtilityFunction</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utility_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">utility_function</span><span class="p">)</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.generate_dataset">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.generate_dataset">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_processes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_options</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">simulate_method</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a dataset of stochastic processes for analysis.</span>

<span class="sd">        :param n_processes: Number of datasets to generate (i.e., number of decision instances)</span>
<span class="sd">        :type n_processes: int</span>
<span class="sd">        :param n_options: Number of process options per decision instance</span>
<span class="sd">        :type n_options: int</span>
<span class="sd">        :return:  List of datasets, each containing process options</span>
<span class="sd">        :rtype: List[List[np.ndarray]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">process_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_processes</span><span class="p">):</span>
            <span class="n">process_options</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_options</span><span class="p">):</span>
                <span class="n">process_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">process_types</span><span class="p">)</span>
                <span class="n">process_type_code</span> <span class="o">=</span> <span class="n">process_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">process_type</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 1-indexed</span>

                <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="n">param</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">[</span><span class="n">process_type</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

                <span class="c1"># Create a process instance</span>
                <span class="n">process_class</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">process_type</span><span class="p">]</span>
                <span class="n">process</span> <span class="o">=</span> <span class="n">process_class</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

                <span class="c1"># Simulate the process</span>
                <span class="k">if</span> <span class="n">simulate_method</span><span class="p">:</span>
                    <span class="n">trajectory</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
                        <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">timestep</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">num_instances</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">trajectory</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">simulate_until</span><span class="p">(</span>
                        <span class="n">timestep</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">num_instances</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="k">lambda</span> <span class="n">X</span><span class="p">:</span> <span class="n">X</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">X0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># Prepare data: trajectory values</span>
                <span class="c1"># Assuming trajectory is of shape (num_time_steps, num_instances)</span>
                <span class="c1"># We take the final values for each instance</span>
                <span class="n">final_values</span> <span class="o">=</span> <span class="n">trajectory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

                <span class="n">process_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">final_values</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">process_type_code</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="p">(</span><span class="n">final_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="n">final_values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">))</span>

                <span class="n">process_options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process_data</span><span class="p">)</span>

            <span class="n">dataset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process_options</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dataset</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.get_agent_choices">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.get_agent_choices">[docs]</a>
    <span class="k">def</span> <span class="nf">get_agent_choices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the agent&#39;s choice based on a dataset of process options.</span>

<span class="sd">        :param data: A list of process options, each containing process data (np.ndarray)</span>
<span class="sd">        :type data: List[np.ndarray]</span>
<span class="sd">        :return: The index of the agent&#39;s choice</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_encoded_processes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">process_data</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Extract process_type_code and parameters from the first row</span>
                <span class="n">first_row</span> <span class="o">=</span> <span class="n">process_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">process_type_code</span> <span class="o">=</span> <span class="n">first_row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">process_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_process_type</span><span class="p">(</span><span class="n">process_type_code</span><span class="p">)</span>
                <span class="n">num_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">[</span><span class="n">process_type</span><span class="p">])</span>
                <span class="n">params_values</span> <span class="o">=</span> <span class="n">first_row</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span> <span class="o">+</span> <span class="n">num_params</span><span class="p">]</span>
                <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">[</span><span class="n">process_type</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">params_values</span><span class="p">)}</span>
                <span class="n">process_class</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">process_type</span><span class="p">]</span>
                <span class="n">process</span> <span class="o">=</span> <span class="n">process_class</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
                <span class="n">encoded_process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_encoder</span><span class="o">.</span><span class="n">encode_process_with_time</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">all_encoded_processes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encoded_process</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing data point: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># Skip this process option</span>
                <span class="k">continue</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_encoded_processes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No valid processes to choose from&quot;</span><span class="p">)</span>

        <span class="c1"># Present all encoded processes to the agent at once</span>
        <span class="n">all_encoded_processes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_encoded_processes</span><span class="p">)</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent</span><span class="o">.</span><span class="n">select_process</span><span class="p">(</span><span class="n">all_encoded_processes</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Agent&#39;s choice: </span><span class="si">{</span><span class="n">choice</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">choice</span>  <span class="c1"># Return the index of the chosen process</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.get_process_type">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.get_process_type">[docs]</a>
    <span class="k">def</span> <span class="nf">get_process_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_code</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the process type name based on the type code.</span>

<span class="sd">        :param type_code: Process type code</span>
<span class="sd">        :type type_code: int</span>
<span class="sd">        :return: Process type name</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">process_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">type_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span> <span class="n">process_type</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">process_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">process_types</span><span class="p">)}</span>

        <span class="c1"># Convert type_code to float and round to nearest integer</span>
        <span class="n">type_code_int</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">type_code</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">type_code_int</span> <span class="ow">in</span> <span class="n">type_mapping</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">type_mapping</span><span class="p">[</span><span class="n">type_code_int</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid type_code: </span><span class="si">{</span><span class="n">type_code</span><span class="si">}</span><span class="s2">. Valid codes are </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">type_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.generate_choices">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.generate_choices">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_choices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_options</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_choices</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate agent choices among stochastic processes for testing utility functions with the corresponding dataset of processes to choose from.</span>

<span class="sd">        :param n_options: Number of process options per decision instance</span>
<span class="sd">        :param n_choices: Number of choices to generate (number of decision instances)</span>
<span class="sd">        :return dataset: A list of datasets, each containing process options</span>
<span class="sd">        :rtype dataset: List[List[np.ndarray]]</span>
<span class="sd">        :return: A list of choices where each choice is an index of the selected process</span>
<span class="sd">        :rtype: List[int]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_choices</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_dataset</span><span class="p">(</span><span class="n">n_processes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_options</span><span class="o">=</span><span class="n">n_options</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Since generate_dataset returns a list of datasets</span>
            <span class="n">choice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_agent_choices</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">choices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">choices</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.negative_log_likelihood">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.negative_log_likelihood">[docs]</a>
    <span class="k">def</span> <span class="nf">negative_log_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">utility_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
                                <span class="n">choices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the negative log-likelihood of the utility function given the dataset and choices,</span>
<span class="sd">        assuming the agent maximizes expected utility.</span>

<span class="sd">        :param params: Utility function parameters</span>
<span class="sd">        :type params: List[float]</span>
<span class="sd">        :param utility_func: Utility function to evaluate</span>
<span class="sd">        :type utility_func: Callable</span>
<span class="sd">        :param dataset: List of datasets, each containing lists of process trajectories</span>
<span class="sd">        :type dataset: List[List[np.ndarray]]</span>
<span class="sd">        :param choices: List of agent choices</span>
<span class="sd">        :type choices: List[int]</span>
<span class="sd">        :return: Negative log-likelihood value</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_nll</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">choice</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">choices</span><span class="p">):</span>
            <span class="n">expected_utilities</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">process_data</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">final_values</span> <span class="o">=</span> <span class="n">process_data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Final values of trajectories</span>
                <span class="n">utilities</span> <span class="o">=</span> <span class="n">utility_func</span><span class="p">(</span><span class="n">final_values</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
                <span class="n">expected_utility</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">utilities</span><span class="p">)</span>
                <span class="n">expected_utilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expected_utility</span><span class="p">)</span>
            <span class="n">expected_utilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">expected_utilities</span><span class="p">)</span>
            <span class="c1"># Softmax over expected utilities</span>
            <span class="n">exp_utilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">expected_utilities</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">expected_utilities</span><span class="p">))</span>
            <span class="n">probs</span> <span class="o">=</span> <span class="n">exp_utilities</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">exp_utilities</span><span class="p">)</span>
            <span class="n">total_nll</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="n">choice</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">total_nll</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.fit_utility_functions">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.fit_utility_functions">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_utility_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">choices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the utility functions to the observed choices using maximum likelihood estimation (MLE),</span>
<span class="sd">        assuming the agent maximizes expected utility.</span>

<span class="sd">        :param dataset: List of datasets, each containing lists of process trajectories</span>
<span class="sd">        :type dataset: List[List[np.ndarray]]</span>
<span class="sd">        :param choices: List of agent choices</span>
<span class="sd">        :type choices: List[int]</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">utility_function</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility_functions</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">negative_log_likelihood</span><span class="p">,</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">utility_function</span><span class="o">.</span><span class="n">initial_params</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">utility_function</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">choices</span><span class="p">),</span>
                <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">,</span>
                <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="n">utility_function</span><span class="o">.</span><span class="n">fitted_params</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span>
            <span class="n">utility_function</span><span class="o">.</span><span class="n">nll</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">fun</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.print_results">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.print_results">[docs]</a>
    <span class="k">def</span> <span class="nf">print_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print the fitted utility functions and their parameters, including negative log-likelihood.</span>

<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">utility_function</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility_functions</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">utility_function</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> utility function:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Parameters: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">p</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">utility_function</span><span class="o">.</span><span class="n">fitted_params</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Negative log-likelihood: </span><span class="si">{</span><span class="n">utility_function</span><span class="o">.</span><span class="n">nll</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">()</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.plot_utility_functions">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.plot_utility_functions">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_utility_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the fitted utility functions for visualization.</span>

<span class="sd">        :param x_range: Range of x values to plot</span>
<span class="sd">        :type x_range: Tuple[float, float]</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">utility_function</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility_functions</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">utility_function</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">utility_function</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Process value&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Utility&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Fitted Utility Functions&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.bayesian_fit_utility_functions">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.bayesian_fit_utility_functions">[docs]</a>
    <span class="k">def</span> <span class="nf">bayesian_fit_utility_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">choices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                                       <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">burn_in</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform Bayesian inference on utility functions using Metropolis-Hastings sampling.</span>
<span class="sd">        It generates samples from the posterior distribution of the utility function parameters.</span>
<span class="sd">        Provides a distribution of parameter values instead of a single point estimate.</span>

<span class="sd">        :param dataset: List of datasets, each containing lists of process trajectories</span>
<span class="sd">        :type dataset: List[List[np.ndarray]]</span>
<span class="sd">        :param choices: List of agent choices</span>
<span class="sd">        :type choices: List[int]</span>
<span class="sd">        :param n_samples: Number of MCMC samples to generate</span>
<span class="sd">        :type n_samples: int</span>
<span class="sd">        :param burn_in: Number of burn-in samples to discard</span>
<span class="sd">        :type burn_in: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store dataset and choices as instance variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">choices</span> <span class="o">=</span> <span class="n">choices</span>

        <span class="k">for</span> <span class="n">utility_function</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility_functions</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metropolis_hastings</span><span class="p">(</span><span class="n">utility_function</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">burn_in</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_samples</span><span class="p">[</span><span class="n">utility_function</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.metropolis_hastings">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.metropolis_hastings">[docs]</a>
    <span class="k">def</span> <span class="nf">metropolis_hastings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">utility_function</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">choices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                            <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">burn_in</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform Metropolis-Hastings sampling for Bayesian inference on utility functions.</span>
<span class="sd">        Generates samples from the posterior distribution of the utility function parameters.</span>

<span class="sd">        :param utility_function: Utility function to fit</span>
<span class="sd">        :type utility_function: UtilityFunction</span>
<span class="sd">        :param dataset: List of datasets, each containing lists of process trajectories</span>
<span class="sd">        :type dataset: List[List[np.ndarray]]</span>
<span class="sd">        :param choices: List of agent choices</span>
<span class="sd">        :type choices: List[int]</span>
<span class="sd">        :param n_samples: Number of samples to generate</span>
<span class="sd">        :type n_samples: int</span>
<span class="sd">        :param burn_in: Number of burn-in samples to discard</span>
<span class="sd">        :type burn_in: int</span>
<span class="sd">        :return: Array of MCMC samples</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">utility_function</span><span class="o">.</span><span class="n">initial_params</span><span class="p">)</span>
        <span class="n">n_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_params</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_params</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span> <span class="o">+</span> <span class="n">burn_in</span><span class="p">):</span>
            <span class="c1"># Propose new parameters</span>
            <span class="n">proposal_params</span> <span class="o">=</span> <span class="n">current_params</span> <span class="o">+</span> <span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_params</span><span class="p">)</span>

            <span class="c1"># Calculate log likelihoods</span>
            <span class="n">current_nll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">negative_log_likelihood</span><span class="p">(</span><span class="n">current_params</span><span class="p">,</span> <span class="n">utility_function</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">choices</span><span class="p">)</span>
            <span class="n">proposal_nll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">negative_log_likelihood</span><span class="p">(</span><span class="n">proposal_params</span><span class="p">,</span> <span class="n">utility_function</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">choices</span><span class="p">)</span>

            <span class="c1"># Calculate acceptance probability</span>
            <span class="n">acceptance_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">proposal_nll</span> <span class="o">-</span> <span class="n">current_nll</span><span class="p">))</span>

            <span class="c1"># Accept or reject the new parameters</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">acceptance_prob</span><span class="p">:</span>
                <span class="n">current_params</span> <span class="o">=</span> <span class="n">proposal_params</span>

            <span class="c1"># Store the sample after burn-in period</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">burn_in</span><span class="p">:</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">burn_in</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_params</span>

        <span class="k">return</span> <span class="n">samples</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.print_bayesian_results">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.print_bayesian_results">[docs]</a>
    <span class="k">def</span> <span class="nf">print_bayesian_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print the mean and standard deviation of the fitted parameters from Bayesian inference.</span>

<span class="sd">        :return:    None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">samples</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_samples</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mean_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">std_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> utility function:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">mean_params</span><span class="p">,</span> <span class="n">std_params</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Parameter </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">: Mean = </span><span class="si">{</span><span class="n">mean</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, Std = </span><span class="si">{</span><span class="n">std</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">()</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.plot_bayesian_results">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.plot_bayesian_results">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_bayesian_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the fitted utility functions based on Bayesian inference.</span>

<span class="sd">        :param x_range: Range of x values to plot. If None, it will be determined based on the data.</span>
<span class="sd">        :type x_range: Tuple[float, float] or None</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Determine x_range based on the final values in the dataset</span>
            <span class="n">all_final_values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">process_data</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="n">final_values</span> <span class="o">=</span> <span class="n">process_data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">all_final_values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">final_values</span><span class="p">)</span>
            <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">all_final_values</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">all_final_values</span><span class="p">)</span>
            <span class="n">x_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">samples</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcmc_samples</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">utility_function</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">uf</span> <span class="k">for</span> <span class="n">uf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility_functions</span> <span class="k">if</span> <span class="n">uf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">mean_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Plot mean function</span>
            <span class="n">y_mean</span> <span class="o">=</span> <span class="p">[</span><span class="n">utility_function</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="o">*</span><span class="n">mean_params</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_mean</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> (Mean)&quot;</span><span class="p">)</span>

            <span class="c1"># Plot credible intervals</span>
            <span class="n">y_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">utility_function</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">params</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">])</span>
            <span class="n">y_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">y_samples</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">y_95</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">y_samples</span><span class="p">,</span> <span class="mi">95</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_5</span><span class="p">,</span> <span class="n">y_95</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Process Value&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Utility&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Fitted Utility Functions (Bayesian Inference)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.plot_parameter_distributions">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.plot_parameter_distributions">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_parameter_distributions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the distributions of fitted parameters from Bayesian inference.</span>

<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_functions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mcmc_samples</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">n_functions</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">n_functions</span><span class="p">),</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mcmc_samples</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Param </span><span class="si">{</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> Parameter Distributions&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Parameter Value&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.regression_fit">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.regression_fit">[docs]</a>
    <span class="k">def</span> <span class="nf">regression_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_processes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">n_options</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">test_size</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                       <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">32</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train a regression model to predict agent preferences based on process parameters.</span>
<span class="sd">        The model is trained using a dataset of stochastic processes and agent choices,</span>
<span class="sd">        assuming the agent maximizes expected utility.</span>

<span class="sd">        :param n_processes: Number of decision instances to generate for training</span>
<span class="sd">        :type n_processes: int</span>
<span class="sd">        :param n_options: Number of process options per decision instance</span>
<span class="sd">        :type n_options: int</span>
<span class="sd">        :param test_size: Fraction of data to use for testing</span>
<span class="sd">        :type test_size: float</span>
<span class="sd">        :param epochs: Number of training epochs</span>
<span class="sd">        :type epochs: int</span>
<span class="sd">        :param batch_size: Batch size for training</span>
<span class="sd">        :type batch_size: int</span>
<span class="sd">        :raises ValueError: If input parameters are invalid</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Input Validation</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">test_size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;test_size must be between 0 and 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">epochs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;epochs must be a positive integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;batch_size must be a positive integer&quot;</span><span class="p">)</span>

        <span class="c1"># Generate dataset and get agent choices</span>
        <span class="n">dataset</span><span class="p">,</span> <span class="n">choices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_choices</span><span class="p">(</span><span class="n">n_options</span><span class="o">=</span><span class="n">n_options</span><span class="p">,</span> <span class="n">n_choices</span><span class="o">=</span><span class="n">n_processes</span><span class="p">)</span>

        <span class="c1"># Assign dataset and choices to instance variables for potential use in plotting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">choices</span> <span class="o">=</span> <span class="n">choices</span>

        <span class="c1"># Prepare input data (process type code and parameters) and output data (choice)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">choice</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">choices</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">process_data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="c1"># Extract process_type_code and parameters from the first row</span>
                <span class="n">first_row</span> <span class="o">=</span> <span class="n">process_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">process_type_code</span> <span class="o">=</span> <span class="n">first_row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">process_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_process_type</span><span class="p">(</span><span class="n">process_type_code</span><span class="p">)</span>
                <span class="n">num_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">[</span><span class="n">process_type</span><span class="p">])</span>
                <span class="n">params_values</span> <span class="o">=</span> <span class="n">first_row</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span> <span class="o">+</span> <span class="n">num_params</span><span class="p">]</span>
                <span class="n">process_params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">params_values</span><span class="p">)</span>

                <span class="c1"># Create feature vector: [process_type_code, param1, param2, ...]</span>
                <span class="n">feature_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">process_type_code</span><span class="p">],</span> <span class="n">params_values</span><span class="p">))</span>
                <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_vector</span><span class="p">)</span>

                <span class="c1"># Create label: 1 if this process option is the chosen one, else 0</span>
                <span class="n">label</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">choice</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># Print shapes for debugging</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;X shape: </span><span class="si">{</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Should be (n_processes * n_options, num_features)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;y shape: </span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Should be (n_processes * n_options,)</span>

        <span class="c1"># Split data into training and testing sets</span>
        <span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

        <span class="c1"># Print final shapes for debugging</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;X_train shape: </span><span class="si">{</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;X_test shape: </span><span class="si">{</span><span class="n">X_test</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;y_train shape: </span><span class="si">{</span><span class="n">y_train</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;y_test shape: </span><span class="si">{</span><span class="n">y_test</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Create and compile the regression model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
            <span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">input_shape</span><span class="o">=</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],)),</span>
            <span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">),</span>
            <span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">)</span>  <span class="c1"># Binary classification</span>
        <span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;binary_crossentropy&#39;</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">])</span>

        <span class="c1"># Train the regression model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regression_history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">validation_data</span><span class="o">=</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">),</span>
            <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.plot_regression_results">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.plot_regression_results">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_regression_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the results of the regression model training.</span>
<span class="sd">        It includes accuracy and loss curves for both training and validation sets.</span>

<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regression_history</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No regression results to plot. Run regression_fit() first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

        <span class="c1"># Plot training &amp; validation accuracy values</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regression_history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regression_history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">&#39;val_accuracy&#39;</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Model Accuracy&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Accuracy&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Epoch&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Train&#39;</span><span class="p">,</span> <span class="s1">&#39;Test&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>

        <span class="c1"># Plot training &amp; validation loss values</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regression_history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">&#39;loss&#39;</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regression_history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">&#39;val_loss&#39;</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Model Loss&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Loss&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Epoch&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Train&#39;</span><span class="p">,</span> <span class="s1">&#39;Test&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.predict_preference">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.predict_preference">[docs]</a>
    <span class="k">def</span> <span class="nf">predict_preference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict the agent&#39;s preference for a given process type and parameters.</span>
<span class="sd">        It is done by encoding the process and passing it through the regression model.</span>

<span class="sd">        :param process_type: Type of the stochastic process</span>
<span class="sd">        :type process_type: str</span>
<span class="sd">        :param params: Parameters of the stochastic process</span>
<span class="sd">        :type params: Dict[str, float]</span>
<span class="sd">        :return: Predicted preference value</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Regression model not trained. Run regression_fit() first.&quot;</span><span class="p">)</span>

        <span class="c1"># Encode the process type and parameters</span>
        <span class="n">encoded_process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_encoder</span><span class="o">.</span><span class="n">encode_process</span><span class="p">(</span><span class="nb">globals</span><span class="p">()[</span><span class="n">process_type</span><span class="p">](</span><span class="o">**</span><span class="n">params</span><span class="p">))</span>

        <span class="c1"># Make prediction</span>
        <span class="n">preference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">encoded_process</span><span class="p">]))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">preference</span><span class="p">)</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.plot_preference_heatmap">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.plot_preference_heatmap">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_preference_heatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">param1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">param2</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">n_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a heatmap of agent preferences for different parameter values of a process type.</span>
<span class="sd">        The heatmap shows how the agent&#39;s preference changes with different parameter combinations.</span>
<span class="sd">        It allows visualizing the utility landscape for the agent.</span>

<span class="sd">        :param process_type: Type of the stochastic process</span>
<span class="sd">        :type process_type: str</span>
<span class="sd">        :param param1: First parameter to vary</span>
<span class="sd">        :type param1: str</span>
<span class="sd">        :param param2: Second parameter to vary</span>
<span class="sd">        :type param2: str</span>
<span class="sd">        :param n_points: Number of points to sample for each parameter</span>
<span class="sd">        :type n_points: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Regression model not trained. Run regression_fit() first.&quot;</span><span class="p">)</span>

        <span class="c1"># Create grid of parameter values</span>
        <span class="n">param1_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">[</span><span class="n">process_type</span><span class="p">][</span><span class="n">param1</span><span class="p">],</span> <span class="n">n_points</span><span class="p">)</span>
        <span class="n">param2_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">[</span><span class="n">process_type</span><span class="p">][</span><span class="n">param2</span><span class="p">],</span> <span class="n">n_points</span><span class="p">)</span>
        <span class="n">param1_grid</span><span class="p">,</span> <span class="n">param2_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">param1_range</span><span class="p">,</span> <span class="n">param2_range</span><span class="p">)</span>

        <span class="c1"># Compute preferences for each point in the grid</span>
        <span class="n">preferences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_points</span><span class="p">,</span> <span class="n">n_points</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
                <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="n">param1</span><span class="p">:</span> <span class="n">param1_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">param2</span><span class="p">:</span> <span class="n">param2_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]}</span>
                <span class="n">preferences</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_preference</span><span class="p">(</span><span class="n">process_type</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="c1"># Plot heatmap</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">preferences</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span>
                   <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">param1_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param1_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">param2_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param2_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Preference&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">param1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">param2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Preference Heatmap for </span><span class="si">{</span><span class="n">process_type</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.analyze_feature_importance">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.analyze_feature_importance">[docs]</a>
    <span class="k">def</span> <span class="nf">analyze_feature_importance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyze the importance of different features in the regression model.</span>
<span class="sd">        The method calculates the feature importance based on the weights of the first layer of the model.</span>
<span class="sd">        It helps understand which features have the most influence on the agent&#39;s decision-making process.</span>

<span class="sd">        :return: Dictionary of feature names and their importance scores</span>
<span class="sd">        :rtype: Dict[str, float]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Regression model not trained. Run regression_fit() first.&quot;</span><span class="p">)</span>

        <span class="c1"># Get the weights of the first layer</span>
        <span class="n">first_layer_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Calculate the absolute mean of weights for each feature</span>
        <span class="n">feature_importance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">first_layer_weights</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Normalize the importance scores</span>
        <span class="n">feature_importance</span> <span class="o">=</span> <span class="n">feature_importance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">feature_importance</span><span class="p">)</span>

        <span class="c1"># Get feature names</span>
        <span class="n">feature_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Process Type&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># Sort features by importance</span>
        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">feature_importance</span><span class="p">)</span>
        <span class="n">sorted_features</span> <span class="o">=</span> <span class="p">[</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sorted_idx</span><span class="p">]</span>
        <span class="n">sorted_importance</span> <span class="o">=</span> <span class="n">feature_importance</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>

        <span class="c1"># Plot feature importance</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">barh</span><span class="p">(</span><span class="n">sorted_features</span><span class="p">,</span> <span class="n">sorted_importance</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Normalized Importance&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Feature Importance Analysis&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># Print feature importance</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Feature Importance:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">feature</span><span class="p">,</span> <span class="n">importance</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sorted_features</span><span class="p">,</span> <span class="n">sorted_importance</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">feature</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">importance</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sorted_features</span><span class="p">,</span> <span class="n">sorted_importance</span><span class="p">))</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.analyze_feature_interactions">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.analyze_feature_interactions">[docs]</a>
    <span class="k">def</span> <span class="nf">analyze_feature_interactions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyze the interaction strength between features in the regression model.</span>
<span class="sd">        It is done by calculating the dot product of the weights of the first layer.</span>
<span class="sd">        The resulting matrix shows how features interact with each other in the decision-making process.</span>

<span class="sd">        :return: Interaction strength matrix</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Regression model not trained. Run regression_fit() first.&quot;</span><span class="p">)</span>

        <span class="c1"># Get the weights of the first layer</span>
        <span class="n">first_layer_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Calculate the interaction strength between features</span>
        <span class="n">interaction_strength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">first_layer_weights</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">first_layer_weights</span><span class="p">)</span>

        <span class="c1"># Get feature names</span>
        <span class="n">feature_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Process Type&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># Plot interaction heatmap</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">interaction_strength</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Interaction Strength&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">feature_names</span><span class="p">)),</span> <span class="n">feature_names</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">feature_names</span><span class="p">)),</span> <span class="n">feature_names</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Feature Interaction Analysis&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">interaction_strength</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.plot_partial_dependence">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.plot_partial_dependence">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_partial_dependence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature_index</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the partial dependence of the predicted preference on a selected feature.</span>
<span class="sd">        The partial dependence shows how the predicted preference changes with variations in a single feature.</span>
<span class="sd">        It helps understand the relationship between the feature and the agent&#39;s decision-making process.</span>
<span class="sd">        It is calculated by fixing all other features at a reference point and varying the selected feature.</span>

<span class="sd">        :param feature_index: Index of the feature to analyze</span>
<span class="sd">        :type feature_index: int</span>
<span class="sd">        :param num_points: Number of points to sample for the selected feature</span>
<span class="sd">        :type num_points: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Regression model not trained. Run regression_fit() first.&quot;</span><span class="p">)</span>

        <span class="n">feature_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Process Type&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">feature_name</span> <span class="o">=</span> <span class="n">feature_names</span><span class="p">[</span><span class="n">feature_index</span><span class="p">]</span>

        <span class="c1"># Generate a range of values for the selected feature</span>
        <span class="k">if</span> <span class="n">feature_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Process Type</span>
            <span class="n">x_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">feature_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">param_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]][</span><span class="n">param_name</span><span class="p">]</span>
            <span class="n">x_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">param_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_points</span><span class="p">)</span>

        <span class="c1"># Create a copy of the first data point and vary only the selected feature</span>
        <span class="n">base_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">x_range</span><span class="p">:</span>
            <span class="n">input_data</span> <span class="o">=</span> <span class="n">base_input</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">input_data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">feature_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">prediction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regression_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">input_data</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prediction</span><span class="p">)</span>

        <span class="c1"># Plot partial dependence</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_range</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">feature_name</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Predicted Preference&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Partial Dependence Plot for </span><span class="si">{</span><span class="n">feature_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="UtilityFunctionInference.perform_irl">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionInference.perform_irl">[docs]</a>
    <span class="k">def</span> <span class="nf">perform_irl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_processes</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">n_options</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform Inverse Reinforcement Learning (IRL) to infer the reward function from agent choices.</span>
<span class="sd">        It uses the MaxEntIRL algorithm to learn the reward weights based on agent behavior.</span>
<span class="sd">        It is designed to understand the underlying reward structure that drives the agent&#39;s decisions.</span>

<span class="sd">        :param n_processes: Number of decision instances to generate for IRL</span>
<span class="sd">        :type n_processes: int</span>
<span class="sd">        :param n_options: Number of process options per decision instance</span>
<span class="sd">        :type n_options: int</span>
<span class="sd">        :return: Inferred reward weights</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Generate dataset and agent choices</span>
        <span class="n">dataset</span><span class="p">,</span> <span class="n">choices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_choices</span><span class="p">(</span><span class="n">n_options</span><span class="o">=</span><span class="n">n_options</span><span class="p">,</span> <span class="n">n_choices</span><span class="o">=</span><span class="n">n_processes</span><span class="p">)</span>

        <span class="c1"># Assign dataset and choices to instance variables for potential use in plotting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">choices</span> <span class="o">=</span> <span class="n">choices</span>

        <span class="c1"># Prepare trajectories for IRL</span>
        <span class="n">trajectories</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">choice</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">choices</span><span class="p">):</span>
            <span class="n">trajectory</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">process_data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="c1"># Extract process features from the first trajectory (all trajectories have the same features)</span>
                <span class="n">first_row</span> <span class="o">=</span> <span class="n">process_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">process_type_code</span> <span class="o">=</span> <span class="n">first_row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">process_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_process_type</span><span class="p">(</span><span class="n">process_type_code</span><span class="p">)</span>
                <span class="n">num_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">[</span><span class="n">process_type</span><span class="p">])</span>
                <span class="n">params_values</span> <span class="o">=</span> <span class="n">first_row</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span> <span class="o">+</span> <span class="n">num_params</span><span class="p">]</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">process_type_code</span><span class="p">],</span> <span class="n">params_values</span><span class="p">))</span>

                <span class="c1"># Define action: 1 if chosen, 0 otherwise</span>
                <span class="n">action</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">choice</span> <span class="k">else</span> <span class="mi">0</span>

                <span class="c1"># Append the (state, action) pair to the trajectory</span>
                <span class="n">trajectory</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">))</span>
            <span class="n">trajectories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>

        <span class="c1"># Initialize and fit IRL model</span>
        <span class="c1"># Number of features corresponds to the length of the state vector</span>
        <span class="n">n_features</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectories</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Number of actions: binary (chosen or not chosen)</span>
        <span class="n">n_actions</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># Initialize MaxEntIRL model</span>
        <span class="n">irl_model</span> <span class="o">=</span> <span class="n">MaxEntIRL</span><span class="p">(</span><span class="n">n_features</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">)</span>

        <span class="c1"># Fit the IRL model using the prepared trajectories</span>
        <span class="n">reward_weights</span> <span class="o">=</span> <span class="n">irl_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">trajectories</span><span class="p">)</span>

        <span class="c1"># Print and plot results</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inferred Reward Weights:&quot;</span><span class="p">)</span>
        <span class="c1"># Feature names: [&#39;Process Type&#39;, &#39;Param1&#39;, &#39;Param2&#39;, ...]</span>
        <span class="n">process_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">feature_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Process Type&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="p">[</span><span class="n">process_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">feature_names</span><span class="p">,</span> <span class="n">reward_weights</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">weight</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Plot the inferred reward weights</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">feature_names</span><span class="p">,</span> <span class="n">reward_weights</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Inferred Reward Weights&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Features&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Weight&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">reward_weights</span></div>
</div>


<div class="viewcode-block" id="MaxEntIRL">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.MaxEntIRL">[docs]</a>
<span class="k">class</span> <span class="nc">MaxEntIRL</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MaxEntIRL (Maximum Entropy Inverse Reinforcement Learning) Class</span>

<span class="sd">    This class implements the Maximum Entropy Inverse Reinforcement Learning algorithm, which aims to</span>
<span class="sd">    recover the underlying reward function from observed optimal behavior in a Markov Decision Process (MDP).</span>

<span class="sd">    Attributes:</span>

<span class="sd">        n_features (int): Number of features in the state space.</span>

<span class="sd">        n_actions (int): Number of possible actions in the MDP.</span>

<span class="sd">        learning_rate (float): Learning rate for the optimization process.</span>

<span class="sd">        n_iterations (int): Number of iterations for the optimization process.</span>

<span class="sd">        reward_weights (np.ndarray): Weights representing the reward function.</span>

<span class="sd">    The MaxEntIRL class implements the core algorithm of Maximum Entropy Inverse Reinforcement Learning.</span>
<span class="sd">    It aims to find a reward function that makes the observed behavior appear near-optimal. The algorithm</span>
<span class="sd">    works by iteratively updating the reward weights to maximize the likelihood of the observed trajectories</span>
<span class="sd">    under the maximum entropy distribution.</span>

<span class="sd">    Key aspects of the implementation:</span>

<span class="sd">    1. It uses feature expectations to characterize the observed behavior.</span>

<span class="sd">    2. It computes state visitation frequencies to understand the importance of different states.</span>

<span class="sd">    3. The optimization process uses the L-BFGS-B algorithm to find the optimal reward weights.</span>

<span class="sd">    4. The resulting policy is computed using a softmax over Q-values.</span>

<span class="sd">    This implementation is particularly useful in scenarios where we want to understand the underlying</span>
<span class="sd">    motivations or rewards that drive observed behavior, such as in robotics, autonomous systems,</span>
<span class="sd">    or behavioral economics.</span>

<span class="sd">    Usage:</span>

<span class="sd">        irl_model = MaxEntIRL(n_features=5, n_actions=3)</span>

<span class="sd">        trajectories = [...]  # List of observed state-action trajectories</span>

<span class="sd">        learned_rewards = irl_model.fit(trajectories)</span>

<span class="sd">        # Predict reward for a new state</span>

<span class="sd">        new_state = np.array([...])</span>

<span class="sd">        predicted_reward = irl_model.predict_reward(new_state)</span>

<span class="sd">    Note: This implementation assumes discrete state and action spaces and may require modifications</span>
<span class="sd">    for continuous domains or large-scale problems.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_features</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">n_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the MaxEntIRL model with the given parameters.</span>

<span class="sd">        :param n_features: Number of features in the state space</span>
<span class="sd">        :type n_features: int</span>
<span class="sd">        :param n_actions: Number of actions in the action space</span>
<span class="sd">        :type n_actions: int</span>
<span class="sd">        :param learning_rate: Learning rate for optimization</span>
<span class="sd">        :type learning_rate: float</span>
<span class="sd">        :param n_iterations: Number of iterations for optimization</span>
<span class="sd">        :type n_iterations: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_features</span> <span class="o">=</span> <span class="n">n_features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_actions</span> <span class="o">=</span> <span class="n">n_actions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="n">learning_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iterations</span> <span class="o">=</span> <span class="n">n_iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reward_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_features</span><span class="p">)</span>

<div class="viewcode-block" id="MaxEntIRL.feature_expectations">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.MaxEntIRL.feature_expectations">[docs]</a>
    <span class="k">def</span> <span class="nf">feature_expectations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectories</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute empirical feature expectations.</span>
<span class="sd">        It is the average feature value observed in the given trajectories.</span>

<span class="sd">        :param trajectories: List of observed state-action trajectories</span>
<span class="sd">        :type trajectories: List[List[Tuple[np.ndarray, int]]]</span>
<span class="sd">        :return: Empirical feature expectations</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">feature_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_features</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">trajectory</span> <span class="ow">in</span> <span class="n">trajectories</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">action</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="p">:</span>
                <span class="n">feature_exp</span> <span class="o">+=</span> <span class="n">state</span>
        <span class="k">return</span> <span class="n">feature_exp</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectories</span><span class="p">)</span></div>


<div class="viewcode-block" id="MaxEntIRL.compute_state_visitation_freq">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.MaxEntIRL.compute_state_visitation_freq">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_state_visitation_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectories</span><span class="p">,</span> <span class="n">policy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute state visitation frequencies.</span>
<span class="sd">        It calculates the frequency of visiting each state under a given policy.</span>

<span class="sd">        :param trajectories: List of observed state-action trajectories</span>
<span class="sd">        :type trajectories: List[List[Tuple[np.ndarray, int]]]</span>
<span class="sd">        :param policy: Policy function mapping states to action probabilities</span>
<span class="sd">        :type policy: Callable</span>
<span class="sd">        :return: State visitation frequencies</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectories</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">t_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">trajectory</span> <span class="ow">in</span> <span class="n">trajectories</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">t_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">t_matrix</span> <span class="o">/=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectories</span><span class="p">)</span>

        <span class="n">state_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
        <span class="n">state_freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="n">state_freq</span> <span class="o">=</span> <span class="n">state_freq</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">t_matrix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state_freq</span></div>


<div class="viewcode-block" id="MaxEntIRL.compute_expected_svf">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.MaxEntIRL.compute_expected_svf">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_expected_svf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectories</span><span class="p">,</span> <span class="n">policy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute expected state visitation frequency.</span>
<span class="sd">        It estimates the expected frequency of visiting each state under the given policy.</span>

<span class="sd">        :param trajectories: List of observed state-action trajectories</span>
<span class="sd">        :type trajectories: List[List[Tuple[np.ndarray, int]]]</span>
<span class="sd">        :param policy: Policy function mapping states to action probabilities</span>
<span class="sd">        :type policy: Callable</span>
<span class="sd">        :return: Expected state visitation frequency</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">svf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_state_visitation_freq</span><span class="p">(</span><span class="n">trajectories</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span>
        <span class="n">exp_svf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_features</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">trajectory</span> <span class="ow">in</span> <span class="n">trajectories</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trajectory</span><span class="p">):</span>
                <span class="n">exp_svf</span> <span class="o">+=</span> <span class="n">state</span> <span class="o">*</span> <span class="n">svf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">exp_svf</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectories</span><span class="p">)</span></div>


<div class="viewcode-block" id="MaxEntIRL.compute_gradient">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.MaxEntIRL.compute_gradient">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feat_exp</span><span class="p">,</span> <span class="n">exp_svf</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the gradient for the optimization.</span>
<span class="sd">        It represents the difference between empirical feature expectations and expected state visitation frequency.</span>

<span class="sd">        :param feat_exp: Empirical feature expectations</span>
<span class="sd">        :type feat_exp: np.ndarray</span>
<span class="sd">        :param exp_svf: Expected state visitation frequency</span>
<span class="sd">        :type exp_svf: np.ndarray</span>
<span class="sd">        :return: Gradient vector</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">feat_exp</span> <span class="o">-</span> <span class="n">exp_svf</span></div>


<div class="viewcode-block" id="MaxEntIRL.optimize_reward">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.MaxEntIRL.optimize_reward">[docs]</a>
    <span class="k">def</span> <span class="nf">optimize_reward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectories</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize the reward function.</span>
<span class="sd">        It uses the L-BFGS-B algorithm to find the optimal reward weights.</span>
<span class="sd">        The result is a reward function that explains the observed behavior.</span>

<span class="sd">        :param trajectories: List of observed state-action trajectories</span>
<span class="sd">        :type trajectories: List[List[Tuple[np.ndarray, int]]]</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">feat_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_expectations</span><span class="p">(</span><span class="n">trajectories</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">obj_func</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reward_weights</span> <span class="o">=</span> <span class="n">weights</span>
            <span class="n">policy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_policy</span><span class="p">(</span><span class="n">trajectories</span><span class="p">)</span>
            <span class="n">exp_svf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_expected_svf</span><span class="p">(</span><span class="n">trajectories</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">feat_exp</span> <span class="o">-</span> <span class="n">exp_svf</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">policy</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">obj_func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward_weights</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;L-BFGS-B&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reward_weights</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span></div>


<div class="viewcode-block" id="MaxEntIRL.compute_policy">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.MaxEntIRL.compute_policy">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectories</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the policy based on current reward weights.</span>
<span class="sd">        It uses a softmax over Q-values to derive the action probabilities.</span>
<span class="sd">        The result is a policy that explains the observed behavior.</span>

<span class="sd">        :param trajectories: List of observed state-action trajectories</span>
<span class="sd">        :type trajectories: List[List[Tuple[np.ndarray, int]]]</span>
<span class="sd">        :return: Computed policy</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">policy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">trajectories</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_actions</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trajectories</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">q_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward_weights</span><span class="p">)</span>
            <span class="n">policy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">q_values</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">q_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">policy</span></div>


<div class="viewcode-block" id="MaxEntIRL.fit">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.MaxEntIRL.fit">[docs]</a>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectories</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the IRL model to the given trajectories.</span>
<span class="sd">        The method allows to learn the reward function that explains the observed behavior.</span>

<span class="sd">        :param trajectories: List of observed state-action trajectories</span>
<span class="sd">        :type trajectories: List[List[Tuple[np.ndarray, int]]]</span>
<span class="sd">        :return: Inferred reward</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iterations</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optimize_reward</span><span class="p">(</span><span class="n">trajectories</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward_weights</span></div>


<div class="viewcode-block" id="MaxEntIRL.predict_reward">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.MaxEntIRL.predict_reward">[docs]</a>
    <span class="k">def</span> <span class="nf">predict_reward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict the reward for a given state.</span>
<span class="sd">        It uses the learned reward weights to estimate the reward value.</span>

<span class="sd">        :param state: Input state for reward prediction</span>
<span class="sd">        :type state: np.ndarray</span>
<span class="sd">        :return: Predicted reward value</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward_weights</span><span class="p">)</span></div>
</div>


<span class="c1"># Utility function definitions</span>
<span class="k">def</span> <span class="nf">utility_power</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Power utility function.</span>
<span class="sd">    The expression is: U(x) = x^beta</span>

<span class="sd">    :param x: Input value</span>
<span class="sd">    :type x: float</span>
<span class="sd">    :param beta: Utility parameter</span>
<span class="sd">    :type beta: float</span>
<span class="sd">    :return: Utility value</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">**</span> <span class="n">beta</span>

<span class="k">def</span> <span class="nf">utility_exp</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exponential utility function.</span>
<span class="sd">    The expression is: U(x) = 1 - exp(-alpha * x)</span>

<span class="sd">    :param x: Input value</span>
<span class="sd">    :type x: float</span>
<span class="sd">    :param alpha: Utility parameter</span>
<span class="sd">    :type alpha: float</span>
<span class="sd">    :return: Utility value</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">utility_log</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logarithmic utility function.</span>
<span class="sd">    The expression is: U(x) = log(1 + gamma * x)</span>

<span class="sd">    :param x: Input value</span>
<span class="sd">    :type x: float</span>
<span class="sd">    :param gamma: Utility parameter</span>
<span class="sd">    :type gamma: float</span>
<span class="sd">    :return: Utility value</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="utility_quadratic">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.utility_quadratic">[docs]</a>
<span class="k">def</span> <span class="nf">utility_quadratic</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quadratic utility function.</span>
<span class="sd">    The expression is: U(x) = a * x - b * x^2</span>

<span class="sd">    :param x: Input value</span>
<span class="sd">    :type x: float</span>
<span class="sd">    :param a: Utility parameter corresponding to linear term</span>
<span class="sd">    :type a: float</span>
<span class="sd">    :param b: Utility parameter corresponding to quadratic term</span>
<span class="sd">    :type b: float</span>
<span class="sd">    :return: Utility value</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="utility_arctan">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.utility_arctan">[docs]</a>
<span class="k">def</span> <span class="nf">utility_arctan</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arctan utility function.</span>
<span class="sd">    The expression is: U(x) = arctan(k * x)</span>

<span class="sd">    :param x: Input value</span>
<span class="sd">    :type x: float</span>
<span class="sd">    :param k: Utility parameter</span>
<span class="sd">    :type k: float</span>
<span class="sd">    :return: Utility value</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="utility_sigmoid">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.utility_sigmoid">[docs]</a>
<span class="k">def</span> <span class="nf">utility_sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sigmoid utility function.</span>
<span class="sd">    The expression is: U(x) = 1 / (1 + exp(-k * (x - x0)))</span>

<span class="sd">    :param x: Input value</span>
<span class="sd">    :type x: float</span>
<span class="sd">    :param k: Utility parameter controlling slope</span>
<span class="sd">    :type k: float</span>
<span class="sd">    :param x0: Utility parameter controlling inflection point</span>
<span class="sd">    :type x0: float</span>
<span class="sd">    :return: Utility value</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)))</span></div>


<div class="viewcode-block" id="utility_linear_threshold">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.utility_linear_threshold">[docs]</a>
<span class="k">def</span> <span class="nf">utility_linear_threshold</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linear threshold utility function.</span>
<span class="sd">    The expression is: U(x) = max(0, a * x - b)</span>

<span class="sd">    :param x: Input value</span>
<span class="sd">    :type x: float</span>
<span class="sd">    :param a: Utility parameter corresponding to linear term</span>
<span class="sd">    :type a: float</span>
<span class="sd">    :param b: Utility parameter   corresponding to threshold</span>
<span class="sd">    :type b: float</span>
<span class="sd">    :return: Utility value</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span></div>


<div class="viewcode-block" id="utility_cobb_douglas">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.utility_cobb_douglas">[docs]</a>
<span class="k">def</span> <span class="nf">utility_cobb_douglas</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cobb-Douglas utility function.</span>
<span class="sd">    The expression is: U(x) = x^alpha * (1 - x)^beta</span>

<span class="sd">    :param x: Input value</span>
<span class="sd">    :type x: float</span>
<span class="sd">    :param alpha: Utility parameter corresponding to first term</span>
<span class="sd">    :type alpha: float</span>
<span class="sd">    :param beta: Utility parameter corresponding to second term</span>
<span class="sd">    :type beta: float</span>
<span class="sd">    :return: Utility value</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">**</span> <span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="n">beta</span></div>


<div class="viewcode-block" id="utility_prospect_theory">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.utility_prospect_theory">[docs]</a>
<span class="k">def</span> <span class="nf">utility_prospect_theory</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prospect Theory utility function.</span>

<span class="sd">    :param x: Input value</span>
<span class="sd">    :type x: float</span>
<span class="sd">    :param alpha: Utility parameter corresponding to loss aversion</span>
<span class="sd">    :type alpha: float</span>
<span class="sd">    :param lambda_: Utility parameter corresponding to risk-seeking behavior</span>
<span class="sd">    :type lambda_: float</span>
<span class="sd">    :return: Utility value</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">**</span> <span class="n">alpha</span><span class="p">,</span> <span class="o">-</span><span class="n">lambda_</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="n">alpha</span><span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="c1"># Initialize the UtilityFunctionInference with the path to your trained model</span>
    <span class="n">ufi</span> <span class="o">=</span> <span class="n">UtilityFunctionInference</span><span class="p">(</span><span class="s1">&#39;path/to/your/model.h5&#39;</span><span class="p">)</span>

    <span class="c1"># Add utility functions to be considered</span>
    <span class="n">ufi</span><span class="o">.</span><span class="n">add_utility_function</span><span class="p">(</span><span class="n">UtilityFunction</span><span class="p">(</span><span class="s1">&#39;Power&#39;</span><span class="p">,</span> <span class="n">utility_power</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]))</span>
    <span class="n">ufi</span><span class="o">.</span><span class="n">add_utility_function</span><span class="p">(</span><span class="n">UtilityFunction</span><span class="p">(</span><span class="s1">&#39;Exponential&#39;</span><span class="p">,</span> <span class="n">utility_exp</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]))</span>
    <span class="n">ufi</span><span class="o">.</span><span class="n">add_utility_function</span><span class="p">(</span><span class="n">UtilityFunction</span><span class="p">(</span><span class="s1">&#39;Logarithmic&#39;</span><span class="p">,</span> <span class="n">utility_log</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]))</span>
    <span class="n">ufi</span><span class="o">.</span><span class="n">add_utility_function</span><span class="p">(</span><span class="n">UtilityFunction</span><span class="p">(</span><span class="s1">&#39;Quadratic&#39;</span><span class="p">,</span> <span class="n">utility_quadratic</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]))</span>
    <span class="n">ufi</span><span class="o">.</span><span class="n">add_utility_function</span><span class="p">(</span><span class="n">UtilityFunction</span><span class="p">(</span><span class="s1">&#39;Arctan&#39;</span><span class="p">,</span> <span class="n">utility_arctan</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]))</span>
    <span class="n">ufi</span><span class="o">.</span><span class="n">add_utility_function</span><span class="p">(</span><span class="n">UtilityFunction</span><span class="p">(</span><span class="s1">&#39;Sigmoid&#39;</span><span class="p">,</span> <span class="n">utility_sigmoid</span><span class="p">,</span> <span class="p">[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]))</span>
    <span class="n">ufi</span><span class="o">.</span><span class="n">add_utility_function</span><span class="p">(</span><span class="n">UtilityFunction</span><span class="p">(</span><span class="s1">&#39;Linear Threshold&#39;</span><span class="p">,</span> <span class="n">utility_linear_threshold</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]))</span>
    <span class="n">ufi</span><span class="o">.</span><span class="n">add_utility_function</span><span class="p">(</span><span class="n">UtilityFunction</span><span class="p">(</span><span class="s1">&#39;Cobb-Douglas&#39;</span><span class="p">,</span> <span class="n">utility_cobb_douglas</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]))</span>
    <span class="n">ufi</span><span class="o">.</span><span class="n">add_utility_function</span><span class="p">(</span><span class="n">UtilityFunction</span><span class="p">(</span><span class="s1">&#39;Prospect Theory&#39;</span><span class="p">,</span> <span class="n">utility_prospect_theory</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.88</span><span class="p">,</span> <span class="mf">2.25</span><span class="p">]))</span>

    <span class="c1"># Define processes and parameter ranges</span>
    <span class="n">processes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;BrownianMotion&#39;</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;GeometricBrownianMotion&#39;</span><span class="p">},</span>
        <span class="c1"># Add more process types here as needed</span>
    <span class="p">]</span>
    <span class="n">param_ranges</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;BrownianMotion&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;mu&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)},</span>
        <span class="s1">&#39;GeometricBrownianMotion&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;mu&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)},</span>
        <span class="c1"># Add parameter ranges for other process types here</span>
    <span class="p">}</span>

    <span class="c1"># Generate dataset</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">ufi</span><span class="o">.</span><span class="n">generate_dataset</span><span class="p">(</span><span class="n">processes</span><span class="p">,</span> <span class="n">param_ranges</span><span class="p">,</span> <span class="n">num_instances</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_simulations</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="c1"># Get agent choices</span>
    <span class="n">choices</span> <span class="o">=</span> <span class="n">ufi</span><span class="o">.</span><span class="n">get_agent_choices</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>

    <span class="c1"># Fit utility functions</span>
    <span class="n">ufi</span><span class="o">.</span><span class="n">fit_utility_functions</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">choices</span><span class="p">)</span>

    <span class="c1"># Print results</span>
    <span class="n">ufi</span><span class="o">.</span><span class="n">print_results</span><span class="p">()</span>

    <span class="c1"># Plot utility functions</span>
    <span class="n">ufi</span><span class="o">.</span><span class="n">plot_utility_functions</span><span class="p">()</span>

    <span class="c1"># You can also access individual fitted utility functions</span>
    <span class="n">best_utility_function</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ufi</span><span class="o">.</span><span class="n">utility_functions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">uf</span><span class="p">:</span> <span class="n">uf</span><span class="o">.</span><span class="n">nll</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The best-fitting utility function is: </span><span class="si">{</span><span class="n">best_utility_function</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;With parameters: </span><span class="si">{</span><span class="n">best_utility_function</span><span class="o">.</span><span class="n">fitted_params</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Use the best-fitting utility function</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mf">0.3</span>  <span class="c1"># Example input</span>
    <span class="n">utility</span> <span class="o">=</span> <span class="n">best_utility_function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The utility of </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> according to the best-fitting function is: </span><span class="si">{</span><span class="n">utility</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="UtilityFunctionTester">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionTester">[docs]</a>
<span class="k">class</span> <span class="nc">UtilityFunctionTester</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    UtilityFunctionTester Class</span>

<span class="sd">    This class is designed to test and analyze various utility functions against stochastic processes.</span>
<span class="sd">    It provides tools for generating process parameters, simulating processes, optimizing utility</span>
<span class="sd">    functions, and analyzing the results through statistical and visual methods.</span>

<span class="sd">    Attributes:</span>

<span class="sd">        process_class: The class of the stochastic process to be tested.</span>

<span class="sd">        param_ranges (Dict[str, Tuple[float, float]]): Ranges for each parameter of the process.</span>

<span class="sd">        utility_functions (Dict[str, Callable]): Dictionary of utility functions to be tested.</span>

<span class="sd">        results (List): Stores the results of the tests.</span>

<span class="sd">    This class provides a comprehensive framework for evaluating and comparing different utility</span>
<span class="sd">    functions in the context of stochastic processes. It is particularly useful for researchers</span>
<span class="sd">    and practitioners in fields such as economics, finance, and decision theory, where</span>
<span class="sd">    understanding the performance of utility functions under various stochastic conditions is crucial.</span>

<span class="sd">    Key features:</span>

<span class="sd">    1. Automatic generation of process parameters for comprehensive testing.</span>

<span class="sd">    2. Parallel processing capability for efficient large-scale testing.</span>

<span class="sd">    3. Advanced statistical analysis including correlation, PCA, and clustering.</span>

<span class="sd">    4. Visualization tools for intuitive interpretation of results.</span>

<span class="sd">    Usage:</span>

<span class="sd">        process_class = BrownianMotion</span>

<span class="sd">        param_ranges = {&#39;mu&#39;: (0, 0.5), &#39;sigma&#39;: (0.1, 0.5)}</span>

<span class="sd">        utility_functions = {</span>
<span class="sd">            &#39;power&#39;: lambda x, beta: x ** beta,</span>
<span class="sd">            &#39;exponential&#39;: lambda x, alpha: 1 - np.exp(-alpha * x),</span>
<span class="sd">            &#39;logarithmic&#39;: lambda x, gamma: np.log(1 + gamma * x)</span>
<span class="sd">        }</span>

<span class="sd">        tester = UtilityFunctionTester(process_class, param_ranges, utility_functions)</span>

<span class="sd">        tester.run_tests(n_processes=1000, n_steps=1000)</span>

<span class="sd">        tester.analyze_results()</span>

<span class="sd">        tester.plot_optimal_utility_vs_process_params()</span>

<span class="sd">    This class enables researchers to gain insights into how different utility functions perform</span>
<span class="sd">    under various stochastic process conditions, helping in the selection and refinement of</span>
<span class="sd">    utility models for specific applications.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">param_ranges</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
                 <span class="n">utility_functions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the UtilityFunctionTester with the given parameters.</span>

<span class="sd">        :param process_class: Class representing the stochastic process to simulate</span>
<span class="sd">        :type: process_class: type</span>
<span class="sd">        :param param_ranges: Dictionary of parameter ranges for the process</span>
<span class="sd">        :type param_ranges: Dict[str, Tuple[float, float]]</span>
<span class="sd">        :param utility_functions: Dictionary of utility functions to test</span>
<span class="sd">        :type utility_functions: Dict[str, Callable]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_class</span> <span class="o">=</span> <span class="n">process_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span> <span class="o">=</span> <span class="n">param_ranges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utility_functions</span> <span class="o">=</span> <span class="n">utility_functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="UtilityFunctionTester.generate_process_parameters">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionTester.generate_process_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_process_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate random process parameters within specified ranges.</span>

<span class="sd">        :param n_samples: Number of parameter sets to generate</span>
<span class="sd">        :type n_samples: int</span>
<span class="sd">        :return: List of process parameters</span>
<span class="sd">        :rtype: List[Dict[str, float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="n">param</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">params_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">params_list</span></div>


<div class="viewcode-block" id="UtilityFunctionTester.simulate_process">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionTester.simulate_process">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the stochastic process with given parameters.</span>

<span class="sd">        :param params: Parameters of the process</span>
<span class="sd">        :type params: Dict[str, float]</span>
<span class="sd">        :param n_steps: Number of steps to simulate</span>
<span class="sd">        :type n_steps: int</span>
<span class="sd">        :return: Trajectory of the process</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_class</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">process</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)</span></div>


<div class="viewcode-block" id="UtilityFunctionTester.calculate_utility">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionTester.calculate_utility">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_utility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">utility_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">utility_params</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the utility of a given stochastic process instance using a utility function.</span>

<span class="sd">        :param utility_func: Utility function to evaluate</span>
<span class="sd">        :type utility_func: Callable</span>
<span class="sd">        :param trajectory: Trajectory of the stochastic process</span>
<span class="sd">        :type trajectory: np.ndarray</span>
<span class="sd">        :param utility_params: Parameters of the utility function</span>
<span class="sd">        :type utility_params: List[float]</span>
<span class="sd">        :return: Utility value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">utility_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">utility_params</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="p">])</span></div>


<div class="viewcode-block" id="UtilityFunctionTester.optimize_utility_function">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionTester.optimize_utility_function">[docs]</a>
    <span class="k">def</span> <span class="nf">optimize_utility_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">utility_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize the parameters of a utility function for a given trajectory.</span>
<span class="sd">        It is done by maximizing the utility value using numerical optimization.</span>

<span class="sd">        :param utility_func: Utility function to optimize</span>
<span class="sd">        :type utility_func: Callable</span>
<span class="sd">        :param trajectory: Trajectory of the stochastic process</span>
<span class="sd">        :type trajectory: np.ndarray</span>
<span class="sd">        :return: Tuple of optimal parameters and maximum utility value</span>
<span class="sd">        :rtype: Tuple[List[float], float]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">objective</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">calculate_utility</span><span class="p">(</span><span class="n">utility_func</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="n">initial_guess</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">utility_func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">result</span><span class="o">.</span><span class="n">fun</span></div>


<div class="viewcode-block" id="UtilityFunctionTester.test_utility_functions">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionTester.test_utility_functions">[docs]</a>
    <span class="k">def</span> <span class="nf">test_utility_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process_params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test all utility functions against a simulated process trajectory.</span>
<span class="sd">        It evaluates each utility function&#39;s performance and optimizes its parameters.</span>

<span class="sd">        :param process_params:</span>
<span class="sd">        :type process_params: Dict[str, float]</span>
<span class="sd">        :param n_steps:</span>
<span class="sd">        :type n_steps: int</span>
<span class="sd">        :return:    Dictionary of results for each utility function</span>
<span class="sd">        :rtype: Dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trajectory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_process</span><span class="p">(</span><span class="n">process_params</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;process_params&#39;</span><span class="p">:</span> <span class="n">process_params</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility_functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">optimal_params</span><span class="p">,</span> <span class="n">optimal_utility</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_utility_function</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimal_params</span>
            <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">_utility&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimal_utility</span>

        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="UtilityFunctionTester.run_tests">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionTester.run_tests">[docs]</a>
    <span class="k">def</span> <span class="nf">run_tests</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_processes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run tests for multiple processes in parallel.</span>

<span class="sd">        :param n_processes: Number of processes to test</span>
<span class="sd">        :type n_processes: int</span>
<span class="sd">        :param n_steps: Number of steps to simulate for each process</span>
<span class="sd">        :type n_steps: int</span>
<span class="sd">        :param n_jobs: Number of parallel jobs to run (-1 for all cores)</span>
<span class="sd">        :type n_jobs: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">process_params_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_process_parameters</span><span class="p">(</span><span class="n">n_processes</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">params</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_utility_functions</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">),</span>
                                             <span class="n">process_params_list</span><span class="p">))</span></div>


<div class="viewcode-block" id="UtilityFunctionTester.analyze_results">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionTester.analyze_results">[docs]</a>
    <span class="k">def</span> <span class="nf">analyze_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform statistical analysis on the test results for all utility functions.</span>
<span class="sd">        It includes correlation analysis, PCA, and clustering to understand the relationships.</span>
<span class="sd">        The results are aimed to demonstrate the performance and characteristics of each utility function.</span>

<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>

        <span class="c1"># Correlation analysis</span>
        <span class="n">correlation_matrix</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">corr</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">correlation_matrix</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Correlation between Process Parameters and Utility Function Parameters&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># PCA analysis</span>
        <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">pca_result</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;process_params&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pca_result</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pca_result</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;process_params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;mu&#39;</span><span class="p">]))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Process mu&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;First Principal Component&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Second Principal Component&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;PCA of Utility Function Parameters&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># Clustering analysis</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;process_params&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">scatter</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pca_result</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pca_result</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">clusters</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="o">*</span><span class="n">scatter</span><span class="o">.</span><span class="n">legend_elements</span><span class="p">(),</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Clusters&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;First Principal Component&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Second Principal Component&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Clustering of Utility Function Parameters&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="UtilityFunctionTester.plot_optimal_utility_vs_process_params">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.UtilityFunctionTester.plot_optimal_utility_vs_process_params">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_optimal_utility_vs_process_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the relationship between process parameters and optimal utility values.</span>
<span class="sd">        It visualizes how the utility functions perform under different process conditions.</span>

<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_ranges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility_functions</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;process_params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">param</span><span class="p">]),</span>
                            <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">_utility&#39;</span><span class="p">],</span>
                            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                            <span class="n">label</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Process </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Optimal Utility&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Optimal Utility vs Process </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
</div>


<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

<span class="c1"># Usage example:</span>
    <span class="kn">from</span> <span class="nn">ergodicity.process.basic</span> <span class="kn">import</span> <span class="n">BrownianMotion</span>


    <span class="k">def</span> <span class="nf">utility_power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
       <span class="k">return</span> <span class="n">x</span> <span class="o">**</span> <span class="n">beta</span>


    <span class="k">def</span> <span class="nf">utility_exp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">utility_log</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>


    <span class="n">process_class</span> <span class="o">=</span> <span class="n">BrownianMotion</span>
    <span class="n">param_ranges</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mu&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)}</span>
    <span class="n">utility_functions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;power&#39;</span><span class="p">:</span> <span class="n">utility_power</span><span class="p">,</span>
        <span class="s1">&#39;exponential&#39;</span><span class="p">:</span> <span class="n">utility_exp</span><span class="p">,</span>
        <span class="s1">&#39;logarithmic&#39;</span><span class="p">:</span> <span class="n">utility_log</span>
    <span class="p">}</span>

    <span class="n">tester</span> <span class="o">=</span> <span class="n">UtilityFunctionTester</span><span class="p">(</span><span class="n">process_class</span><span class="p">,</span> <span class="n">param_ranges</span><span class="p">,</span> <span class="n">utility_functions</span><span class="p">)</span>
    <span class="n">tester</span><span class="o">.</span><span class="n">run_tests</span><span class="p">(</span><span class="n">n_processes</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
    <span class="n">tester</span><span class="o">.</span><span class="n">analyze_results</span><span class="p">()</span>
    <span class="n">tester</span><span class="o">.</span><span class="n">plot_optimal_utility_vs_process_params</span><span class="p">()</span>


<span class="c1"># Utility functions as functions of x without parameters</span>
<div class="viewcode-block" id="utility_power">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.utility_power">[docs]</a>
<span class="k">def</span> <span class="nf">utility_power</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span>  <span class="c1"># Equivalent to x ** 0.5</span></div>


<div class="viewcode-block" id="utility_exp">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.utility_exp">[docs]</a>
<span class="k">def</span> <span class="nf">utility_exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># Equivalent to alpha = 1.0</span></div>


<div class="viewcode-block" id="utility_log">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.utility_log">[docs]</a>
<span class="k">def</span> <span class="nf">utility_log</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>  <span class="c1"># Small constant to avoid log(0)</span></div>


<span class="c1"># Updated utility_functions list</span>
<span class="n">utility_functions</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Power&#39;</span><span class="p">,</span> <span class="s1">&#39;function&#39;</span><span class="p">:</span> <span class="n">utility_power</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Exponential&#39;</span><span class="p">,</span> <span class="s1">&#39;function&#39;</span><span class="p">:</span> <span class="n">utility_exp</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Logarithmic&#39;</span><span class="p">,</span> <span class="s1">&#39;function&#39;</span><span class="p">:</span> <span class="n">utility_log</span><span class="p">},</span>
<span class="p">]</span>

<span class="c1"># Define the agent class</span>
<div class="viewcode-block" id="AgentEvaluation">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.AgentEvaluation">[docs]</a>
<span class="k">class</span> <span class="nc">AgentEvaluation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    AgentEvaluation Class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the AgentEvaluation with the given model.</span>

<span class="sd">        :param model: Trained model for selecting processes</span>
<span class="sd">        :type model: Model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

<div class="viewcode-block" id="AgentEvaluation.select_process">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.AgentEvaluation.select_process">[docs]</a>
    <span class="k">def</span> <span class="nf">select_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoded_processes</span><span class="p">,</span> <span class="n">select_max</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select a process based on the model&#39;s predictions.</span>

<span class="sd">        :param encoded_processes: Encoded processes to choose from</span>
<span class="sd">        :param select_max: Whether to select the process with the maximum score</span>
<span class="sd">        :return: Index of the selected process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute scores for each process</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">encoded_processes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">select_max</span><span class="p">:</span>
            <span class="n">choice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">choice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">choice</span></div>
</div>


<span class="c1"># Main function</span>
<div class="viewcode-block" id="evaluate_utility_functions">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.agents.html#ergodicity.agents.evaluation.evaluate_utility_functions">[docs]</a>
<span class="k">def</span> <span class="nf">evaluate_utility_functions</span><span class="p">(</span><span class="n">utility_functions</span><span class="p">,</span> <span class="n">agent</span><span class="p">,</span> <span class="n">processes</span><span class="p">,</span> <span class="n">param_ranges</span><span class="p">,</span> <span class="n">n_process_batches</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_options</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_instances</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">select_max</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate utility functions based on agent choices.</span>
<span class="sd">    The utility functions are estimated according to the maximum likelihood of the agent&#39;s choices.</span>

<span class="sd">    :param utility_functions: List of utility functions to evaluate</span>
<span class="sd">    :rtype: List[Dict[str, float]]</span>
<span class="sd">    :param agent: An instance of the AgentEvaluation class</span>
<span class="sd">    :rtype agent: AgentEvaluation</span>
<span class="sd">    :param processes: A list of process types</span>
<span class="sd">    :rtype processes: List[Dict[str, str]]</span>
<span class="sd">    :param param_ranges: A dictionary of parameter ranges for each process type</span>
<span class="sd">    :rtype param_ranges: Dict[str, Dict[str, Tuple[float, float]]]</span>
<span class="sd">    :param n_process_batches: Number of process batches to evaluate</span>
<span class="sd">    :rtype n_process_batches: int</span>
<span class="sd">    :param n_options: Number of process options per batch</span>
<span class="sd">    :rtype n_options: int</span>
<span class="sd">    :param num_instances: Number of instances used in the expected utility calculation</span>
<span class="sd">    :rtype num_instances: int</span>
<span class="sd">    :param select_max: Whether to select the process with the maximum expected utility or with the minimum</span>
<span class="sd">    :rtype select_max: bool</span>
<span class="sd">    :return: Dictionary of likelihood scores for each utility function</span>
<span class="sd">    :rtype: Dict[str, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define the process encoder</span>
    <span class="n">process_encoder</span> <span class="o">=</span> <span class="n">ProcessEncoder</span><span class="p">()</span>

    <span class="c1"># Initialize counters for utility functions</span>
    <span class="n">utility_counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">uf</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">uf</span> <span class="ow">in</span> <span class="n">utility_functions</span><span class="p">}</span>

    <span class="c1"># Total number of batches</span>
    <span class="n">total_batches</span> <span class="o">=</span> <span class="n">n_process_batches</span>

    <span class="k">for</span> <span class="n">batch_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_process_batches</span><span class="p">):</span>
        <span class="c1"># For each batch, generate n_options processes</span>
        <span class="n">process_options</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">option_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_options</span><span class="p">):</span>
            <span class="c1"># Randomly select a process type</span>
            <span class="n">process_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">processes</span><span class="p">)</span>
            <span class="n">process_type</span> <span class="o">=</span> <span class="n">process_info</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
            <span class="n">process_class</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">process_type</span><span class="p">]</span>
            <span class="c1"># Randomly select parameters within specified ranges</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span> <span class="ow">in</span> <span class="n">param_ranges</span><span class="p">[</span><span class="n">process_type</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
            <span class="c1"># Create process instance</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">process_class</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
            <span class="c1"># Simulate the process to get final values x</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">num_instances</span><span class="o">=</span><span class="n">num_instances</span><span class="p">)</span>
            <span class="n">times</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">separate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="c1"># Get final values</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># x = np.maximum(x, 0.001)  # Ensure x is positive</span>
            <span class="c1"># Store the process data</span>
            <span class="n">process_data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;process&#39;</span><span class="p">:</span> <span class="n">process</span><span class="p">,</span>
                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x</span>
            <span class="p">}</span>
            <span class="n">process_options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process_data</span><span class="p">)</span>

        <span class="c1"># Encode the processes using ProcessEncoder</span>
        <span class="n">encoded_processes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">process_data</span> <span class="ow">in</span> <span class="n">process_options</span><span class="p">:</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">process_data</span><span class="p">[</span><span class="s1">&#39;process&#39;</span><span class="p">]</span>
            <span class="n">encoded_process</span> <span class="o">=</span> <span class="n">process_encoder</span><span class="o">.</span><span class="n">encode_process_with_time</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="n">encoded_processes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encoded_process</span><span class="p">)</span>
        <span class="n">encoded_processes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">encoded_processes</span><span class="p">)</span>

        <span class="c1"># The agent makes its choice</span>
        <span class="n">agent_choice</span> <span class="o">=</span> <span class="n">agent</span><span class="o">.</span><span class="n">select_process</span><span class="p">(</span><span class="n">encoded_processes</span><span class="p">,</span> <span class="n">select_max</span><span class="o">=</span><span class="n">select_max</span><span class="p">)</span>

        <span class="c1"># For each utility function, compute expected utilities and determine the process with the highest expected utility</span>
        <span class="k">for</span> <span class="n">uf</span> <span class="ow">in</span> <span class="n">utility_functions</span><span class="p">:</span>
            <span class="n">expected_utilities</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p_data</span> <span class="ow">in</span> <span class="n">process_options</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">p_data</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
                <span class="n">u_x</span> <span class="o">=</span> <span class="n">uf</span><span class="p">[</span><span class="s1">&#39;function&#39;</span><span class="p">](</span><span class="n">x</span><span class="p">)</span>
                <span class="n">expected_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">u_x</span><span class="p">)</span>
                <span class="n">expected_utilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expected_u</span><span class="p">)</span>
            <span class="c1"># Determine the process with the maximum expected utility</span>
            <span class="k">if</span> <span class="n">select_max</span><span class="p">:</span>
                <span class="n">utility_choice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">expected_utilities</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">utility_choice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">expected_utilities</span><span class="p">)</span>
            <span class="c1"># Compare with agent&#39;s choice</span>
            <span class="k">if</span> <span class="n">utility_choice</span> <span class="o">==</span> <span class="n">agent_choice</span><span class="p">:</span>
                <span class="n">utility_counts</span><span class="p">[</span><span class="n">uf</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># After all batches, calculate likelihood scores</span>
    <span class="n">likelihood_scores</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">uf</span> <span class="ow">in</span> <span class="n">utility_functions</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">utility_counts</span><span class="p">[</span><span class="n">uf</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span>
        <span class="n">likelihood</span> <span class="o">=</span> <span class="n">count</span> <span class="o">/</span> <span class="n">total_batches</span>
        <span class="n">likelihood_scores</span><span class="p">[</span><span class="n">uf</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">likelihood</span>

    <span class="c1"># Return the likelihood scores</span>
    <span class="k">return</span> <span class="n">likelihood_scores</span></div>


<span class="c1"># Example usage</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Instantiate the agent</span>
    <span class="n">agent</span> <span class="o">=</span> <span class="n">AgentEvaluation</span><span class="p">()</span>

    <span class="c1"># Evaluate utility functions</span>
    <span class="n">likelihood_scores</span> <span class="o">=</span> <span class="n">evaluate_utility_functions</span><span class="p">(</span>
        <span class="n">utility_functions</span><span class="o">=</span><span class="n">utility_functions</span><span class="p">,</span>
        <span class="n">agent</span><span class="o">=</span><span class="n">agent</span><span class="p">,</span>
        <span class="n">n_process_batches</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">n_options</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">num_instances</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">select_max</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># Print the likelihood scores</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Likelihood scores for each utility function:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="n">likelihood_scores</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">score</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Ergodicity Library</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Ihor Kendiukhov.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>