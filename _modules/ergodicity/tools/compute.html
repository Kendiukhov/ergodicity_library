<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ergodicity.tools.compute &#8212; Ergodicity Library 0.3.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../_static/documentation_options.js?v=e259d695"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ergodicity.tools.compute</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">compute Submodule</span>

<span class="sd">The `compute` submodule provides a comprehensive set of utilities and functions for performing various numerical computations and visualizations related to stochastic processes. This includes tools for calculating growth rates, visualizing time series data, and generating sample paths for different types of stochastic processes. Additionally, it offers advanced numerical methods, such as solving partial differential equations like the Fokker-Planck equation, which is essential for understanding the dynamics of stochastic processes.</span>

<span class="sd">Key Features:</span>

<span class="sd">1. **Visualization of Time Series Data**:</span>

<span class="sd">   - Functions like `visualize_function` and `average` allow for easy visualization of data over time, aiding in the analysis of simulated processes.</span>

<span class="sd">   - The submodule also supports visualizing more complex quantities such as growth rates and comparing them with theoretical models like Geometric Brownian Motion (GBM).</span>

<span class="sd">2. **Increment Calculation and Validation**:</span>

<span class="sd">   - Functions are decorated with `validate_input_shape` to ensure correct input data structure and shape.</span>

<span class="sd">   - Tools such as `growth_rates`, `growth_rate_of_average`, and `relative_increments` calculate the growth rates and relative increments for a variety of stochastic processes.</span>

<span class="sd">3. **Alpha-Stable Processes**:</span>

<span class="sd">   - The `demonstrate_alpha_stable_self_similarity` function illustrates the self-similarity property of alpha-stable processes.</span>

<span class="sd">   - It also allows for the comparison of different scaling factors and their effects on the distribution of end values, making it useful for simulating heavy-tailed distributions.</span>

<span class="sd">4. **Lévy and Gaussian Processes**:</span>

<span class="sd">   - This submodule includes functions to generate and simulate Lévy processes and Gaussian processes, such as `generate_levy_process` and `create_multivariate_gaussian_process`.</span>

<span class="sd">   - The matrix `A` is constructed from correlation matrices and variances to model multivariate Gaussian processes, enhancing the ability to work with correlated variables.</span>

<span class="sd">5. **Fokker-Planck Equation Solver**:</span>

<span class="sd">   - The `solve_fokker_planck_numerically` function numerically solves the Fokker-Planck equation using finite difference methods.</span>

<span class="sd">   - The solution is visualized in 3D, making it an invaluable tool for studying drift-diffusion processes and their time evolution.</span>

<span class="sd">6. **Statistical Tools**:</span>

<span class="sd">   - Functions such as `mu_sigma` and `compare_distributions` provide statistical insights, allowing the user to compute averages, variances, and distributions of stochastic processes over time.</span>

<span class="sd">Applications:</span>

<span class="sd">This submodule is useful in various fields, including:</span>

<span class="sd">- **Financial Modeling**: Simulation of processes like Geometric Brownian Motion and Lévy processes to study asset price dynamics and other market phenomena.</span>

<span class="sd">- **Physics and Environmental Science**: Modeling diffusion processes, random walks, and other phenomena where stochastic differential equations apply.</span>

<span class="sd">- **Machine Learning and Data Science**: Incorporating stochastic processes in optimization algorithms and reinforcement learning environments.</span>

<span class="sd">The `compute` submodule equips users with robust tools for simulating, visualizing, and analyzing stochastic processes. Whether working on theoretical models or practical applications, this submodule offers both simplicity and flexibility in dealing with complex stochastic dynamics.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">.helper</span> <span class="kn">import</span> <span class="n">separate</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">levy_stable</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">import</span> <span class="nn">plotly.graph_objects</span> <span class="k">as</span> <span class="nn">go</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">levy_stable</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">quad</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">integrate</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>

<div class="viewcode-block" id="visualize_function">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.visualize_function">[docs]</a>
<span class="k">def</span> <span class="nf">visualize_function</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize the given precomputed data evolution over time. The data should be a 2D array with the first row.</span>
<span class="sd">    This function is intended to work with the outputs of the other functions in this module.</span>

<span class="sd">    :param time: The time points for the data.</span>
<span class="sd">    :type time: np.ndarray</span>
<span class="sd">    :param data: The data to visualize.</span>
<span class="sd">    :type data: np.ndarray</span>
<span class="sd">    :param name: The name of the data to display.</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param save: Whether to save the plot as a PNG file.</span>
<span class="sd">    :type save: bool</span>
<span class="sd">    :return: None</span>
<span class="sd">    :rtype: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">time</span>
    <span class="n">num_instances</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;instance&#39;</span><span class="p">,</span> <span class="n">num_instances</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_instances</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Simulation of </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Value&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">.png&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="validate_input_shape">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.validate_input_shape">[docs]</a>
<span class="k">def</span> <span class="nf">validate_input_shape</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to validate the input shape of the data array for the functions in this module.</span>
<span class="sd">    The correct shape is a 2D array with the first row representing the time points and the remaining rows representing the instances.</span>

<span class="sd">    :param func: The function to decorate.</span>
<span class="sd">    :type func: Any</span>
<span class="sd">    :return: The decorated function.</span>
<span class="sd">    :rtype: Any</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper function to validate the input shape of the data array.</span>

<span class="sd">        :param data: The input data array.</span>
<span class="sd">        :type data: np.ndarray</span>
<span class="sd">        :param args: Additional positional arguments.</span>
<span class="sd">        :param kwargs: Additional keyword arguments.</span>
<span class="sd">        :return: The result of the decorated function.</span>
<span class="sd">        :rtype: Any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input data must be a numpy array&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input data must be a 2D array&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span></div>


<div class="viewcode-block" id="average">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.average">[docs]</a>
<span class="nd">@validate_input_shape</span>
<span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">visualize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the average over all instances for each time step.</span>

<span class="sd">    :param data: The input data array of shape (1 + number of instances, number of time steps).</span>
<span class="sd">    :type data: np.ndarray</span>
<span class="sd">    :param visualize: Whether to visualize the average values.</span>
<span class="sd">    :type visualize: bool</span>
<span class="sd">    :param name: The name of the data to display.</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param save: Whether to save the plot as a PNG file.</span>
<span class="sd">    :type save: bool</span>
<span class="sd">    :return: The average values for each time step.</span>
<span class="sd">    :rtype: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the average over all instances for each time step</span>
    <span class="n">average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">average</span><span class="p">])</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="n">visualize</span><span class="p">:</span>
        <span class="n">visualize_function</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">average</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">times</span><span class="p">,</span> <span class="n">average</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="growth_rates">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.growth_rates">[docs]</a>
<span class="nd">@validate_input_shape</span>
<span class="k">def</span> <span class="nf">growth_rates</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">visualize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;growth rates&quot;</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate cumulative log growth rates for each time step based on the input data.</span>

<span class="sd">    :param data: The input data array of shape (1 + number of instances, number of time steps).</span>
<span class="sd">    :type data: np.ndarray</span>
<span class="sd">    :param visualize: Whether to visualize the growth rates.</span>
<span class="sd">    :type visualize: bool</span>
<span class="sd">    :param name: The name of the data to display.</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param save: Whether to save the plot as a PNG file.</span>
<span class="sd">    :type save: bool</span>
<span class="sd">    :return: The cumulative log growth rates for each time step.</span>
<span class="sd">    :rtype: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Separate time row and instances data</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">instances</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Calculate cumulative log growth rates for each time step</span>
    <span class="c1"># Maybe bring it back instead of the next line</span>
    <span class="n">growth_rates_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">instances</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">instances</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

    <span class="c1"># Visualize the log growth rates</span>
    <span class="k">if</span> <span class="n">visualize</span><span class="p">:</span>
        <span class="n">visualize_function</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">growth_rates_data</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">)</span>

    <span class="c1"># Combine the time row and the average log growth rates into a new array</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">times</span><span class="p">,</span> <span class="n">growth_rates_data</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="growth_rate_of_average">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.growth_rate_of_average">[docs]</a>
<span class="nd">@validate_input_shape</span>
<span class="k">def</span> <span class="nf">growth_rate_of_average</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">visualize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the cumulative log growth rates for the average of all instances.</span>

<span class="sd">    :param data: The input data array of shape (1 + number of instances, number of time steps).</span>
<span class="sd">    :type data: np.ndarray</span>
<span class="sd">    :param visualize: Whether to visualize the growth rates.</span>
<span class="sd">    :type visualize: bool</span>
<span class="sd">    :param save: Whether to save the plot as a PNG file.</span>
<span class="sd">    :type save: bool</span>
<span class="sd">    :return: The cumulative log growth rates for the average of all instances.</span>
<span class="sd">    :rtype: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">average_values</span> <span class="o">=</span> <span class="n">average</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">visualize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">growth_rate_values</span> <span class="o">=</span> <span class="n">growth_rates</span><span class="p">(</span><span class="n">average_values</span><span class="p">,</span> <span class="n">visualize</span><span class="o">=</span><span class="n">visualize</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;growth rate of average&quot;</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">growth_rate_values</span></div>


<div class="viewcode-block" id="growth_rate_of_average_per_time">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.growth_rate_of_average_per_time">[docs]</a>
<span class="nd">@validate_input_shape</span>
<span class="k">def</span> <span class="nf">growth_rate_of_average_per_time</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the cumulative log growth rates for the average of all instances per time.</span>

<span class="sd">    :param data: The input data array of shape (1 + number of instances, number of time steps).</span>
<span class="sd">    :type data: np.ndarray</span>
<span class="sd">    :return: The cumulative log growth rates for the average of all instances per time.</span>
<span class="sd">    :rtype: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">growth_rate_values</span> <span class="o">=</span> <span class="n">growth_rate_of_average</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">visualize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">increments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">growth_rate_values</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

    <span class="n">average_increment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">increments</span><span class="p">)</span>

    <span class="c1"># divide by the time step</span>
    <span class="n">average_increment</span> <span class="o">=</span> <span class="n">average_increment</span> <span class="o">/</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">average_increment</span></div>


<div class="viewcode-block" id="average_growth_rate">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.average_growth_rate">[docs]</a>
<span class="nd">@validate_input_shape</span>
<span class="k">def</span> <span class="nf">average_growth_rate</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">visualize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the average of the cumulative log growth rates for all instances.</span>

<span class="sd">    :param data: The input data array of shape (1 + number of instances, number of time steps).</span>
<span class="sd">    :type data: np.ndarray</span>
<span class="sd">    :param visualize: Whether to visualize the average growth rates.</span>
<span class="sd">    :type visualize: bool</span>
<span class="sd">    :param save: Whether to save the plot as a PNG file.</span>
<span class="sd">    :type save: bool</span>
<span class="sd">    :return: The average of the cumulative log growth rates for all instances.</span>
<span class="sd">    :rtype: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">growth_rate_values</span> <span class="o">=</span> <span class="n">growth_rates</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">visualize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">average_growth_rate_values</span> <span class="o">=</span> <span class="n">average</span><span class="p">(</span><span class="n">growth_rate_values</span><span class="p">,</span> <span class="n">visualize</span><span class="o">=</span><span class="n">visualize</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;average growth rate&quot;</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">average_growth_rate_values</span></div>


<div class="viewcode-block" id="mu_sigma">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.mu_sigma">[docs]</a>
<span class="nd">@validate_input_shape</span>
<span class="k">def</span> <span class="nf">mu_sigma</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the average and standard deviation of the dataset.</span>

<span class="sd">    :param data: The input data array of shape (1 + number of instances, number of time steps).</span>
<span class="sd">    :type data: np.ndarray</span>
<span class="sd">    :return: The average and standard deviation of the dataset.</span>
<span class="sd">    :rtype: tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">instances</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Calculate the average and standard deviation of the dataset</span>
    <span class="n">average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">instances</span><span class="p">)</span>
    <span class="n">std_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">instances</span><span class="p">)</span>

    <span class="n">timestep</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">average</span> <span class="o">=</span> <span class="n">average</span> <span class="o">/</span> <span class="n">timestep</span>
    <span class="n">std_dev</span> <span class="o">=</span> <span class="n">std_dev</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">timestep</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">average</span><span class="p">,</span> <span class="n">std_dev</span></div>


<div class="viewcode-block" id="average_growth_rate_vs_gbm">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.average_growth_rate_vs_gbm">[docs]</a>
<span class="nd">@validate_input_shape</span>
<span class="k">def</span> <span class="nf">average_growth_rate_vs_gbm</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the average of the cumulative log growth rates for all instances and compare with the graph</span>
<span class="sd">    mu*t - 0.5*sigma^2*t</span>

<span class="sd">    :param data: The input data array of shape (1 + number of instances, number of time steps).</span>
<span class="sd">    :type data: np.ndarray</span>
<span class="sd">    :param save: Whether to save the plot as a PNG file.</span>
<span class="sd">    :type save: bool</span>
<span class="sd">    :return: The average of the cumulative log growth rates for all instances.</span>
<span class="sd">    :rtype: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">average_growth_rate_values</span> <span class="o">=</span> <span class="n">average_growth_rate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">visualize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">average_growth_rate_values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">data_increments</span> <span class="o">=</span> <span class="n">relative_increments</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">visualize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">mu_sigma</span><span class="p">(</span><span class="n">data_increments</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="n">gbm</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="n">times</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">times</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">average_growth_rate_values</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Average Growth Rate&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">gbm</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;GBM&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Comparison of Average Growth Rate and GBM&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Value&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;comparison_of_averages_vs_gbm.png&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">average_growth_rate_values</span></div>


<div class="viewcode-block" id="compare_averages">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.compare_averages">[docs]</a>
<span class="nd">@validate_input_shape</span>
<span class="k">def</span> <span class="nf">compare_averages</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare and plot average growth rate and growth rate of average.</span>

<span class="sd">    :param data: The input data array of shape (1 + number of instances, number of time steps).</span>
<span class="sd">    :type data: np.ndarray</span>
<span class="sd">    :param save: Whether to save the plot as a PNG file.</span>
<span class="sd">    :type save: bool</span>
<span class="sd">    :return: None</span>
<span class="sd">    :rtype: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">average_growth_rate_values</span> <span class="o">=</span> <span class="n">average_growth_rate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">visualize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">)</span>
    <span class="n">growth_rate_of_average_values</span> <span class="o">=</span> <span class="n">growth_rate_of_average</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">visualize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">)</span>

    <span class="c1"># Visualize the comparison of average growth rate and growth rate of average</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">average_growth_rate_values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">average_growth_rate_values</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Average Growth Rate&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">growth_rate_of_average_values</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Growth Rate of Average&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Comparison of Average Growth Rate and Growth Rate of Average&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Value&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;comparison_of_averages.png&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="demonstrate_alpha_stable_self_similarity">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.demonstrate_alpha_stable_self_similarity">[docs]</a>
<span class="k">def</span> <span class="nf">demonstrate_alpha_stable_self_similarity</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_points</span><span class="p">,</span> <span class="n">n_simulations</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Demonstrate the self-similarity of an α-stable process.</span>

<span class="sd">    :param alpha: Stability parameter (0 &lt; alpha &lt;= 2).</span>
<span class="sd">    :type alpha: float</span>
<span class="sd">    :param c: Scaling factor for time.</span>
<span class="sd">    :type c: float</span>
<span class="sd">    :param n_points: Number of points in each process realization.</span>
<span class="sd">    :type n_points: int</span>
<span class="sd">    :param n_simulations: Number of process realizations to generate.</span>
<span class="sd">    :type n_simulations: int</span>
<span class="sd">    :return: Figure and axes objects for the plot.</span>
<span class="sd">    :rtype: tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generate time points</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_points</span><span class="p">)</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">t</span>

    <span class="c1"># Generate α-stable increments</span>
    <span class="n">increments</span> <span class="o">=</span> <span class="n">levy_stable</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_simulations</span><span class="p">,</span> <span class="n">n_points</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Generate processes</span>
    <span class="n">X_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">increments</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">X_ct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">increments</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Prepend zeros to align with time points</span>
    <span class="n">X_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_simulations</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">X_t</span><span class="p">))</span>
    <span class="n">X_ct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_simulations</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">X_ct</span><span class="p">))</span>

    <span class="c1"># Plot results</span>
    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

    <span class="c1"># Plot sample paths</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_simulations</span><span class="p">)):</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">X_t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;X(t) - Sim </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">X_ct</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;X(ct) - Sim </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Sample Paths of α-Stable Process (α=</span><span class="si">{</span><span class="n">alpha</span><span class="si">}</span><span class="s1">, c=</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;X(t)&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

    <span class="c1"># Plot distributions</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">X_t</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;X(1)&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">X_ct</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">c</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">alpha</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;X(c)/c^(1/α)&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Distribution Comparison at t=1 and t=c&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Value&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Density&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

    <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span></div>


<div class="viewcode-block" id="relative_increments">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.relative_increments">[docs]</a>
<span class="nd">@validate_input_shape</span>
<span class="k">def</span> <span class="nf">relative_increments</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">visualize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the relative increments for each time step based on the input data.</span>

<span class="sd">    :param data: The input data array of shape (1 + number of instances, number of time steps).</span>
<span class="sd">    :type data: np.ndarray</span>
<span class="sd">    :param visualize: Whether to visualize the relative increments.</span>
<span class="sd">    :type visualize: bool</span>
<span class="sd">    :return: The relative increments for each time step.</span>
<span class="sd">    :rtype: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Separate time row and instances data</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">instances</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Calculate the relative increments for each time step</span>
    <span class="n">relative_increments</span> <span class="o">=</span> <span class="p">(</span><span class="n">instances</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">instances</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span> <span class="n">instances</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Visualize the relative increments</span>
    <span class="k">if</span> <span class="n">visualize</span><span class="p">:</span>
        <span class="n">visualize_function</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">relative_increments</span><span class="p">,</span> <span class="s2">&quot;relative increments&quot;</span><span class="p">)</span>

    <span class="c1"># Combine the time row and the relative increments into a new array</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">times</span><span class="p">,</span> <span class="n">relative_increments</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">result</span></div>


<span class="c1"># Demonstration</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.5</span>  <span class="c1"># Stability parameter</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">2.0</span>      <span class="c1"># Scaling factor</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">n_simulations</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">demonstrate_alpha_stable_self_similarity</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_points</span><span class="p">,</span> <span class="n">n_simulations</span><span class="p">)</span>

    <span class="c1"># Additional statistical comparison</span>
    <span class="n">X_1</span> <span class="o">=</span> <span class="n">levy_stable</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_simulations</span><span class="p">)</span>
    <span class="n">X_c</span> <span class="o">=</span> <span class="n">c</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">levy_stable</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_simulations</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean of X(1): </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_1</span><span class="p">)</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean of X(c)/c^(1/α): </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_c</span><span class="o">/</span><span class="n">c</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">alpha</span><span class="p">))</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Std of X(1): </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X_1</span><span class="p">)</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Std of X(c)/c^(1/α): </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X_c</span><span class="o">/</span><span class="n">c</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">alpha</span><span class="p">))</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<div class="viewcode-block" id="generate_levy_process">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.generate_levy_process">[docs]</a>
<span class="k">def</span> <span class="nf">generate_levy_process</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Function to generate a Lévy process with the given parameters.</span>

<span class="sd">    :param T: Time horizon.</span>
<span class="sd">    :type T: float</span>
<span class="sd">    :param N: Number of time steps.</span>
<span class="sd">    :type N: int</span>
<span class="sd">    :param alpha: Stability parameter (0 &lt; alpha &lt;= 2).</span>
<span class="sd">    :return: The generated Lévy process dataset.</span>
<span class="sd">    :rtype: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="n">N</span>
    <span class="n">dL</span> <span class="o">=</span> <span class="n">levy_stable</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dL</span><span class="p">)</span></div>



<div class="viewcode-block" id="compare_distributions">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.compare_distributions">[docs]</a>
<span class="k">def</span> <span class="nf">compare_distributions</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">scales</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">num_realizations</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare the scaled distributions of end values for Lévy processes with different scales to check self-similarity.</span>

<span class="sd">    :param alpha: Stability parameter (0 &lt; alpha &lt;= 2).</span>
<span class="sd">    :type alpha: float</span>
<span class="sd">    :param T: Time horizon.</span>
<span class="sd">    :type T: float</span>
<span class="sd">    :param N: Number of time steps.</span>
<span class="sd">    :type N: int</span>
<span class="sd">    :param scales: List of scales to compare.</span>
<span class="sd">    :type scales: list</span>
<span class="sd">    :param num_realizations:</span>
<span class="sd">    :type num_realizations: int</span>
<span class="sd">    :return: None</span>
<span class="sd">    :rtype: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">scale</span> <span class="ow">in</span> <span class="n">scales</span><span class="p">:</span>
        <span class="n">end_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_realizations</span><span class="p">):</span>
            <span class="c1"># Generate process for each realization</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">generate_levy_process</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>

            <span class="c1"># Store the end value of each process</span>
            <span class="n">end_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Scale the end values</span>
        <span class="n">scaled_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">end_values</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">scaled_values</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Scale: </span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s1">x&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Lévy Process (α=</span><span class="si">{</span><span class="n">alpha</span><span class="si">}</span><span class="s1">) - Scaled Distributions of End Values&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Scaled Value&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Density&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="create_A_from_correlation_and_variances">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.create_A_from_correlation_and_variances">[docs]</a>
<span class="k">def</span> <span class="nf">create_A_from_correlation_and_variances</span><span class="p">(</span><span class="n">correlation_matrix</span><span class="p">,</span> <span class="n">variances</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create matrix A from a given correlation matrix and variance vector.</span>

<span class="sd">    :param correlation_matrix: Desired correlation matrix R.</span>
<span class="sd">    :type correlation_matrix: np.ndarray</span>
<span class="sd">    :param variances: Desired variances for each process.</span>
<span class="sd">    :type variances: np.ndarray</span>
<span class="sd">    :return: The matrix used to create the multivariate Gaussian process.</span>
<span class="sd">    :rtype: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if correlation matrix is positive definite (all eigenvalues are positive)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">correlation_matrix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Correlation matrix must be positive definite.&quot;</span><span class="p">)</span>

    <span class="c1"># Step 1: Perform Cholesky decomposition on the correlation matrix</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">correlation_matrix</span><span class="p">)</span>

    <span class="c1"># Step 2: Create the diagonal matrix of standard deviations</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variances</span><span class="p">))</span>

    <span class="c1"># Step 3: Scale L by the standard deviations to obtain A</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="simulate_independent_gaussian_processes">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.simulate_independent_gaussian_processes">[docs]</a>
<span class="k">def</span> <span class="nf">simulate_independent_gaussian_processes</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate n independent Gaussian processes.</span>

<span class="sd">    :param n: Number of processes.</span>
<span class="sd">    :type n: int</span>
<span class="sd">    :param size: Number of time steps.</span>
<span class="sd">    :type size: int</span>
<span class="sd">    :param mean: Mean of the Gaussian distribution.</span>
<span class="sd">    :type mean: float</span>
<span class="sd">    :param std: Standard deviation of the Gaussian distribution.</span>
<span class="sd">    :type std: float</span>
<span class="sd">    :return: Matrix of independent Gaussian processes.</span>
<span class="sd">    :rtype: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span></div>


<div class="viewcode-block" id="create_multivariate_gaussian_process">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.create_multivariate_gaussian_process">[docs]</a>
<span class="k">def</span> <span class="nf">create_multivariate_gaussian_process</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">independent_processes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a multivariate Gaussian process by linearly combining independent Gaussian processes.</span>

<span class="sd">    :param A: Matrix to combine the independent processes.</span>
<span class="sd">    :type A: np.ndarray</span>
<span class="sd">    :param independent_processes: Matrix of independent Gaussian processes.</span>
<span class="sd">    :type independent_processes: np.ndarray</span>
<span class="sd">    :return: The multivariate Gaussian process.</span>
<span class="sd">    :rtype: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">independent_processes</span><span class="p">)</span></div>


<div class="viewcode-block" id="random_variable_from_pdf">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.random_variable_from_pdf">[docs]</a>
<span class="k">def</span> <span class="nf">random_variable_from_pdf</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate random variable samples from a given probability density function (pdf).</span>

<span class="sd">    :param pdf: Probability density function.</span>
<span class="sd">    :type pdf: sympy.core.add.Add</span>
<span class="sd">    :param x: Symbolic variable for the random variable.</span>
<span class="sd">    :type x: sympy.core.symbol.Symbol</span>
<span class="sd">    :param num_samples: Number of random variable samples to generate.</span>
<span class="sd">    :type num_samples: int</span>
<span class="sd">    :param t: Time parameter for the PDF (default is 1).</span>
<span class="sd">    :type t: float</span>
<span class="sd">    :return: Random variable samples.</span>
<span class="sd">    :rtype: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert sympy expression to numpy function</span>
    <span class="n">pdf_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)),</span> <span class="n">pdf</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span>

    <span class="c1"># Create a grid for x</span>
    <span class="n">x_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  <span class="c1"># Adjust range as needed</span>

    <span class="c1"># Compute the CDF numerically</span>
    <span class="n">cdf_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="n">pdf_func</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_vals</span><span class="p">])</span>

    <span class="c1"># Normalize CDF</span>
    <span class="n">cdf_vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdf_vals</span> <span class="o">-</span> <span class="n">cdf_vals</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">cdf_vals</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">cdf_vals</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

    <span class="c1"># Inverse CDF (interpolation)</span>
    <span class="n">inverse_cdf</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">cdf_vals</span><span class="p">,</span> <span class="n">x_vals</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>

    <span class="c1"># Generate uniform random numbers and apply inverse CDF</span>
    <span class="n">uniform_random</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
    <span class="n">random_samples</span> <span class="o">=</span> <span class="n">inverse_cdf</span><span class="p">(</span><span class="n">uniform_random</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">random_samples</span></div>



<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Example correlation matrix and variances</span>
    <span class="n">correlation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
    <span class="p">])</span>

    <span class="n">variances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>

    <span class="c1"># Create matrix A</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">create_A_from_correlation_and_variances</span><span class="p">(</span><span class="n">correlation_matrix</span><span class="p">,</span> <span class="n">variances</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Matrix A:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>


<div class="viewcode-block" id="solve_fokker_planck_numerically">
<a class="viewcode-back" href="../../../ergodicity/docs/source/ergodicity.tools.html#ergodicity.tools.compute.solve_fokker_planck_numerically">[docs]</a>
<span class="k">def</span> <span class="nf">solve_fokker_planck_numerically</span><span class="p">(</span><span class="n">mu_func</span><span class="p">,</span> <span class="n">sigma_func</span><span class="p">,</span> <span class="n">P0_func</span><span class="p">,</span> <span class="n">x_range</span><span class="p">,</span> <span class="n">t_range</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Nt</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve the Fokker-Planck equation numerically using finite differences and visualize the result in 3D.</span>

<span class="sd">    :param mu_func: Function for drift term, mu(x, t).</span>
<span class="sd">    :type mu_func: function</span>
<span class="sd">    :param sigma_func: Function for diffusion term, sigma(x, t).</span>
<span class="sd">    :type sigma_func: function</span>
<span class="sd">    :param P0_func: Function for the initial condition P(x, 0).</span>
<span class="sd">    :type P0_func: function</span>
<span class="sd">    :param x_range: Tuple (x_min, x_max) defining the spatial domain.</span>
<span class="sd">    :type x_range: Tuple[float, float]</span>
<span class="sd">    :param t_range: Tuple (t_min, t_max) defining the time domain.</span>
<span class="sd">    :type t_range: Tuple[float, float]</span>
<span class="sd">    :param Nx: Number of spatial grid points.</span>
<span class="sd">    :type Nx: int</span>
<span class="sd">    :param Nt: Number of time steps.</span>
<span class="sd">    :type Nt: int</span>
<span class="sd">    :param boundary_conditions: Tuple specifying Dirichlet boundary conditions as (P(x_min, t), P(x_max, t)).</span>
<span class="sd">    :type boundary_conditions: Tuple[float, float]</span>
<span class="sd">    :return: Arrays for the solution P(x, t) at each time step and the spatial grid points.</span>
<span class="sd">    :rtype: Tuple[np.ndarray, np.ndarray, np.ndarray]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Discretize space and time</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="n">x_range</span>
    <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="n">t_range</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Spatial step</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_max</span> <span class="o">-</span> <span class="n">t_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Time step (fixed for entire range of t)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">Nt</span><span class="p">)</span>

    <span class="c1"># Initialize solution array</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nt</span><span class="p">,</span> <span class="n">Nx</span><span class="p">))</span>

    <span class="c1"># Set initial condition P(x, 0)</span>
    <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">P0_func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Boundary conditions</span>
    <span class="n">P</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># P(x_min, t)</span>
    <span class="n">P</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># P(x_max, t)</span>

    <span class="c1"># Finite difference loop</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Skip the boundary points</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">mu_func</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma_func</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

            <span class="c1"># Central difference for second derivative (diffusion term)</span>
            <span class="n">d2P_dx2</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">P</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="c1"># Central difference for first derivative (drift term)</span>
            <span class="n">dP_dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">P</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span>

            <span class="c1"># Update P using finite differences</span>
            <span class="n">P</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">mu</span> <span class="o">*</span> <span class="n">dP_dx</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">d2P_dx2</span><span class="p">)</span>

    <span class="c1"># Plot the result in 3D</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Space (x)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Time (t)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;P(x, t)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Numerical Solution of Fokker-Planck Equation&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">P</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Example usage with arbitrary drift and diffusion terms</span>

    <span class="c1"># Define drift term: mu(x,t) = x - t</span>
    <span class="n">mu_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">t</span>

    <span class="c1"># Define diffusion term: sigma(x,t) = x**2 + t</span>
    <span class="n">sigma_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">t</span>

    <span class="c1"># Define initial condition: P(x, 0) = exp(-x**2)</span>
    <span class="n">P0_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Define boundary conditions: P(x_min, t) = 0, P(x_max, t) = 0</span>
    <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Dirichlet boundary conditions at both ends</span>

    <span class="c1"># Spatial and time ranges</span>
    <span class="n">x_range</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># x from -5 to 5</span>
    <span class="n">t_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># t from 0 to 1</span>

    <span class="c1"># Number of spatial grid points and time steps</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="c1"># Solve the Fokker-Planck equation numerically and visualize</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">solve_fokker_planck_numerically</span><span class="p">(</span><span class="n">mu_func</span><span class="p">,</span> <span class="n">sigma_func</span><span class="p">,</span> <span class="n">P0_func</span><span class="p">,</span> <span class="n">x_range</span><span class="p">,</span> <span class="n">t_range</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Nt</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Ergodicity Library</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Ihor Kendiukhov.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>